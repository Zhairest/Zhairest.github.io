<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>ECS架构</title>
      <link href="/2023/03/10/ECS%E6%9E%B6%E6%9E%84/"/>
      <url>/2023/03/10/ECS%E6%9E%B6%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<p><a href="https://blog.codingnow.com/2017/06/overwatch_ecs.html">浅谈《守望先锋》中的 ECS 构架</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity基础</title>
      <link href="/2023/03/10/Unity%E5%9F%BA%E7%A1%80/"/>
      <url>/2023/03/10/Unity%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h1 id="Unity脚本的生命周期"><a href="#Unity脚本的生命周期" class="headerlink" title="Unity脚本的生命周期"></a>Unity脚本的生命周期</h1><h3 id="脚本生命周期流程图"><a href="#脚本生命周期流程图" class="headerlink" title="脚本生命周期流程图"></a>脚本生命周期流程图</h3><p>重要函数：</p><p><strong>Awake-&gt;OnEnable-&gt;Start-&gt;FixedUpdate-&gt;Update-&gt;LateUpdate-&gt;OnDisable-&gt;OnDestroy</strong></p><p><a href="https://docs.unity3d.com/cn/current/Manual/ExecutionOrder.html">事件函数的执行顺序</a></p><p><a href="https://zhuanlan.zhihu.com/p/551294000">Unity 脚本的生命周期</a></p><p><img src="https://docs.unity3d.com/cn/current/uploads/Main/monobehaviour_flowchart.svg" alt="img"></p><h1 id="协程-线程"><a href="#协程-线程" class="headerlink" title="协程 线程"></a>协程 线程</h1><p><a href="https://blog.csdn.net/vinkey_st/article/details/126759402">Unity的协程详解</a></p><p><a href="https://blog.csdn.net/xinzhilinger/article/details/116240688">Unity 协程(Coroutine)原理与用法详解</a></p><p><a href="https://www.cnblogs.com/iwiniwin/p/14878498.html">Unity协程背后的实现原理 </a></p><h2 id="线程与协程有什么区别呢："><a href="#线程与协程有什么区别呢：" class="headerlink" title="线程与协程有什么区别呢："></a>线程与协程有什么区别呢：</h2><ul><li><strong>两者在内存的使用上是相同的，共享堆，不共享栈</strong></li><li><strong>对于协程而言，同一时间只能执行一个协程，而线程则是并发的，可以同时有多个线程在运行</strong></li></ul><img src="/2023/03/10/Unity%E5%9F%BA%E7%A1%80/image-20230310190603993.png" class title="image-20230310190603993"><p>两者最关键，最简单的区别是微观上<strong>线程是并行（对于多核CPU）的</strong>，而<strong>协程是串行</strong>的。</p><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>​    协程，从字面意义上理解就是协助程序的意思，<strong>我们在主任务进行的同时，需要一些分支任务配合工作</strong>来达到最终的效果</p><p>​    <strong>稍微形象的解释一下，想象一下，在进行主任务的过程中我们需要一个对资源消耗极大的操作时候，如果在一帧中实现这样的操作，游戏就会变得十分卡顿，这个时候，我们就可以通过协程，在一定帧内完成该工作的处理，同时不影响主任务的进行。</strong></p><p>​    当我们需要进行一些分时操作时，可以使用协程，它可以让我们的程序随时间推移发生一系列的事件</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>​    协程不是线程，协程依旧是在主线程中进行</p><p>​    <a href="https://www.bilibili.com/video/BV18R4y1t7Hg">然后要知道协程是通过迭代器来实现功能的，通过关键字<code>IEnumerator</code>来定义一个迭代方法，注意使用的是<code>IEnumerator</code>，而不是<code>IEnumerable</code>：两者之间的区别：</a></p><ul><li><code>IEnumerator</code>：是一个实现迭代器功能的接口</li><li><code>IEnumerable</code>：是在<code>IEnumerator</code>基础上的一个封装接口，有一个<code>GetEnumerator()</code>方法返回<code>IEnumerator</code></li></ul><h2 id="协程的使用"><a href="#协程的使用" class="headerlink" title="协程的使用"></a>协程的使用</h2><p>​    首先通过一个迭代器定义一个返回值为IEnumerator的方法，然后再程序中通过StartCoroutine来开启一个协程即可：</p><p>​    在正式开始代码之前，需要了解StartCoroutine的两种重载方式：</p><ul><li>StartCoroutine（string methodName）：这种是没有参数的情况，直接通过方法名（字符串形式）来开启协程</li><li>StartCoroutine（IEnumerator routine）：通过方法形式调用</li><li>StartCoroutine（string methodName，object values):带参数的通过方法名进行调用</li></ul><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过迭代器定义一个方法</span></span><br><span class="line"><span class="function">IEnumerator <span class="title">Demo</span>(<span class="params"><span class="built_in">int</span> i</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//代码块</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line"><span class="comment">//代码块</span></span><br><span class="line">   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在程序种调用协程</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Test</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//第一种与第二种调用方式,通过方法名与参数调用</span></span><br><span class="line">    StartCoroutine(<span class="string">&quot;Demo&quot;</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//第三种调用方式， 通过调用方法直接调用</span></span><br><span class="line">    StartCoroutine(Demo(<span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    在一个协程开始后，同样会对应一个结束协程的方法StopCoroutine与StopAllCoroutines两种方式，但是需要注意的是，两者的使用需要遵循一定的规则，在介绍规则之前，同样介绍一下关于StopCoroutine重载：</p><ul><li>StopCoroutine（string methodName）：通过方法名（字符串）来进行</li><li>StopCoroutine（IEnumerator routine）:通过方法形式来调用</li><li>StopCoroutine(Coroutine routine)：通过指定的协程来关闭</li></ul><p>如果我们是使用<code>StartCoroutine（string methodName）</code>来开启一个协程的，那么结束协程就只能使用<code>StopCoroutine（string methodName）</code>和<code>StopCoroutine(Coroutine routine)</code>来结束协程。</p><h2 id="yield"><a href="#yield" class="headerlink" title="yield"></a>yield</h2><p>​    如果你了解<code>Unity</code>的脚本的生命周期，你一定对<code>yield</code>这几个关键词很熟悉，没错，<code>yield</code> 也是脚本生命周期的一些执行方法，不同的<code>yield</code> 的方法处于生命周期的不同位置</p><img src="/2023/03/10/Unity%E5%9F%BA%E7%A1%80/image-20230310195518316.png" class title="image-20230310195518316"><p>首先解释一下位于Update与LateUpdate之间这些yield 的含义：</p><ul><li><p>yield return null; 暂停协程等待下一帧继续执行</p></li><li><p>yield return 0或其他数字; 暂停协程等待下一帧继续执行</p></li><li><p>yield return new WairForSeconds(时间); 等待规定时间后继续执行</p></li><li><p>yield return StartCoroutine(“协程方法名”);开启一个协程（嵌套协程)</p></li></ul><img src="/2023/03/10/Unity%E5%9F%BA%E7%A1%80/image-20230310195822997.png" class title="image-20230310195822997"><p>​    可以很清晰的看出，协程虽然是在<code>Update</code>中开启，但是关于<code>yield return null</code>后面的代码会在下一帧运行，并且是在Update执行完之后才开始执行，但是会在<code>LateUpdate</code>之前执行。</p><h2 id="具体用处"><a href="#具体用处" class="headerlink" title="具体用处"></a>具体用处</h2><h3 id="将一个复杂程序分帧执行："><a href="#将一个复杂程序分帧执行：" class="headerlink" title="将一个复杂程序分帧执行："></a>将一个复杂程序分帧执行：</h3><p>​    如果一个复杂的函数对于一帧的性能需求很大，我们就可以通过yield return null将步骤拆除，从而将性能压力分摊开来，最终获取一个流畅的过程，这就是一个简单的应用</p><p>​    举一个案例，如果某一时刻需要使用Update读取一个列表，这样一般需要一个循环去遍历列表，这样每帧的代码执行量就比较大，就可以将这样的执行放置到协程中来处理：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Test</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;<span class="built_in">int</span>&gt; nums = <span class="keyword">new</span> List&lt;<span class="built_in">int</span>&gt; &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Update</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(Input.GetKeyDown(KeyCode.Space))</span><br><span class="line">        &#123;</span><br><span class="line">            StartCoroutine(PrintNum(nums));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//通过协程分帧处理</span></span><br><span class="line">    <span class="function">IEnumerator <span class="title">PrintNum</span>(<span class="params">List&lt;<span class="built_in">int</span>&gt; nums</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">foreach</span>(<span class="built_in">int</span> i <span class="keyword">in</span> nums)</span><br><span class="line">        &#123;</span><br><span class="line">            Debug.Log(i);</span><br><span class="line">            <span class="keyword">yield</span> <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="进行计时器工作"><a href="#进行计时器工作" class="headerlink" title="进行计时器工作"></a>进行计时器工作</h3><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">IEnumerator <span class="title">Test</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Debug.Log(<span class="string">&quot;开始&quot;</span>);</span><br><span class="line">    <span class="function"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title">WaitForSeconds</span>(<span class="params"><span class="number">3</span></span>)</span>;</span><br><span class="line">    Debug.Log(<span class="string">&quot;输出开始后三秒后执行我&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="异步加载等功能"><a href="#异步加载等功能" class="headerlink" title="异步加载等功能"></a>异步加载等功能</h3><p>​    只要一说到异步，就必定离不开协程，因为在异步加载过程中可能会影响到其他任务的进程，这个时候就需要通过协程将这些可能被影响的任务剥离出来</p><p>常见的异步操作有：</p><ul><li><code>AB</code>包资源的异步加载</li><li><code>Reaources</code>资源的异步加载</li><li>场景的异步加载</li><li><code>WWW</code>模块的异步请求</li></ul><p><a href="https://blog.csdn.net/xinzhilinger/article/details/110836837">Unity 场景异步加载（加载界面的实现）</a></p><h2 id="Unity实际应用"><a href="#Unity实际应用" class="headerlink" title="Unity实际应用"></a>Unity实际应用</h2><p><strong>子弹随着时间流逝逐渐变得透明</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">IEnumerator <span class="title">Fade</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Color c = renderer.material.color;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">float</span> alpha = <span class="number">1f</span>; alpha &gt;= <span class="number">0</span>; alpha -= <span class="number">0.1f</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        c.a = alpha;</span><br><span class="line">        renderer.material.color = c;</span><br><span class="line">        <span class="keyword">yield</span> <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    简单的说，协程就是一种特殊的函数，它可以主动的请求暂停自身并提交一个唤醒条件，Unity会在唤醒条件满足的时候去重新唤醒协程。</p><p>​    <code>MonoBehaviour.StartCoroutine()</code>方法可以开启一个协程，这个协程会挂在该<code>MonoBehaviour</code>下。</p><p>​    在<code>MonoBehaviour</code>生命周期的<code>Update</code>和<code>LateUpdate</code>之间，会检查这个<code>MonoBehaviour</code>下挂载的所有协程，并唤醒其中满足唤醒条件的协程。</p><p>​    要想使用协程，只需要以<code>IEnumerator</code>为返回值，并且在函数体里面用<code>yield return</code>语句来暂停协程并提交一个唤醒条件。然后使用<code>StartCoroutine</code>来开启协程。</p><h1 id="FixedUpdate、Update、LateUpdate"><a href="#FixedUpdate、Update、LateUpdate" class="headerlink" title="FixedUpdate、Update、LateUpdate"></a>FixedUpdate、Update、LateUpdate</h1><ul><li>FixedUpdate：每隔固定时间执行一次（可设置）</li><li>Update: 每一帧执行一次</li><li>LateUpdate：每一帧执行一次，但会在所有Update都执行完之后才会执行</li></ul><p>​    当FixedUpdate的设定大于实际运行速度时（比如设定每秒执行五十帧但实际上运行速率只有每秒三十帧）：Unity会尝试多次调用FixedUpdate（为了和Update同步）。</p><p>​    当FixedUpdate运行速度非常慢时：庞大的运算量会拖慢每一帧的时间，所以每一帧会尝试多次调用FixedUpdate，卡顿非常严重</p><p><a href="https://blog.csdn.net/Marine_snow/article/details/117127889">Unity3D Update和FixedUpdate的区别及深入探讨</a></p><h1 id="有哪几种动画，他们的区别是什么？"><a href="#有哪几种动画，他们的区别是什么？" class="headerlink" title="有哪几种动画，他们的区别是什么？"></a>有哪几种动画，他们的区别是什么？</h1><ul><li>关键帧动画：每一帧动画序列当中包含了顶点的空间位置信息以及改变量，然后通过插值运算，得出动画效果。选中某一游戏对象，创建animation，添加属性Transform，MeshRender、collider。还可以添加关键帧，在关键帧上Add Animation Event事件。</li><li>骨骼动画：模型当中有一个骨骼结构层次的对象，存储了各个骨骼在空间内的位置信息。皮肤蒙皮附着在骨骼上，决定了角色的外观，每一个顶点数据都会随着多个骨骼影响而改变，从而实现动画效果。创建animator将各个动画拖入到动画状态机当中，设置参数，连接各个动画状态，在通过脚本控制来实现动画控制</li><li>关节动画：骨骼动画的前身，模型分成N个部分网格，分成部分动画，组成一个整体动画</li></ul><h1 id="物体发生碰撞的必要条件是什么？"><a href="#物体发生碰撞的必要条件是什么？" class="headerlink" title="物体发生碰撞的必要条件是什么？"></a>物体发生碰撞的必要条件是什么？</h1><p>物体A有(Collider和Rigidbody)或者CharacterController，物体B有collider</p><ul><li>rigidbody完全受物理引擎影响</li><li>CharacterController物理引擎影响受限制</li></ul><h1 id="有限状态机FSM"><a href="#有限状态机FSM" class="headerlink" title="有限状态机FSM"></a>有限状态机FSM</h1><p>Unity 有限状态机（FSM）的框架结构:<a href="https://blog.csdn.net/xinzhilinger/article/details/115840911">https://blog.csdn.net/xinzhilinger/article/details/115840911</a></p><h1 id="图集"><a href="#图集" class="headerlink" title="图集"></a>图集</h1><p>图集是将很多零碎的2D小图整合成一张大图，方便unity渲染合批，降低渲染消耗。</p><p><a href="https://blog.csdn.net/xinzhilinger/article/details/116043662">Unity 将Sprite打包进图集</a></p><h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h3><h4 id="1-UI的合批处理，减少DrawCall"><a href="#1-UI的合批处理，减少DrawCall" class="headerlink" title="1.UI的合批处理，减少DrawCall"></a>1.UI的合批处理，减少DrawCall</h4><p>多张图片需要多次DrawCall，合并成一张大图只需要调用一次DrawCall</p><h4 id="2-减少对内存的占用"><a href="#2-减少对内存的占用" class="headerlink" title="2.减少对内存的占用"></a>2.减少对内存的占用</h4><p>OpenGL每张贴图都需要设置为2的N次方才能使用，假设有宽高分别为100x100、10x10的两张图片，如果不合成大贴图，那么就需要分别使用128x128和16x16的图片，会浪费一部分内存空间。</p><p>如果是使用一张大图的话，就可以将两张图片打到128x128的图集，进而减少内存的占用。</p><h4 id="3-提升效率"><a href="#3-提升效率" class="headerlink" title="3.提升效率"></a>3.提升效率</h4><p>图片尺寸为2的次幂时，GPU处理起来会快很多，小图不可能做不到每张图都是2的次幂的，但打成一张大图就可以。</p><h1 id="Drawcall"><a href="#Drawcall" class="headerlink" title="Drawcall"></a>Drawcall</h1><p><a href="https://zhuanlan.zhihu.com/p/358687016">Unity:浅谈对Drawcall的理解</a></p><h1 id="关于UI框架的实现思路"><a href="#关于UI框架的实现思路" class="headerlink" title="关于UI框架的实现思路"></a>关于UI框架的实现思路</h1><p><a href="https://blog.csdn.net/qq_21315789/article/details/125591416">https://blog.csdn.net/qq_21315789/article/details/125591416</a></p><h1 id="Lua如何实现面向对象的三大特性"><a href="#Lua如何实现面向对象的三大特性" class="headerlink" title="Lua如何实现面向对象的三大特性"></a>Lua如何实现面向对象的三大特性</h1><p><a href="https://blog.csdn.net/IQsuper/article/details/117804746">https://blog.csdn.net/IQsuper/article/details/117804746</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Unity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法合集 C++ 剑指Offer</title>
      <link href="/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/"/>
      <url>/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h1 id="C-基础"><a href="#C-基础" class="headerlink" title="C++基础"></a>C++基础</h1><p><a href="https://blog.csdn.net/qiancm/article/details/119611928">vector 详解</a></p><p><a href="https://blog.csdn.net/acc_hoyh/article/details/122974190">string详解</a></p><p><a href="https://blog.csdn.net/qq_42185999/article/details/115331051">queue详解</a></p><h1 id="搜索与回溯算法-二叉树相关"><a href="#搜索与回溯算法-二叉树相关" class="headerlink" title="搜索与回溯算法 二叉树相关"></a>搜索与回溯算法 二叉树相关</h1><p>剑指Offer题目</p><h3 id="32-从上到下打印出二叉树的每个节点，同一层的节点按照从左到右的顺序打印。"><a href="#32-从上到下打印出二叉树的每个节点，同一层的节点按照从左到右的顺序打印。" class="headerlink" title="32.从上到下打印出二叉树的每个节点，同一层的节点按照从左到右的顺序打印。"></a>32.从上到下打印出二叉树的每个节点，同一层的节点按照从左到右的顺序打印。</h3><img src="/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/image-20230310110433552.png" class title="image-20230310110433552"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">levelOrder</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//二叉树的层序遍历</span></span><br><span class="line">        <span class="comment">//利用队列先进先出的特性</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        queue&lt;TreeNode*&gt; q;</span><br><span class="line">        q.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            TreeNode* node =q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            ans.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">            <span class="keyword">if</span>(node-&gt;left) q.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">            <span class="keyword">if</span>(node-&gt;right) q.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="32-从上到下按层打印二叉树，同一层的节点按从左到右的顺序打印，每一层打印到一行。"><a href="#32-从上到下按层打印二叉树，同一层的节点按从左到右的顺序打印，每一层打印到一行。" class="headerlink" title="32.从上到下按层打印二叉树，同一层的节点按从左到右的顺序打印，每一层打印到一行。"></a>32.从上到下按层打印二叉树，同一层的节点按从左到右的顺序打印，每一层打印到一行。</h3><img src="/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/image-20230310110545093.png" class title="image-20230310110545093"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">levelOrder</span>(TreeNode* root) &#123;</span><br><span class="line">                </span><br><span class="line">        <span class="comment">/* 根据函数返回值定义存储结果的变量 */</span></span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; result;</span><br><span class="line">        <span class="comment">/* 定义一个队列用于存储节点的数据 */</span></span><br><span class="line">        queue&lt;TreeNode*&gt; que;</span><br><span class="line">        <span class="comment">/* 判空 */</span></span><br><span class="line">        <span class="keyword">if</span>(root != <span class="literal">NULL</span>) que.<span class="built_in">push</span>(root);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 开始层序遍历 */</span></span><br><span class="line">        <span class="keyword">while</span>(!que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="comment">/* 计算队列的大小也即有多少个孩子 */</span></span><br><span class="line">            <span class="keyword">int</span> size = que.<span class="built_in">size</span>();</span><br><span class="line">            <span class="comment">/* 定义一个临时vector 存储每一层 */</span></span><br><span class="line">            vector&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line">            <span class="comment">/* 层序遍历 */</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                <span class="comment">/* 获取第一个节点数据 */</span></span><br><span class="line">                TreeNode* node = que.<span class="built_in">front</span>();</span><br><span class="line">                que.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">                vec.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">                <span class="keyword">if</span>(node-&gt;left != <span class="literal">NULL</span>) que.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">                <span class="keyword">if</span>(node-&gt;right != <span class="literal">NULL</span>) que.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/* 将一层的数据保存 */</span></span><br><span class="line">            result.<span class="built_in">push_back</span>(vec);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="32-请实现一个函数按照之字形顺序打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右到左的顺序打印，第三行再按照从左到右的顺序打印，其他行以此类推。"><a href="#32-请实现一个函数按照之字形顺序打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右到左的顺序打印，第三行再按照从左到右的顺序打印，其他行以此类推。" class="headerlink" title="32.请实现一个函数按照之字形顺序打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右到左的顺序打印，第三行再按照从左到右的顺序打印，其他行以此类推。"></a>32.请实现一个函数按照之字形顺序打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右到左的顺序打印，第三行再按照从左到右的顺序打印，其他行以此类推。</h3><img src="/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/image-20230310110623326.png" class title="image-20230310110623326"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">levelOrder</span>(TreeNode* root) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;res;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>) <span class="keyword">return</span> res;</span><br><span class="line">       </span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> flag=<span class="number">-1</span>;</span><br><span class="line">        queue&lt;TreeNode*&gt;q;</span><br><span class="line">        q.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="keyword">int</span> q_size=q.<span class="built_in">size</span>();</span><br><span class="line">            res.<span class="built_in">push_back</span>(vector&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">            flag=-flag;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;q_size;i++)&#123;</span><br><span class="line">                <span class="keyword">auto</span> s=q.<span class="built_in">front</span>();</span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line">                res.<span class="built_in">back</span>().<span class="built_in">push_back</span>(s-&gt;val);</span><br><span class="line">                <span class="keyword">if</span>(s-&gt;left)&#123;q.<span class="built_in">push</span>(s-&gt;left);&#125;</span><br><span class="line">                <span class="keyword">if</span>(s-&gt;right)&#123;q.<span class="built_in">push</span>(s-&gt;right);&#125;</span><br><span class="line">            &#125;</span><br><span class="line">                <span class="keyword">if</span>(flag==<span class="number">-1</span>)&#123;<span class="built_in">reverse</span>(res.<span class="built_in">back</span>().<span class="built_in">begin</span>(),res.<span class="built_in">back</span>().<span class="built_in">end</span>());&#125;<span class="comment">//翻转输出</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="33-输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历结果。如果是则返回-true，否则返回-false。假设输入的数组的任意两个数字都互不相同。"><a href="#33-输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历结果。如果是则返回-true，否则返回-false。假设输入的数组的任意两个数字都互不相同。" class="headerlink" title="33.输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历结果。如果是则返回 true，否则返回 false。假设输入的数组的任意两个数字都互不相同。"></a>33.输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历结果。如果是则返回 <code>true</code>，否则返回 <code>false</code>。假设输入的数组的任意两个数字都互不相同。</h3><img src="/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/image-20230310110703417.png" class title="image-20230310110703417"><h4 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h4><p><strong>二叉搜索树（BST）</strong>的定义是：对于任意一个节点，它的左子树的所有节点的值都小于该节点的值，而它的右子树的所有节点的值都大于该节点的值。</p><p>二叉搜索树的后序遍历序列中，最后一个数字是树的根节点的值，而前面的数字可以分为两部分：</p><ol><li><strong>第一部分是左子树节点的值，它们都小于根节点的值；</strong></li><li><strong>第二部分是右子树节点的值，它们都大于根节点的值。</strong></li></ol><p>我们可以根据这个特点，递归地判断每个子树是否符合二叉搜索树的定义。</p><h4 id="具体地，我们可以首先找到根节点的位置，然后分别递归判断左子树和右子树是否为二叉搜索树。"><a href="#具体地，我们可以首先找到根节点的位置，然后分别递归判断左子树和右子树是否为二叉搜索树。" class="headerlink" title="具体地，我们可以首先找到根节点的位置，然后分别递归判断左子树和右子树是否为二叉搜索树。"></a>具体地，我们可以首先找到根节点的位置，然后分别递归判断左子树和右子树是否为二叉搜索树。</h4><p>​    递归的过程中，需要注意以下几点：</p><ol><li>对于左子树和右子树，需要分别处理前半部分和后半部分的数组；</li><li>对于空子树，直接返回 true；</li><li>对于只有一个节点的子树，也认为它是二叉搜索树。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">verifyPostorder</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; sequence)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(sequence.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">int</span> n = sequence.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> root = sequence[n - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; n - <span class="number">1</span> &amp;&amp; sequence[i] &lt; root) &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> j = i;</span><br><span class="line">        <span class="keyword">while</span> (j &lt; n - <span class="number">1</span> &amp;&amp; sequence[j] &gt; root) &#123;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (j != n - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">left</span><span class="params">(sequence.begin(), sequence.begin() + i)</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">right</span><span class="params">(sequence.begin() + i, sequence.end() - <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">return</span> (left.<span class="built_in">empty</span>() || <span class="built_in">verifyPostorder</span>(left)) &amp;&amp; (right.<span class="built_in">empty</span>() || <span class="built_in">verifyPostorder</span>(right));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="搜索与回溯算法-树相关"><a href="#搜索与回溯算法-树相关" class="headerlink" title="搜索与回溯算法 树相关"></a>搜索与回溯算法 树相关</h1><h3 id="26-输入两棵二叉树A和B，判断B是不是A的子结构。-约定空树不是任意一个树的子结构"><a href="#26-输入两棵二叉树A和B，判断B是不是A的子结构。-约定空树不是任意一个树的子结构" class="headerlink" title="26.输入两棵二叉树A和B，判断B是不是A的子结构。(约定空树不是任意一个树的子结构)"></a>26.输入两棵二叉树A和B，判断B是不是A的子结构。(约定空树不是任意一个树的子结构)</h3><p>B是A的子结构， 即 A中有出现和B相同的结构和节点值。</p><img src="/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/image-20230310111801195.png" class title="image-20230310111801195"><p>​    刚开始的思路就是对俩颗树进行先序遍历，若A遍历结果包含了B，则输出true</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">Cclass Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">     <span class="function"><span class="keyword">bool</span> <span class="title">isSubStructure</span><span class="params">(TreeNode* A, TreeNode* B)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//可以改写为判断 二者的先序遍历中有无相同部分</span></span><br><span class="line">        string a1=<span class="built_in">XianXu</span>(A);</span><br><span class="line">        string a2=<span class="built_in">XianXu</span>(B);</span><br><span class="line">        <span class="keyword">if</span>(a2==<span class="string">&quot;&quot;</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> a1.<span class="built_in">find</span>(a2);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">string <span class="title">XianXu</span><span class="params">(TreeNode* node)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        string ans;</span><br><span class="line">        <span class="keyword">if</span>(node==<span class="literal">NULL</span>) <span class="keyword">return</span> ans;</span><br><span class="line">        </span><br><span class="line">        TreeNode* temp=node;</span><br><span class="line">        ans+=(temp-&gt;val);</span><br><span class="line">        queue&lt;TreeNode*&gt; q;</span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            q.<span class="built_in">push</span>(temp);</span><br><span class="line">            <span class="keyword">if</span>(temp-&gt;left) &#123;q.<span class="built_in">push</span>(temp-&gt;left);</span><br><span class="line">                ans+=(temp-&gt;left-&gt;val);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(temp-&gt;right) &#123;q.<span class="built_in">push</span>(temp-&gt;right);ans+=(temp-&gt;left-&gt;val);&#125;</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            temp=q.<span class="built_in">front</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但很明显，用string返回，一旦出现负数或俩位数，就寄！wssb</p><p>直到我看见下面这种，哈哈哈</p><h5 id="大家整体逻辑一致，都是："><a href="#大家整体逻辑一致，都是：" class="headerlink" title="大家整体逻辑一致，都是："></a>大家整体逻辑一致，都是：</h5><p>如果AB相等就去判断AB是否为同一棵树，如果为真就返回真，如果为假，<br>就先让B和A的左子树进行对比，如果为真就返回真，如果为假，<br>再让B和A的右子树进行对比，如果为真就返回真，如果为假，那就返回。</p><h5 id="子函数iscontain用来判断是否被包含，逻辑也很简单：如果AB节点相等就去判断各子树，如果不想等直接返回假。"><a href="#子函数iscontain用来判断是否被包含，逻辑也很简单：如果AB节点相等就去判断各子树，如果不想等直接返回假。" class="headerlink" title="子函数iscontain用来判断是否被包含，逻辑也很简单：如果AB节点相等就去判断各子树，如果不想等直接返回假。"></a>子函数iscontain用来判断是否被包含，逻辑也很简单：如果AB节点相等就去判断各子树，如果不想等直接返回假。</h5><p>个人认为其中的一个小点也是要点是前两个if判断。</p><p>因为我们认为B是A的子结构，递归判断过程中</p><p>如果B为空说明已经判断完毕，可以返回真了，<br>如果B没完A却完了说明，不是子结构直接返回假。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">//输入两棵二叉树，判断B是不是A的子结构</span></span><br><span class="line">        <span class="comment">//思路：DFS，即先序遍历，然后判断A的每个节点都作为根节点是否可以跟B相匹配</span></span><br><span class="line">        <span class="comment">//匹配成功则返回true，匹配到空节点都还未成功则返回false</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//树A是否是树B的子结构</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSubStructure</span><span class="params">(TreeNode* A, TreeNode* B)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(B == <span class="literal">NULL</span> || A == <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//遍历A中的每一个节点，若是包含B则返回true</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">isContain</span>(A, B) || <span class="built_in">isSubStructure</span>(A-&gt;left, B) || <span class="built_in">isSubStructure</span>(A-&gt;right, B);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//以A为根节点的树是否包含B</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isContain</span><span class="params">(TreeNode* A, TreeNode* B)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(B == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(A == <span class="literal">NULL</span> || A-&gt;val != B-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">isContain</span>(A-&gt;left, B-&gt;left) &amp;&amp; <span class="built_in">isContain</span>(A-&gt;right, B-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="27-请完成一个函数，输入一个二叉树，该函数输出它的镜像。"><a href="#27-请完成一个函数，输入一个二叉树，该函数输出它的镜像。" class="headerlink" title="27.请完成一个函数，输入一个二叉树，该函数输出它的镜像。"></a>27.请完成一个函数，输入一个二叉树，该函数输出它的镜像。</h3><img src="/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/image-20230310124214167.png" class title="image-20230310124214167"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">mirrorTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>) <span class="keyword">return</span> root;</span><br><span class="line">        <span class="keyword">bool</span> leftEmpty=<span class="literal">false</span>, rightEmpty=<span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left ==<span class="literal">NULL</span>)   leftEmpty=<span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right ==<span class="literal">NULL</span>)   rightEmpty=<span class="literal">true</span>;</span><br><span class="line">        TreeNode* temp;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(leftEmpty&amp;&amp; rightEmpty)&#123; <span class="comment">//若左右子皆空，则直接返回</span></span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(leftEmpty &amp;&amp; !rightEmpty)  <span class="comment">//若左子空，右子不空</span></span><br><span class="line">        &#123;</span><br><span class="line">            root-&gt;left=root-&gt;right;</span><br><span class="line">            root-&gt;right=<span class="literal">NULL</span>;</span><br><span class="line">            <span class="built_in">mirrorTree</span>(root-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(!leftEmpty &amp;&amp; rightEmpty)  <span class="comment">//若左子不空，右子空</span></span><br><span class="line">        &#123;</span><br><span class="line">            root-&gt;right=root-&gt;left;</span><br><span class="line">            root-&gt;left=<span class="literal">NULL</span>;</span><br><span class="line">            <span class="built_in">mirrorTree</span>(root-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            temp=root-&gt;left;</span><br><span class="line">            root-&gt;left=root-&gt;right;</span><br><span class="line">            root-&gt;right=temp;</span><br><span class="line">            <span class="built_in">mirrorTree</span>(root-&gt;left);</span><br><span class="line">            <span class="built_in">mirrorTree</span>(root-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><img src="/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/image-20230310130259308.png" class title="image-20230310130259308"><p>太简单了没意思</p><h3 id="28-请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。"><a href="#28-请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。" class="headerlink" title="28.请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。"></a>28.请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。</h3><img src="/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/image-20230310130539704.png" class title="image-20230310130539704"><p>​    第一思路：可知对称的二叉树，其中序遍历应该也是对称的。所以我想去把其中序遍历输出出来。太复杂PASS，以下指针思路必须学习！！</p><img src="/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/image-20230310131649500.png" class title="image-20230310131649500"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">isTrue</span>(root -&gt; left, root -&gt; right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isTrue</span><span class="params">(TreeNode* A, TreeNode* B)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(A == <span class="literal">nullptr</span> &amp;&amp; B == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(A == <span class="literal">nullptr</span> || B == <span class="literal">nullptr</span> || A -&gt; val != B -&gt; val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">isTrue</span>(A -&gt; left, B -&gt; right) &amp;&amp; <span class="built_in">isTrue</span>(A -&gt; right, B -&gt; left);       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><img src="/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/image-20230310133610109.png" class title="image-20230310133610109"><h3 id="什么样的问题可以使用动态规划"><a href="#什么样的问题可以使用动态规划" class="headerlink" title="什么样的问题可以使用动态规划"></a>什么样的问题可以使用动态规划</h3><p>如果一个问题，可以把所有可能的答案穷举出来，并且穷举出来后，发现存在重叠子问题，就可以考虑使用动态规划。</p><h3 id="动态规划的解题思路"><a href="#动态规划的解题思路" class="headerlink" title="动态规划的解题思路"></a>动态规划的解题思路</h3><p>动态规划的核心思想就是<strong>拆分子问题，记住过往，减少重复计算。</strong> 并且动态规划一般都是自底向上的，因此到这里，基于<strong>青蛙跳阶</strong>问题，我总结了一下我做动态规划的思路：</p><ul><li>穷举分析</li><li>确定边界</li><li>找出规律，确定最优子结构</li><li>写出状态转移方程</li></ul><h3 id="动态规划实现框架"><a href="#动态规划实现框架" class="headerlink" title="动态规划实现框架"></a>动态规划实现框架</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">dp[<span class="number">0</span>][<span class="number">0</span>][...] = 边界值</span><br><span class="line"><span class="keyword">for</span>(状态<span class="number">1</span> ：所有状态<span class="number">1</span>的值)&#123;</span><br><span class="line">    <span class="keyword">for</span>(状态<span class="number">2</span> ：所有状态<span class="number">2</span>的值)&#123;</span><br><span class="line">        <span class="keyword">for</span>(...)&#123;</span><br><span class="line">          <span class="comment">//状态转移方程</span></span><br><span class="line">          dp[状态<span class="number">1</span>][状态<span class="number">2</span>][...] = 求最值</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/u010365819/article/details/121000532">https://blog.csdn.net/u010365819/article/details/121000532</a></p><h2 id="斐波那契（Fibonacci）"><a href="#斐波那契（Fibonacci）" class="headerlink" title="斐波那契（Fibonacci）"></a>斐波那契（Fibonacci）</h2><p>写一个函数，输入 <code>n</code> ，求斐波那契（Fibonacci）数列的第 <code>n</code> 项（即 <code>F(N)</code>）。斐波那契数列的定义如下：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">F</span>(<span class="number">0</span>) = <span class="number">0</span>,   F(<span class="number">1</span>) = <span class="number">1</span></span><br><span class="line"><span class="attribute">F</span>(N) = F(N - <span class="number">1</span>) + F(N - <span class="number">2</span>), 其中 N &gt; <span class="number">1</span>.</span><br></pre></td></tr></table></figure><p>斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。</p><p>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</p><img src="/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/image-20230310132214593.png" class title="image-20230310132214593"><p><a href="https://leetcode.cn/problems/fei-bo-na-qi-shu-lie-lcof/solution/mian-shi-ti-10-i-fei-bo-na-qi-shu-lie-dong-tai-gui/">斐波那契数列 动态规划题解</a></p><h3 id="很明显，用递归直接超时，还得是动态规划！"><a href="#很明显，用递归直接超时，还得是动态规划！" class="headerlink" title="很明显，用递归直接超时，还得是动态规划！"></a>很明显，用递归直接超时，还得是动态规划！</h3><p><img src="/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/image-20230310134237927.png" alt="image-20230310134237927"><img src="/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/image-20230310134247523.png" alt="image-20230310134247523"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a=<span class="number">0</span>, b=<span class="number">1</span>,sum=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 当n&gt;1时才会进入循环，所以for循环算的是n从2到n+1的值</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>; i&lt;=n+<span class="number">1</span>; i++)&#123;</span><br><span class="line">            sum=(a+b) % <span class="number">1000000007</span>;        </span><br><span class="line">            a=b;</span><br><span class="line">            b=sum;  </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 由于多算一次，所以返回的是a，不是b</span></span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="或者用记忆化搜索-降低复杂度"><a href="#或者用记忆化搜索-降低复杂度" class="headerlink" title="或者用记忆化搜索 降低复杂度"></a>或者用记忆化搜索 降低复杂度</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1000000007</span>;</span><br><span class="line">    <span class="keyword">int</span> dp[<span class="number">101</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(dp[n]) <span class="keyword">return</span> dp[n];</span><br><span class="line">        <span class="keyword">if</span>(n &lt; <span class="number">2</span>) <span class="keyword">return</span> n;</span><br><span class="line">        dp[n] = (<span class="built_in">fib</span>(n<span class="number">-1</span>)+<span class="built_in">fib</span>(n<span class="number">-2</span>)) % mod;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>结果也不错。</p><h2 id="青蛙跳台阶"><a href="#青蛙跳台阶" class="headerlink" title="青蛙跳台阶"></a>青蛙跳台阶</h2><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 <code>n</code> 级的台阶总共有多少种跳法。</p><p> 其实也是斐波那契数列的问题，看<a href="https://leetcode.cn/problems/climbing-stairs/solution/yuan-lai-hui-pa-lou-ti-de-zheng-que-zi-s-pjez/">这个链接！</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> dp[<span class="number">101</span>]=&#123;<span class="number">0</span>&#125;; </span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1000000007</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numWays</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//很不明显，可以将爬上n级台阶的问题，分成【先跳1步，然后爬n-1级楼梯】与【先跳2步，然后爬n-2级楼梯】之和</span></span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">1</span> || n==<span class="number">2</span>)<span class="keyword">return</span> n;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(dp[n]) <span class="keyword">return</span> dp[n];</span><br><span class="line">        dp[n] = (<span class="built_in">numWays</span>(n<span class="number">-1</span>)+<span class="built_in">numWays</span>(n<span class="number">-2</span>)) % mod;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="动态规划有几个典型特征，最优子结构、状态转移方程、边界、重叠子问题。在青蛙跳阶问题中："><a href="#动态规划有几个典型特征，最优子结构、状态转移方程、边界、重叠子问题。在青蛙跳阶问题中：" class="headerlink" title="动态规划有几个典型特征，最优子结构、状态转移方程、边界、重叠子问题。在青蛙跳阶问题中："></a>动态规划有几个典型特征，<strong>最优子结构、状态转移方程、边界、重叠子问题</strong>。在青蛙跳阶问题中：</h3><ul><li>f(n-1)和f(n-2) 称为 f(n) 的最优子结构</li><li>f(n)= f（n-1）+f（n-2）就称为状态转移方程</li><li>f(1) = 1, f(2) = 2 就是边界啦</li><li>比如f(10)= f(9)+f(8),f(9) = f(8) + f(7) ,f(8)就是重叠子问题。</li></ul><h2 id="股票的最大利润"><a href="#股票的最大利润" class="headerlink" title="股票的最大利润"></a>股票的最大利润</h2><p>假设把某股票的价格按照时间先后顺序存储在数组中，请问买卖该股票一次可能获得的最大利润是多少？</p><img src="/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/image-20230310141619639.png" class title="image-20230310141619639"><img src="/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/image-20230310142321486.png" class title="image-20230310142321486"><img src="/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/image-20230310142419564.png" class title="image-20230310142419564"><img src="/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/image-20230310142505665.png" class title="image-20230310142505665"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(prices.<span class="built_in">size</span>()==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> minValue = prices[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (prices[i] &lt; minValue) &#123;</span><br><span class="line">                minValue = prices[i];   <span class="comment">//有更低的价格，则以后的价格可以基于这个更低的价格去算</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            res = <span class="built_in">max</span>(res, prices[i] - minValue);<span class="comment">//但是也要和之前的res比较以下</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="连续子数组的最大和"><a href="#连续子数组的最大和" class="headerlink" title="连续子数组的最大和"></a>连续子数组的最大和</h2><img src="/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/image-20230310150347481.png" class title="image-20230310150347481"><img src="/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/image-20230310150402602.png" class title="image-20230310150402602"><p>​    我觉得关键就在于，对于每一个数是否加入数列，或者自己新开一个数列，就取决与该数本身与其之前连续子数列和大小的比较。</p><p>​    我开始还纠结，如果i前面的子数列和为2，然后i为-1，然后i+1为4，那要如何才能不断地组合。后来我发现，并不用组合，后面的4不就是最大的吗。嗯，所以我的思路没想到上面去，那要如何避免产生这种错误的思路呢？1是以后可以大胆假设，小心求证；2是多看多做题。</p><p>​    </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">         <span class="comment">//我们[]第n位数字为尾巴的最大值]就是其[前n-1位数字的最大值加上它本身]与[其自身]相比较，谁大就是谁，如果一样那就继续;</span></span><br><span class="line">         <span class="comment">//如果该数字加上去比原来更小，那就重开一段计算咯</span></span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>()==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> max1 = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> max_final=max1;    <span class="comment">//当前最优解，因为可能后面那段比前面好，所以要比较；</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            max1=<span class="built_in">max</span>(max1+nums[i],nums[i]);</span><br><span class="line">            max_final=<span class="built_in">max</span>(max1,max_final);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max_final;</span><br><span class="line">                   <span class="comment">//关于动态规划的思想可以看首页Krahets的讲解。这里给出C++的简单实现。</span></span><br><span class="line">                    <span class="comment">//算法精髓在于每个子数组必须要考虑最后一个数，但是最终结果只要最优解</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>思路一</p><img src="/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/image-20230310155856278.png" class title="image-20230310155856278"><p>思路二<img src="/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/image-20230310160043917.png" class title="image-20230310160043917"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【C#】 基础篇</title>
      <link href="/2023/03/08/Csharp_%E5%9F%BA%E7%A1%80/"/>
      <url>/2023/03/08/Csharp_%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h1 id="面向对象的三大特性"><a href="#面向对象的三大特性" class="headerlink" title="面向对象的三大特性"></a>面向对象的三大特性</h1><h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a><strong>封装</strong></h2><p>隐藏对象的属性和方法，可以用public，protected，private，internal关键字来区分不同的暴露程度</p><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a><strong>继承</strong></h2><p>子类继承父类的属性和方法，使用sealed关键字可以终止继承</p><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a><strong>多态</strong></h2><p>同一个对象调用函数的不同表现，静态多态用重写实现，动态多态用虚函数实现。可以用关键字virtual、abstrac、interface来定义动态多态的形式</p><h1 id="C-的值类型和引用类型"><a href="#C-的值类型和引用类型" class="headerlink" title="C#的值类型和引用类型"></a>C#的值类型和引用类型</h1><p><a href="https://www.runoob.com/csharp/csharp-data-types.html">C# 数据类型</a></p><h2 id="值类型（Value-types）"><a href="#值类型（Value-types）" class="headerlink" title="值类型（Value types）"></a>值类型（Value types）</h2><p>​    值类型变量可以直接分配给一个值。它们是从类 <strong>System.ValueType</strong> 中派生的。</p><p>​    <strong>值类型直接包含数据。</strong>比如 <strong>int、char、float</strong>，它们分别存储数字、字符、浮点数。当您声明一个 <strong>int</strong> 类型时，系统分配内存来存储值。</p><table><thead><tr><th align="left">类型</th><th align="left">描述</th><th align="left">范围</th><th align="left">默认值</th></tr></thead><tbody><tr><td align="left">bool</td><td align="left">布尔值</td><td align="left">True 或 False</td><td align="left">False</td></tr><tr><td align="left">byte</td><td align="left">8 位无符号整数</td><td align="left">0 到 255</td><td align="left">0</td></tr><tr><td align="left">char</td><td align="left">16 位 Unicode 字符</td><td align="left">U +0000 到 U +ffff</td><td align="left">‘\0’</td></tr><tr><td align="left">decimal</td><td align="left">128 位精确的十进制值，28-29 有效位数</td><td align="left">(-7.9 x 1028 到 7.9 x 1028) / 100 到 28</td><td align="left">0.0M</td></tr><tr><td align="left">double</td><td align="left">64 位双精度浮点型</td><td align="left">(+/-)5.0 x 10-324 到 (+/-)1.7 x 10308</td><td align="left">0.0D</td></tr><tr><td align="left">float</td><td align="left">32 位单精度浮点型</td><td align="left">-3.4 x 1038 到 + 3.4 x 1038</td><td align="left">0.0F</td></tr><tr><td align="left">int</td><td align="left">32 位有符号整数类型</td><td align="left">-2,147,483,648 到 2,147,483,647</td><td align="left">0</td></tr><tr><td align="left">long</td><td align="left">64 位有符号整数类型</td><td align="left">-9,223,372,036,854,775,808 到 9,223,372,036,854,775,807</td><td align="left">0L</td></tr><tr><td align="left">sbyte</td><td align="left">8 位有符号整数类型</td><td align="left">-128 到 127</td><td align="left">0</td></tr><tr><td align="left">short</td><td align="left">16 位有符号整数类型</td><td align="left">-32,768 到 32,767</td><td align="left">0</td></tr><tr><td align="left">uint</td><td align="left">32 位无符号整数类型</td><td align="left">0 到 4,294,967,295</td><td align="left">0</td></tr><tr><td align="left">ulong</td><td align="left">64 位无符号整数类型</td><td align="left">0 到 18,446,744,073,709,551,615</td><td align="left">0</td></tr><tr><td align="left">ushort</td><td align="left">16 位无符号整数类型</td><td align="left">0 到 65,535</td><td align="left">0</td></tr></tbody></table><p>表达式 <em>sizeof(type)</em> 产生以字节为单位存储对象或类型的存储尺寸。</p><h2 id="引用类型（Reference-types）"><a href="#引用类型（Reference-types）" class="headerlink" title="引用类型（Reference types）"></a>引用类型（Reference types）</h2><p>​    引用类型不包含存储在变量中的实际数据，但它们包含对变量的引用。换句话说，<strong>它们指的是一个内存位置</strong>。使用多个变量时，引用类型可以指向一个内存位置。如果内存位置的数据是由一个变量改变的，其他变量会自动反映这种值的变化。</p><p>​    <strong>内置的</strong> 引用类型有：<strong>object</strong>、<strong>dynamic</strong> 和 <strong>string</strong>。</p><h3 id="对象（Object）类型"><a href="#对象（Object）类型" class="headerlink" title="对象（Object）类型"></a>对象（Object）类型</h3><p>​    <strong>对象（Object）类型</strong> 是 C# 通用类型系统（Common Type System - CTS）中所有数据类型的终极基类。Object 是 System.Object 类的别名。所以对象（Object）类型可以被分配任何其他类型（值类型、引用类型、预定义类型或用户自定义类型）的值。但是，在分配值之前，需要先进行类型转换。</p><p>​    当一个值类型转换为对象类型时，则被称为 <strong>装箱</strong>；另一方面，当一个对象类型转换为值类型时，则被称为 <strong>拆箱</strong>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">object obj;</span><br><span class="line">obj = 100; // 这是装箱把int值类型的数据，装入object中，称为装箱</span><br></pre></td></tr></table></figure><h3 id="动态（Dynamic）类型"><a href="#动态（Dynamic）类型" class="headerlink" title="动态（Dynamic）类型"></a>动态（Dynamic）类型</h3><p>​    您可以存储任何类型的值在动态数据类型变量中。这些变量的类型检查是在<strong>运行时</strong>发生的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dynamic &lt;variable_name&gt; = value;//声明动态类型的语法</span><br><span class="line"></span><br><span class="line">dynamic d = 20;</span><br></pre></td></tr></table></figure><p>​    动态类型与对象类型相似，但是<strong>对象类型</strong>变量的类型检查是在<strong>编译</strong>时发生的，而<strong>动态类型</strong>变量的类型<strong>检查</strong>是在运行时发生的。</p><h3 id="字符串（String）类型"><a href="#字符串（String）类型" class="headerlink" title="字符串（String）类型"></a>字符串（String）类型</h3><p><strong>字符串（String）类型</strong> 允许您给变量分配任何字符串值。字符串（String）类型是 System.String 类的别名。它是从对象（Object）类型派生的。字符串（String）类型的值可以通过两种形式进行分配：引号和 @引号。</p><h3 id="用户自定义引用类型有：class、interface-或-delegate。"><a href="#用户自定义引用类型有：class、interface-或-delegate。" class="headerlink" title="用户自定义引用类型有：class、interface 或 delegate。"></a>用户自定义引用类型有：class、interface 或 delegate。</h3><h2 id="指针类型（Pointer-types）"><a href="#指针类型（Pointer-types）" class="headerlink" title="指针类型（Pointer types）"></a>指针类型（Pointer types）</h2><p>​    指针类型变量存储另一种类型的内存地址。C# 中的指针与 C 或 C++ 中的指针有相同的功能。</p><h2 id="值类型和引用类型的区别"><a href="#值类型和引用类型的区别" class="headerlink" title="值类型和引用类型的区别"></a><strong>值类型和引用类型的区别</strong></h2><ol><li><p><strong>值类型存储在栈</strong>区中，<strong>引用类型存储在堆区</strong>中。</p></li><li><p>值类型表示的是实际数据，引用类型表示的时候对数据的引用。</p></li><li><p>值类型存储速度快，引用类型存储速度慢。</p></li><li><p><strong>值类型继承于system.VauleType</strong>，<strong>引用类型继承于system.Object</strong></p></li><li><p><strong>栈区的内存分配是自动释放的</strong>，<strong>而堆区的内存是由GC来进行回收</strong>。</p></li><li><p><strong>当声明一个值类型时，不管是否初始化，编译器都将其分配内存，而引用类型需要初始化后才分配内存。</strong></p></li></ol><p>​    所有的值类型都继承自System.ValueType(System.ValueType继承自System.Object)，也就是说，<strong>所有继承自System.ValueType的类型都是值类型</strong>，而其他类型都是引用类型。<strong>常用的值类型包括结构、枚举、整数型、浮点型、布尔型等</strong>，而在C#中<strong>所有以class关键字定义的类型都是引用类型。</strong></p><h3 id="内存区域上的区别"><a href="#内存区域上的区别" class="headerlink" title="内存区域上的区别"></a><strong>内存区域上的区别</strong></h3><p>​    值类型：<strong>数据存储在栈</strong>上，超出作用域就自动清理</p><p>​    引用类型：<strong>数据存储在托管堆</strong>上，<strong>引用地址在线程栈上</strong>，<strong>地址指向数据存放的堆上</strong></p><p>​    <strong>托管堆会由GC来自动释放</strong> ，<strong>线程栈数据在作用域结束后会被清理。</strong></p><h3 id="拷贝策略："><a href="#拷贝策略：" class="headerlink" title="拷贝策略："></a><strong>拷贝策略：</strong></h3><p>​    <strong>值类型是拷贝数据，引用类型是拷贝引用地址</strong></p><p>​    如果值类型为传值参数，传值参数会在栈上新开辟一个副本，原先的值类型数据不会改变</p><p>​    如果引用类型是传值参数，传值参数会创建一个新的引用地址，两个引用地址会指向同一个对象实例的数据，实例数据会随着改变进行改变。（这种行为被称为副作用，一般实际项目不会这么操作，要么return返回参数，要么使用ref或者out修饰符）</p><h1 id="装箱和拆箱-object"><a href="#装箱和拆箱-object" class="headerlink" title="装箱和拆箱 object"></a>装箱和拆箱 object</h1><p>​    <strong>object是所有类型的基类，它是一个类(引用类型)。</strong></p><h2 id="装箱：值类型-》引用类型object"><a href="#装箱：值类型-》引用类型object" class="headerlink" title="装箱：值类型====》引用类型object"></a>装箱：值类型====》引用类型object</h2><p><strong>对值类型在堆区分配一个对象实例，并且将该值复制到新的对象中。</strong></p><p>1.<strong>分配内存堆</strong></p><p>2.值类型数据拷贝到新分配的内存堆中</p><p>3.栈中分配一个新的引用地址指向堆区中新分配内存的地址（这个地址就是指向对象的引用）</p><h2 id="拆箱：引用类型object-》值类型"><a href="#拆箱：引用类型object-》值类型" class="headerlink" title="拆箱：引用类型object====》值类型"></a>拆箱：引用类型object====》值类型</h2><p>1.检查确保对象是给定值类型的一个装箱值，并获取到堆区中属于值类型的字段地址</p><p>2.将该值数据复制到栈中的值类型实例中，会有类型不安全的情况</p><p><strong>注意：只有被装箱的对象才能进行拆箱操作。</strong></p><p>装箱和拆箱在值类型和引用类型之间架起桥梁，使得值类型和引用类型之间可以互相转换，可以统一考量系统，值类型和引用类型都可以按照对象来处理。但是要尽量避免装箱和拆箱，因为这需要在堆中分配内存，效率低下。</p><ul><li>可以利用里氏替换原则，用object容器装所有对象</li><li>可以用来表示不确定类型，作为函数参数类型</li></ul><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Father</span>&#123;    </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Son</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Speak</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span>&#123;</span><br><span class="line">    Father f = <span class="keyword">new</span> Son();</span><br><span class="line">    <span class="keyword">if</span>(f <span class="keyword">is</span> Son)&#123;</span><br><span class="line">        (f <span class="keyword">as</span> Son).Speak();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 用万物之父实现装箱</span></span><br><span class="line">    <span class="comment">// 引用类型装箱</span></span><br><span class="line">    <span class="built_in">object</span> o = <span class="keyword">new</span> Son();</span><br><span class="line">    <span class="keyword">if</span>(o <span class="keyword">is</span> Son)&#123;</span><br><span class="line">       (o <span class="keyword">as</span> Son).Speak(); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 值类型装箱</span></span><br><span class="line">    <span class="built_in">object</span> o2 = <span class="number">1f</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">float</span> f1 = (<span class="built_in">float</span>)o2;</span><br><span class="line">    <span class="comment">// 特殊的string类型</span></span><br><span class="line">    <span class="built_in">object</span> str = <span class="string">&quot;123123&quot;</span>;</span><br><span class="line">    <span class="comment">// 第一种转法</span></span><br><span class="line">    <span class="built_in">string</span> str2 = str.ToString();</span><br><span class="line">    <span class="comment">// 第二种转法</span></span><br><span class="line">    <span class="built_in">string</span> str3 = str <span class="keyword">as</span> <span class="built_in">string</span>;</span><br><span class="line">    <span class="comment">// 特殊的数组</span></span><br><span class="line">    <span class="built_in">object</span> arr  = <span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">10</span>];</span><br><span class="line">    <span class="comment">// 第一种转法</span></span><br><span class="line">    <span class="built_in">int</span>[] ar = (<span class="built_in">int</span>[])arr;</span><br><span class="line">    <span class="comment">// 第二种转法</span></span><br><span class="line">    <span class="built_in">int</span>[] ar2 = arr <span class="keyword">as</span> <span class="built_in">int</span>[];</span><br><span class="line">&#125;</span><br><span class="line">===============</span><br><span class="line">    总结：</span><br><span class="line">    装箱拆箱的条件：用<span class="built_in">object</span>存值类型(装箱)，再把<span class="built_in">object</span>转为值类型(拆箱)</span><br><span class="line">    装箱：</span><br><span class="line">    把值类型用引用类型存储，栈内存会迁移到堆内存中。</span><br><span class="line">    拆箱：</span><br><span class="line">    把引用类型存储的值类型取出来，堆内存会迁移到栈内存中</span><br><span class="line">    好处：不确定类型时候可以方便方便参数的存储和传递</span><br><span class="line">    坏处：存在内存迁移，增加性能消耗</span><br></pre></td></tr></table></figure><p> <a href="https://blog.csdn.net/HolaMirai/article/details/49533057">https://blog.csdn.net/HolaMirai/article/details/49533057</a></p><h1 id="垃圾回收-GC"><a href="#垃圾回收-GC" class="headerlink" title="垃圾回收 GC"></a>垃圾回收 GC</h1><p>​    <strong>垃圾回收机制GC(Garbage Collector)</strong>    </p><p>​    垃圾回收的过程是在遍历**堆(Heap)**上动态分配的所有对象，通过识别它们是否被引用来确定哪些对象是垃圾，哪些对象仍要被使用，所谓的垃圾就是没有被任何变量，对象引用的内存，垃圾就需要被回收释放。</p><p>​    垃圾回收有很多种算法，比如：<strong>引用计数(Reference Counting)、标记清除(Mark Sweep)、标记整理(Mark Compact)、复制集合(Copy Collection).</strong></p><blockquote><p>​    注意：GC只负责堆(Heap)内存的垃圾回收，<strong>引用类型都是存在堆(Heap)中</strong>的，所以它的分配和释放都是通过垃圾回收机制来管理。</p><p>​    栈(Stack)上的内存是有系统自动管理的，<strong>值类型在栈(Stack)中</strong>分配内存的，他们有自己的生命周期，不用对他们进行管理，会自动分配和释放。</p></blockquote><p>​    在GC（Garbage Collection）过程中，垃圾回收器会检查堆（Heap）中的所有对象，搜索它们的引用，来判断这些对象是否还在作用域中。如果对象不在作用域中，它将被标记为需要删除。然后垃圾回收器会将这些被标记为需要删除的对象删除，收回它们所占用的内存空间。堆中的对象和代码中对象引用越多，垃圾回收过程中要进行的操作就越多，其开销也就越大。</p><p>​    堆内存空间不足、系统定时自动回收垃圾以及强制GC都会触发垃圾回收操作。频繁的进行堆内存分配和释放将会导致频繁的GC。</p><p>​    在Unity中，只有<strong>值类型局部变量</strong>被分配在栈（Stack）中，它们不会引起GC，其他所有类型的数据都分配在堆中，由GC系统进行回收。</p><p>​    由GC引起的性能问题 主要表现 为：帧率低、性能时好时坏以及断断续续的出现卡顿。</p><h3 id="优化方法"><a href="#优化方法" class="headerlink" title="优化方法"></a><strong>优化方法</strong></h3><ol><li>对于子弹等不断重复出现消失的物体使用<strong>对象池Object Pooling</strong>管理</li><li><strong>游戏载入新场景时，显示调用GC.Collection回收垃圾</strong>（因为载入场景本身就要等待，GC运行造成卡顿也没事）</li><li>使用<strong>SriptableObject（脚本化对象）</strong>，其相当于资源文件，在实例化的时只是复制了引用（在实例化Prefab时是把数据复制了一遍）</li><li>启用<strong>增量垃圾收集</strong>（增量垃圾收集将垃圾收集分解到若干帧中完成，避免出现尖峰，这些尖峰意味着进行垃圾收集那一帧的物理时间远远超过维持 60FPS 所需的 16 毫秒限制，这会导致游戏卡顿）</li><li><strong>不要在需要频繁调用的函数中写有会产生内存分配操作的代码，尤其是在Update中</strong></li><li><strong>尽量为需要长时间存活的资源创建大对象。（&gt;=85000字节的对象为大对象）</strong></li><li><strong>减少装箱拆箱代码</strong></li></ol><h3 id="C-内存回收机制原理："><a href="#C-内存回收机制原理：" class="headerlink" title="C#内存回收机制原理："></a><strong>C#内存回收机制原理：</strong></h3><p>​    <strong>内存回收机制存在三代内存：0代内存、1代内存、2代内存；</strong></p><p>​    代的概念：代是垃圾回收机制中使用的一种算法(分代算法)，每次新分配的对象都会被配置在第0代内存中，每次新分配都可能会进行垃圾回收以释放内存(0代内存满时)；在第一次内存回收过程开始时候，垃圾回收器会认为堆中全是内存，会进行以下两步：</p><ol><li><p>标记对象：从根（静态字段、方法参数）开始检查引用对象，标记后为可达对象，未标记为不可达对象，不可达对象就被认为是垃圾。</p></li><li><p>搬迁对象压缩堆（挂起执行托管代码线程）释放未标记的对象，搬迁可达对象，修改引用地址。</p></li></ol><h1 id="结构体与类的区别"><a href="#结构体与类的区别" class="headerlink" title="结构体与类的区别"></a>结构体与类的区别</h1><p>​    结构体和类最大的区别是存储空间上的区别，因为<strong>结构体是值类型</strong>，<strong>类是引用类型</strong>，因此它们在存储位置是不同的，一个在栈上，一个在堆上；</p><p>​    结构体和类在使用上很类似，结构体甚至可以用面向对象的思想来形容一类对象。结构体具备着面向对象思想中的封装特性，但是它不具备继承和多态的特性，因此大大减少了它的使用频率。由于结构体不具备继承的特性，所以它不能够使用protected保护访问修饰符。</p><ol><li>结构体是值类型，类是引用类型</li><li>结构体存在栈中，类存在堆中</li><li>结构体成员不能使用protected访问修饰符，而类可以</li><li>结构体成员变量申明不能指定初始值，而类可以</li><li>结构体不能申明无参的构造函数，而类可以</li><li>结构体申明有参构造函数后，无参构造函数不会被顶替</li><li>结构体不能申明析构函数，而类可以</li><li>结构体不能被继承，而类可以</li><li>结构体需要在构造函数中初始化所有成员变量，而类随意</li><li>结构体不能被静态static修饰(不存在静态结构体)，而类可以</li><li>结构体不能在自己内部申明和自己一样的结构体变量，而类可以</li></ol><h3 id="如何选择结构体和类"><a href="#如何选择结构体和类" class="headerlink" title="如何选择结构体和类"></a>如何选择结构体和类</h3><p>1.想要用继承和多态时候，直接淘汰结构体，比如玩家、怪物等等</p><p>2.对象数据集合时，优先考虑结构体，比如位置、坐标等等</p><p>3.从值类型和引用类型赋值时的区别上去考虑，比如经常被赋值传递的对象，并且改变赋值对象，原对象不想跟着变化时，就用结构体。比如坐标、向量、旋转等等。</p><p><strong>堆栈的空间有限，对于大量的逻辑的对象，创建类要比创建结构好一些。</strong></p><h1 id="抽象类与接口的区别"><a href="#抽象类与接口的区别" class="headerlink" title="抽象类与接口的区别"></a>抽象类与接口的区别</h1><h3 id="抽象类："><a href="#抽象类：" class="headerlink" title="抽象类："></a><strong>抽象类：</strong></h3><p>​    抽象类是一种特殊的类。abstract修饰的类和方法，抽象类不能实例化，抽象方法只能在抽象类中申明，是个纯虚方法，必须在子类中实现。一个类可以直接继承多个接口，但只能直接继承一个类（包括抽象类）。</p><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a><strong>接口</strong></h3><p>​    <strong>接口是对类的行为的规范和规定，表示这个类能做什么。</strong>interface自定义类型，是行为的抽象接口。</p><p>​    除了可以包含方法之外，还可以包含属性、索引器、事件，而且这些成员都被定义为公有的。接口不能包含任何其他的成员，例如：常量、域、构造函数、析构函数、静态成员。</p><p>​    接口不能被实例化，且派生类必须实现接口所有未实现的方法。</p><h3 id="相同点"><a href="#相同点" class="headerlink" title="相同点"></a>相同点</h3><p>1.都可以被继承</p><p>2.都不能被直接实例化</p><p>3.都可以包含方法申明</p><p>4.子类必须实现未实现的方法</p><p>5.都遵循里氏替换原则</p><h3 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h3><p>1.抽象类中可以有构造函数；接口不行</p><p>2.抽象类只能被单一继承；接口可以被继承多个</p><p>3.抽象类中可以有成员变量；接口不能</p><p>4.抽象类中可以申明成员方法，虚方法，抽象方法，静态方法；接口中只能申明没有实现的抽象方法</p><p>5.抽象类方法可以使用访问修饰符；接口中建议不写，默认public</p><h3 id="如何选择抽象类和接口："><a href="#如何选择抽象类和接口：" class="headerlink" title="如何选择抽象类和接口："></a>如何选择抽象类和接口：</h3><p>表示对象的用抽象类，表示拓展的用接口，不同对象拥有的共同行为，我们往往可以使用接口来实现。</p><p>举个例子：</p><p>动物是一类对象，我们自然会选择抽象类；而飞翔是一个行为，我们自然会选择接口。</p><h1 id="C-中常用的容器类"><a href="#C-中常用的容器类" class="headerlink" title="C#中常用的容器类"></a>C#中常用的容器类</h1><h3 id="Stack栈"><a href="#Stack栈" class="headerlink" title="Stack栈"></a>Stack栈</h3><p>​    先进后出，入栈和出栈，底层泛型数组实现，入栈动态扩容2倍</p><h3 id="Queue队列"><a href="#Queue队列" class="headerlink" title="Queue队列"></a>Queue队列</h3><p>​    先进先出，入队和出队，底层泛型数组实现，表头表尾指针，判空还是满通过size比较</p><h3 id="Array数组"><a href="#Array数组" class="headerlink" title="Array数组"></a>Array数组</h3><p>​    需要声明长度，不安全</p><h3 id="ArrayList数组列表"><a href="#ArrayList数组列表" class="headerlink" title="ArrayList数组列表"></a>ArrayList数组列表</h3><p>​    动态增加数组，不安全，实现了IList接口（表示可按照索引进行访问的非泛型集合对象），Object数组实现</p><h3 id="List列表"><a href="#List列表" class="headerlink" title="List列表"></a>List列表</h3><p>​    底层实现是泛型数组，特性，动态扩容，泛型安全</p><p>​    将泛型数据（对值类型来说就是数据本身，对引用类型来说就是引用）存储在一个泛型数组中，添加元素时若超过当前泛型数组容量，则以2倍扩容，进而实现List大小动态可变。（注：大小指容量，不是Count）</p><h3 id="LinkList链表"><a href="#LinkList链表" class="headerlink" title="LinkList链表"></a>LinkList链表</h3><p>​    1、数组和List、ArrayList集合都有一个重大的缺陷，就是从数组的中间位置删除或插入一个元素需要付出很大的代价，其原因是数组中处于被删除元素之后的所有元素都要向数组的前端移动。</p><p>​    2、LinkedList（底层是由链表实现的）基于链表的数据结构，很好的解决了数组删除插入效率低的问题，且不用动态的扩充数组的长度。</p><p>​    3、LinkedList的优点：插入、删除元素效率比较高；缺点：访问效率比较低。</p><h3 id="HashTable哈希表（散列表）"><a href="#HashTable哈希表（散列表）" class="headerlink" title="HashTable哈希表（散列表）"></a>HashTable哈希表（散列表）</h3><p>​    概念：不定长的二进制数据通过哈希函数映射到一个较短的二进制数据集，即Key通过HashFunction函数获得HashCode</p><p>​    装填因子：α=n/m=0.72 ,存储的数据N和空间大小M</p><p>​    然后通过哈希桶算法，HashCode分段，每一段都是一个桶结构，一般是HashCode直接取余。</p><p>​    桶结构会加剧冲突，解决冲突使用拉链法，将产生冲突的元素建立一个单链表，并将头指针地址存储至Hash表对应桶的位置。这样定位到Hash表桶的位置后可通过遍历单链表的形式来查找元素。</p><p>​    1、Key—Value形式存取，无序，类型Object，需要类型转换。</p><p>​    2、Hashtable查询速度快，而添加速度相对慢</p><p>​    3、Hashtable中的数据实际存储在内部的一个数据桶里（bucket结构体数组），容量固定，根据数组索引获取值。</p><h3 id="Directionary-lt-TKey-TVaule-gt-字典"><a href="#Directionary-lt-TKey-TVaule-gt-字典" class="headerlink" title="Directionary&lt;TKey,TVaule&gt;字典"></a>Directionary&lt;TKey,TVaule&gt;字典</h3><p>​    有序，泛型存储不需要进行类型装换（不需要装箱拆箱），碰撞阈值扩容~</p><h3 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h3><p>​    一组不包含重复的元素集合</p><h1 id="String、StringBuffer和StringBuilder"><a href="#String、StringBuffer和StringBuilder" class="headerlink" title="String、StringBuffer和StringBuilder"></a>String、StringBuffer和StringBuilder</h1><p>​    <a href="https://mp.weixin.qq.com/s/66uXP-x5_6ZToOT2ke5hOg#at">面试官问：C#中String、StringBuffer、StringBuilder之间区别？</a></p><p>​    在字符串处理中C#提供了<code>String</code>、<code>StringBuffer</code>、<code>StringBuilder</code>三个类。那么他们到底有什么优缺点，到底什么时候该用谁呢？</p><h3 id="运行速度方面的比较：StringBuilder-gt-StringBuffer-gt-String"><a href="#运行速度方面的比较：StringBuilder-gt-StringBuffer-gt-String" class="headerlink" title="运行速度方面的比较：StringBuilder &gt;StringBuffer &gt; String"></a>运行速度方面的比较：<strong>StringBuilder &gt;StringBuffer &gt; String</strong></h3><p>​    <code>String</code>是字符串常量，一旦赋值或实例化后就不可更改，如果赋予新值将会重新开辟内存地址进行存储。</p><p>​    <code>stringbuffer</code>和<code>stringbuilder</code>， 都是字符串变量，可以扩充其封装的字符串字符的数量，也可定义它的容量，当存储容量达到定义容量时，会自动扩充容量</p><p>​    两者最大的区别在于：</p><ul><li><strong><code>stringbuffer</code>是线程安全的</strong>，<strong>支持并发操作，适合在多线程中使用</strong>；</li><li><strong>而<code>stringbuilder</code>不支持并发，线程也不安全，适合单线程使用。</strong></li></ul><p>​    <code>StringBuffer</code>类使用<code>append</code>和<code>insert</code>等方法改变字符串值时只是在原有对象存储的内存地址上进行连续操作，减少了资源的开销。因此：当需要进行频繁修改字符串的操作时先建立<code>StringBuffer</code>类对象进行操作，将最后结果转化成<code>String</code>类对象返回，这样效率会高很多。</p><p>​    <code>StringBuffer(StringBuilder)</code>其实可以看做“基本数据类型”<code>String</code>的包装类(<code>Wrapper</code>)，就像int与之对应的Integer等关系。</p><p>​    <code>StringBuffer</code>有缓存的，如果你声明一个字符串只是接收传过来的参数，然后进行业务逻辑处理，那么假如你用很多个StringBuffer类型的对象，就比较浪费内存。这样用String就更好。</p><h3 id="字符串拼接时，String-对象的速度并不会比-StringBuffer对象慢。"><a href="#字符串拼接时，String-对象的速度并不会比-StringBuffer对象慢。" class="headerlink" title="字符串拼接时，String 对象的速度并不会比 StringBuffer对象慢。"></a>字符串拼接时，<code>String</code> 对象的速度并不会比 <code>StringBuffer</code>对象慢。</h3><p>String 对象的字符串拼接其实是被 .NET 解释成了StringBuffer 对象的拼接，所以这些时候String 对象的速度并不会比StringBuffer 对象慢，而特别是以下的字符串对象生成中， String 效率是远要比 StringBuffer 快。</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String S1 = “This <span class="keyword">is</span> only a” + “ simple” + “ test”;</span><br><span class="line">StringBuffer Sb = <span class="keyword">new</span> StringBuilder(“This <span class="keyword">is</span> only a”).append(“ simple”).append(“test”);</span><br></pre></td></tr></table></figure><p>你会很惊讶的发现，生成String S1 对象的速度简直太快了，而这个时候 StringBuffer 居然速度上根本一点都不占优势。其实这是 .NET 的一个把戏，在 .NET 眼里，这个</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String S1 = “This <span class="keyword">is</span> only a” + “ simple” + “test”;</span><br></pre></td></tr></table></figure><p>其实就是：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String S1 = “This <span class="keyword">is</span> only a simple test”;</span><br></pre></td></tr></table></figure><p>所以当然不需要太多的时间了。但大家这里要注意的是，如果你的字符串是来自另外的 String 对象的话，速度就没那么快了，譬如：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String S2 = “This <span class="keyword">is</span> only a”;</span><br><span class="line">String S3 = “ simple”;</span><br><span class="line">String S4 = “ test”;</span><br><span class="line">String S1 = S2 +S3 + S4;</span><br></pre></td></tr></table></figure><p>这时候 .NET 会规规矩矩的按照原来的方式去做。</p><h3 id="线程安全性"><a href="#线程安全性" class="headerlink" title="线程安全性"></a>线程安全性</h3><p>​    **<code>StringBuffer</code> 字符串变量（线程安全）    ** <strong><code>StringBuilder</code> 字符串变量（非线程安全）</strong></p><p>​    在操作少量变动的数据时，使用<code>String</code>；</p><p>​    在单线程中操作大量数据的字符串时，使用<code>StringBuilder</code>；</p><p>​    在多线程中操作大量数据的字符串时，使用<code>StringBuffer</code>。</p><h3 id="假的总结"><a href="#假的总结" class="headerlink" title="假的总结"></a>假的总结</h3><p>​    可以多尝试<code>StringBuffer</code>。</p><h1 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h1><p>​    泛型类不是实际的类，而是类的模板</p><p>​    多个代码对 【不同数据类型】 执行 【相同指令】的情况</p><h3 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h3><p>​    泛型不会强行对值类型进行装箱和拆箱，或对引用类型进行向下强制类型转换，所以性能得到提高</p><h3 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h3><p>​    通过知道使用泛型定义的变量的类型限制，编译器可以在一定程度上验证类型假设，所以泛型提高了程序的类型安全。</p><h1 id="for和foreach"><a href="#for和foreach" class="headerlink" title="for和foreach"></a>for和foreach</h1><ul><li>从底层实现上：<strong>foreach是通过指针偏移</strong>实现的（最初在-1位置，每循环一次，指针就偏移一个单位），而<strong>for循环是通过当前索引相对零索引的偏移量（通过首地址和地址偏移量）计算实际访问地址实现的</strong></li><li>从编码结构上：foreach语句省去了for语句中设置循环起点和循环条件的过程</li><li>从使用要求上：使用foreach语句遍历对象要求<strong>对象类型实现了枚举接口IEnumerable</strong></li><li>从使用效率上：<strong>foreach循环访问时会将对象的值复制到栈上</strong>，效率比for循环要低。但<strong>也有说法是foreach效率比for要高</strong>(C#是强类型检查,for循环对于数组访问的时候,要对索引的有效值进行检查)。直到我发现不同的数据结构，<a href="https://www.cnblogs.com/chensuqian/p/4882207.html">for和foreach执行效率是不一样的</a>，不能说哪个一定快。</li><li>从使用开销上：<strong>foreach循环</strong>的时候会释放使用完的资源，所以会<strong>造成额外的gc开销</strong></li></ul><h3 id="foreach遍历的实现逻辑"><a href="#foreach遍历的实现逻辑" class="headerlink" title="foreach遍历的实现逻辑"></a>foreach遍历的实现逻辑</h3><p>​    在微软.NET推出了IEnumerable和IEnumerator两个接口之后才有了foreach的用法，foreach是建立在这两个接口之上的，使用foreach的前提是里边的容器实现了IEnumerable接口；</p><p>​    实现逻辑是：集合或数组实现了IEnumerable接口，并调用GetEnumerator抽象方法返回IEnumerator遍历器，通过使用IEnumerator这个工具来遍历这个类。</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">IEnumerable&lt;<span class="built_in">object</span>&gt; obj = <span class="keyword">new</span> IEnumerable&lt;<span class="built_in">object</span>&gt;();</span><br><span class="line">IEnumerator tor = obj.GetEnumerator();</span><br><span class="line"><span class="keyword">while</span>(tor.MoveNext())</span><br><span class="line">&#123;</span><br><span class="line">    Console.Write(tor.Current);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    IEnumerator中定义了一组方法：</p><ul><li><p>​    Current：返回遍历工具所指容器的当前元素；</p></li><li><p>​    MoveNext:指向下一个元素，当遍历到没有元素时返回一个false；</p></li></ul><h3 id="为什么不能在foreach遍历中更改源集合"><a href="#为什么不能在foreach遍历中更改源集合" class="headerlink" title="为什么不能在foreach遍历中更改源集合"></a>为什么不能在foreach遍历中更改源集合</h3><p>​    在foreach循环访问时<strong>会将集合中的每个值复制到栈上（引用类型复制的是地址）</strong>，<strong>实际遍历的对象其实是一个复制出来的中间变量；</strong></p><p>​    在这个机制的存在下，foreach循环在执行速度上要比for循环慢；</p><img src="/2023/03/08/Csharp_%E5%9F%BA%E7%A1%80/image-20230309001046157.png" class title="image-20230309001046157"><h3 id="foreach处理多维数组-不包括锯齿数组-更加方便"><a href="#foreach处理多维数组-不包括锯齿数组-更加方便" class="headerlink" title="foreach处理多维数组(不包括锯齿数组)更加方便"></a>foreach处理多维数组(不包括锯齿数组)更加方便</h3><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span>[,] nVisited =&#123;</span><br><span class="line">       &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,</span><br><span class="line">       &#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;,</span><br><span class="line">       &#123;<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Use &quot;for&quot; to loop two-dimension array(使用for循环二维数组)</span></span><br><span class="line">Console.WriteLine(<span class="string">&quot;User &#x27;for&#x27; to loop two-dimension array&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; nVisited.GetLength(<span class="number">0</span>); i++)</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> j = <span class="number">0</span>; j &lt; nVisited.GetLength(<span class="number">1</span>); j++)</span><br><span class="line">         Console.Write(nVisited[i, j]);</span><br><span class="line">         Console.WriteLine();</span><br><span class="line"></span><br><span class="line"><span class="comment">//Use &quot;foreach&quot; to loop two-dimension array(使用foreach循环二维数组)</span></span><br><span class="line">Console.WriteLine(<span class="string">&quot;User &#x27;foreach&#x27; to loop two-dimension array&quot;</span>);</span><br><span class="line"><span class="keyword">foreach</span> (<span class="keyword">var</span> item <span class="keyword">in</span> nVisited)</span><br><span class="line">Console.Write(item.ToString());</span><br></pre></td></tr></table></figure><p> foreach处理锯齿数组需进行两次foreach循环</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span>[][] nVisited = <span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">3</span>][];</span><br><span class="line">nVisited[<span class="number">0</span>] = <span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">3</span>] &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;</span><br><span class="line">nVisited[<span class="number">1</span>] = <span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">3</span>] &#123; <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span> &#125;;</span><br><span class="line">nVisited[<span class="number">2</span>] = <span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">6</span>] &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Use &quot;foreach&quot; to loop two-dimension array(使用foreach循环二维数组)</span></span><br><span class="line">Console.WriteLine(<span class="string">&quot;User &#x27;foreach&#x27; to loop two-dimension array&quot;</span>);</span><br><span class="line"><span class="keyword">foreach</span> (<span class="keyword">var</span> item <span class="keyword">in</span> nVisited)</span><br><span class="line">      <span class="keyword">foreach</span> (<span class="keyword">var</span> val <span class="keyword">in</span> item)</span><br><span class="line">          Console.WriteLine(val.ToString());</span><br></pre></td></tr></table></figure><h1 id="ref和out"><a href="#ref和out" class="headerlink" title="ref和out"></a>ref和out</h1><p>​    在C#中通过使用方法来获取返回值时，通常只能得到一个返回值。</p><p>​    因此，<a href="https://blog.csdn.net/qq_43322436/article/details/123363156"><strong>当一个方法需要返回多个值的时候，就需要用到ref和out。</strong> </a>  ref和out都是按地址传递,使用后都将改变原来参数的数值。</p><h3 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h3><p>​    <strong>ref 关键字使参数按引用传递。</strong></p><p>​    其效果是，当控制权传递回调用方法时，<strong>在方法中对参数所做的任何更改都将反映在该变量中</strong>。若要使用 ref 参数，则方法定义和调用方法都必须显式使用 ref 关键字。</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            Program pg = <span class="keyword">new</span> Program();</span><br><span class="line">            <span class="built_in">int</span> x = <span class="number">10</span>;</span><br><span class="line">            <span class="built_in">int</span> y = <span class="number">20</span>;<span class="comment">//此处若 x,y没有进行初始化，则编译不通过。</span></span><br><span class="line">            pg.GetValue(<span class="keyword">ref</span> x, <span class="keyword">ref</span>  y);</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;x=&#123;0&#125;,y=&#123;1&#125;&quot;</span>, x, y);</span><br><span class="line"> </span><br><span class="line">            Console.ReadLine();</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">GetValue</span>(<span class="params"><span class="keyword">ref</span> <span class="built_in">int</span> x, <span class="keyword">ref</span> <span class="built_in">int</span> y</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            x = <span class="number">333</span>;</span><br><span class="line">            y = <span class="number">444</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><img src="/2023/03/08/Csharp_%E5%9F%BA%E7%A1%80/image-20230309002654725.png" class title="image-20230309002654725"><h3 id="out"><a href="#out" class="headerlink" title="out"></a>out</h3><p>​    <strong>out 关键字会导致参数通过引用来传递。</strong></p><p>​    这与 ref 关键字类似，不同之处在于 ref 要求变量必须在传递之前进行初始化。若要使用 out 参数，方法定义和调用方法都必须显式使用 out 关键字。 </p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Program pg = <span class="keyword">new</span> Program();</span><br><span class="line">        <span class="built_in">int</span> x = <span class="number">10</span>;</span><br><span class="line">        <span class="built_in">int</span> y = <span class="number">233</span>;</span><br><span class="line">        Swap(<span class="keyword">out</span> x, <span class="keyword">out</span> y);</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;x=&#123;0&#125;,y=&#123;1&#125;&quot;</span>, x, y);</span><br><span class="line"></span><br><span class="line">        Console.ReadLine();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Swap</span>(<span class="params"><span class="keyword">out</span> <span class="built_in">int</span> a, <span class="keyword">out</span> <span class="built_in">int</span> b</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        a = <span class="number">333</span>;   <span class="comment">//对a,b 在方法内进行了初始化，不会报错</span></span><br><span class="line">        b = <span class="number">444</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2023/03/08/Csharp_%E5%9F%BA%E7%A1%80/image-20230309002644016.png" class title="image-20230309002644016"><h3 id="ref和out的区别"><a href="#ref和out的区别" class="headerlink" title="ref和out的区别"></a>ref和out的区别</h3><p>​    <strong>ref 和 out 本质上都是引用的传递</strong></p><h4 id="口诀："><a href="#口诀：" class="headerlink" title="口诀："></a>口诀：</h4><p>​    ref有进有出，out（有出去的意思）只出不进。</p><ul><li>​    ref修饰引用参数。参数必须赋值，带回返回值，又进又出。</li><li>​    out修饰输出参数。参数可以不赋值，带回返回值之前必须明确赋值。</li></ul><h4 id="相同点："><a href="#相同点：" class="headerlink" title="相同点："></a>相同点：</h4><ul><li>都能返回多个返回值。</li><li>若要使用 ref 和out参数，则方法定义和调用方法都必须显式使用 ref和out 关键字。在方法中对参数的设置和改变将会直接影响函数调用之处(参数的初始值）。</li></ul><h4 id="不同点："><a href="#不同点：" class="headerlink" title="不同点："></a>不同点：</h4><ul><li><p>ref指定的参数在 函数调用前必须初始化，不能为空的引用。而out指定的参数在函数调用时候可以不初始化。</p></li><li><p>out指定的参数在进入函数时会清空自己，必须在函数内部（即方法中）赋初值。而ref指定的参数不需要。</p></li><li><p>ref 将参数的参数值和引用都传入方法中，所以ref的参数的初始化必须在方法外部进行；也就是ref的参数必须有初始化值，否则程序会报错</p></li><li><p>out不会将参数的参数值传入方法中，只会将参数的引用传入方法中，所以参数的初始化工作必须在其对用方法中进行，否则程序会报错</p></li></ul><h1 id="迭代器iterator"><a href="#迭代器iterator" class="headerlink" title="迭代器iterator"></a>迭代器iterator</h1><p><a href="https://www.bilibili.com/video/BV18R4y1t7Hg">几分钟听懂迭代器</a></p><p>​    迭代器是一种设计模式，可以让开发人员无需关心容器对象的底层架构，就可以遍访这个容器对象。简单来说，迭代器就是用来遍历一个序列中的所有对象。</p><p>​    在C#中可以使用foreach关键字就可以枚举一个序列</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">foreach</span> (<span class="keyword">var</span> item <span class="keyword">in</span> collection)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(item?.ToString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    但foreach语句并非完美无缺，它依赖于.NET Co<a href="https://so.csdn.net/so/search?q=re%E5%BA%93&spm=1001.2101.3001.7020">re库</a>中的两个接口：IEnumerable和IEnumerator，接下来我们通过这两个接口实现foreach语句</p><p>​    IEnumerable是可枚举的意思，IEnumerator是枚举器的意思</p><h3 id="IEnumerable接口-可枚举"><a href="#IEnumerable接口-可枚举" class="headerlink" title="IEnumerable接口 可枚举"></a>IEnumerable接口 可枚举</h3><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IEnumerable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">IEnumerator <span class="title">GetEnumerator</span>(<span class="params"></span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    继承这个接口需要实现暴露出来的GetEnumerator方法，返回一个IEnumerator对象</p><h3 id="IEnumerator接口-枚举器"><a href="#IEnumerator接口-枚举器" class="headerlink" title="IEnumerator接口 枚举器"></a>IEnumerator接口 枚举器</h3><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IEnumerator</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">object</span> Current &#123; <span class="keyword">get</span>; &#125; </span><br><span class="line">    <span class="function"><span class="built_in">bool</span> <span class="title">MoveNext</span>(<span class="params"></span>)</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Reset</span>(<span class="params"></span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    IEnumerator是所有非泛型枚举器的基接口。换而言之就是IEnumerator定义了一种适用于任意集合的迭代方式。任意一个集合只要实现自己的IEnumerator，它的使用者就可以通过IEnumerator迭代集合中的元素，而不用针对不同的集合采用不同的迭代方式。    </p><blockquote><ol><li>Current属性可以获取集合中当前迭代位置的元素</li><li>MoveNext方法将当前迭代位置推进到下一个位置，如果成功推进到下一个位置则返回true，否则已经推进到集合的末尾返回false</li><li>Reset方法可以将当前迭代位置设置为初始位置（该位置位于集合中第一个元素之前，所以当调用Reset方法后，再调用MoveNext方法，Curren值则为集合的第一个元素）</li></ol></blockquote><p>​    所以继承这个接口需要实现这三个东西。从这个两个接口对比就可以发现，对于枚举一个容器，起真正作用是IEnumerator，所以一个对象只要实现IEnumerator接口就能遍历。</p><p>​    不难看出，foreach关键字就是主要依靠IEnumerator接口实现。</p><p>​    比如我们经常会使用的<a href="https://docs.microsoft.com/zh-cn/dotnet/csharp/iterators#deeper-dive-into-foreach">foreach</a>关键字遍历集合，其实<code>foreach</code>只是C#提供的语法糖而已</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">foreach</span> (<span class="keyword">var</span> item <span class="keyword">in</span> collection)</span><br><span class="line">&#123;</span><br><span class="line">   Console.WriteLine(item.ToString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    本质上<code>foreach</code>循环也是采用IEnumerator来遍历集合的。在编译时编译器会将上面的<code>foreach</code>循环转换为类似于下面的代码</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> enumerator = collection.GetEnumerator();</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (enumerator.MoveNext())  <span class="comment">// 判断是否成功推进到下一个元素（可理解为集合中是否还有可供迭代的元素）</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> item = enumerator.Current;</span><br><span class="line">            Console.WriteLine(item.ToString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// dispose of enumerator.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    那IEnumerable接口是干嘛的呢？上面已经说了，它只有一个GetEnumerator方法，并且返回的是一个IEnumerator类型的对象，所以说IEnumerable的作用就是获得可用于循环访问集合的IEnumerator对象。</p><p>​    可以发现，foreach在运行时会先调用Anim类中的GetEnumerator方法获得一个MIEnumerator，然后通过MIEnumerator的MoveNext方法后移，在调用Current方法获得元素的值，之后一直循环MoveNext和Current方法来遍历整个Anim序列</p><p>​    不难得出，GetEnumerator方法负责获取枚举器IEnumerator，MoveNext方法负责向下一个元素移动，Current方法负责返回当前的元素的值，Reset方法负责重置枚举器状态</p><h3 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a>小总结</h3><p>​    IEnumerable接口的作用就是获得枚举器IEnumerator，而IEnumerator接口的作用才是迭代的主体，负责遍历序列</p><p>​    通过这两段代码就可以看出foreach遍历的原理是先通过IEnumerable获得枚举器IEnumerator，然后通过枚举器的MoveNext和Current方法来遍历序列。</p><h2 id="yield关键字"><a href="#yield关键字" class="headerlink" title="yield关键字"></a>yield关键字</h2><p>​    yield是迭代器中的关键字，用于向枚举对象提供值或发出迭代结束的信号。其实就是快速定义迭代器的语法糖，是为了简化迭代器的实现语法才产生的。从上面的讲解不难发现，在枚举器中起实际起作用的就是MoveNext和Current方法。所以C#提供一个处理方法：yield语句。</p><p>​    有了yield语句，我们可以在自己的类或者序列中支持foreach迭代而不必实现IEnumerator和IEnumerable接口，我们只要提供一个迭代器，当编辑器检测到迭代器时，会自动生成IEnumerator接口中的Current，MoveNext和Reset方法。</p><p>​    注意，yield只能用于迭代器，也就是说yield只能用于返回值是IEnumertor和IEnumerable接口及其泛型版本</p><p>​    试试想象如果没有<code>yield</code>关键字，我们每定义一个迭代器，就要创建一个类，实现<code>IEnumerator</code>接口，接口包含的属性与方法都要正确的实现，是不是很麻烦？而利用<code>yield</code>关键字，只需要下面简单的几行代码，就可以快速定义一个迭代器。诸如迭代器类的创建，<code>IEnumerator</code>接口的实现工作编译器通通帮你做了</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 由迭代器函数定义的迭代器</span></span><br><span class="line"><span class="function">IEnumerator <span class="title">Test</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    Debug.Log(<span class="string">&quot;Surprise&quot;</span>);</span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="yield为什么能停住代码？"><a href="#yield为什么能停住代码？" class="headerlink" title="yield为什么能停住代码？"></a>yield为什么能停住代码？</h2><p>​    到这里，我想代码“停住”与恢复的神秘面纱终于被揭开了。总结下来就是，以能“停住”的地方为分界线，编译器会为不同分区的语句按照功能逻辑生成一个个对应的代码块。<code>yield</code>语句就是这条分界线，想要代码“停住”，就不执行后面语句对应的代码块，想要代码恢复，就接着执行后面语句对应的代码块。而调度上下文的保存，是通过将需要保存的变量都定义成成员变量来实现的。</p>]]></content>
      
      
      
        <tags>
            
            <tag> C# </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【C#】委托 事件 Lambda 闭包问题</title>
      <link href="/2023/03/08/Csharp%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98Lambda%E9%97%AD%E5%8C%85/"/>
      <url>/2023/03/08/Csharp%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98Lambda%E9%97%AD%E5%8C%85/</url>
      
        <content type="html"><![CDATA[<p><strong>关于委托和事件，更推荐看这个视频：<a href="https://www.bilibili.com/video/BV163411S7QG">https://www.bilibili.com/video/BV163411S7QG</a></strong></p><p>​    ↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑相信我↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑</p><h1 id="委托-Delegate"><a href="#委托-Delegate" class="headerlink" title="委托 Delegate"></a>委托 Delegate</h1><p>​    <a href="https://zhuanlan.zhihu.com/p/491655559">委托，事件，匿名函数，Lambda</a></p><p>​    </p><p>​    （下文中把函数和方法混为一谈，默认二者相等，其实这里用方法更合适）</p><h3 id="委托的作用"><a href="#委托的作用" class="headerlink" title="委托的作用"></a>委托的作用</h3><ul><li>​    函数传参（例如回调函数）</li><li>​    基于委托去声明事件，并注册</li></ul><p>​    **委托相当于把某一个方法当成参数,当执行委托的时候就相当于执行了方法,所以这个方法必须和委托具有相同的参数类型.**<a href="https://blog.csdn.net/sam_game/article/details/53894802">https://blog.csdn.net/sam_game/article/details/53894802</a></p><p>​    委托是函数(方法)的容器，可以理解为表示函数(方法)的变量类型，用来存储、传递函数(方法)。委托的本质是一个类，用来定义函数(方法)的类型(返回值和参数的类型)，不同的函数(方法)必须对应和各自”格式”一致的委托。</p><p>​    <strong>注意：我们时刻要记住委托变量是函数的容器</strong></p><blockquote><p>例如，假设有一个委托：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="built_in">int</span> <span class="title">MyDelegate</span> (<span class="params"><span class="built_in">string</span> s</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">Fun</span>(<span class="params"></span>)</span>;</span><br><span class="line"><span class="comment">// ***注意：(在同一语句块中)委托不存在同名的两个委托，编辑器会报错误的，它不是函数不能重载</span></span><br><span class="line"><span class="function"><span class="built_in">delegate</span> <span class="built_in">int</span> <span class="title">Fun2</span>(<span class="params"><span class="built_in">int</span> a</span>)</span>;<span class="comment">// 表示用来装载或者传递返回值为int 有一个int参数的函数的委托容器规则</span></span><br></pre></td></tr></table></figure><p>上面的委托可被用于引用任何一个带有一个单一的 <em>string</em> 参数的方法，并返回一个 <em>int</em> 类型变量。</p></blockquote><h3 id="例如："><a href="#例如：" class="headerlink" title="例如："></a>例如：</h3><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo=<span class="keyword">new</span> Foo(MyFunc);<span class="comment">//委托的声明时 必须传入一个参数（当然后面可以删掉，为空会报错）</span></span><br><span class="line">foo+= MyFunc;</span><br><span class="line">foo+= MyFunc2;</span><br><span class="line">foo+= MyFunc;</span><br><span class="line">foo?.Invoke();<span class="comment">//?.Invoke() 可以避免为空的报错</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MyFunc</span>(<span class="params"></span>)</span>&#123;<span class="comment">//某函数</span></span><br><span class="line"><span class="string">&quot;hello&quot;</span>.Dump();<span class="comment">//此处的Dump是LINQpad7 特有的功能</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MyFunc2</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="string">&quot;World&quot;</span>.Dump();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">Foo</span>(<span class="params"></span>)</span>;<span class="comment">//委托</span></span><br></pre></td></tr></table></figure><img src="/2023/03/08/Csharp%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98Lambda%E9%97%AD%E5%8C%85/image-20230308200720979.png" class title="image-20230308200720979"><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo=<span class="keyword">new</span> Foo(MyFunc);<span class="comment">//委托的实例化 </span></span><br><span class="line">foo.Invoke(<span class="number">10</span>).Dump();<span class="comment">//Or foo(10).Dump();</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">MyFunc</span>(<span class="params"><span class="built_in">int</span> b</span>)</span>&#123;<span class="comment">//某函数</span></span><br><span class="line"><span class="keyword">return</span> (b+<span class="number">1</span>).ToString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">delegate</span> <span class="built_in">string</span> <span class="title">Foo</span>(<span class="params"><span class="built_in">int</span> a</span>)</span>;<span class="comment">//委托//带参数的委托</span></span><br><span class="line"><span class="comment">//如果有多个，只会返回最后加的东西</span></span><br></pre></td></tr></table></figure><img src="/2023/03/08/Csharp%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98Lambda%E9%97%AD%E5%8C%85/image-20230308201157283.png" class title="image-20230308201157283"><h4 id="委托作为回调函数"><a href="#委托作为回调函数" class="headerlink" title="委托作为回调函数"></a>委托作为回调函数</h4><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">MyHeavyJob(MyCallback);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MyHeavyJob</span>(<span class="params">Callback callback</span>)</span>&#123;</span><br><span class="line">Thread.Sleep(<span class="number">1500</span>);</span><br><span class="line"></span><br><span class="line">callback();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MyCallback</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="string">&quot;Job Done&quot;</span>.Dump();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">Callback</span>(<span class="params"></span>)</span>;</span><br></pre></td></tr></table></figure><p>过了1.5s以后，输出<img src="/2023/03/08/Csharp%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98Lambda%E9%97%AD%E5%8C%85/image-20230308201643879.png" class title="image-20230308201643879"></p><img src="/2023/03/08/Csharp%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98Lambda%E9%97%AD%E5%8C%85/image-20230308202536887.png" class title="image-20230308202536887"><p>​    如图，委托相当于给函数的参数加了一个接口，你可以放入你想放入的参数，只不过这个参数，是对于这个委托合适的函数（即你可以自定义方式，更便捷）。</p><p>​    委托本身还可以进一步定制化，例如图中MyRule可以改成泛型T。</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> rule = <span class="keyword">new</span> MyRule&lt;<span class="built_in">int</span>&gt;(MySpecialRule);</span><br><span class="line">rule(<span class="number">10</span>,<span class="number">20</span>).Dump();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">bool</span> <span class="title">MySpecialRule</span> (<span class="params"><span class="built_in">int</span> x, <span class="built_in">int</span> y</span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="built_in">bool</span> <span class="title">MySpecialRule2</span> (<span class="params"><span class="built_in">int</span> x, <span class="built_in">int</span> y</span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">delegate</span> <span class="built_in">bool</span> <span class="title">MyRule</span>&lt;<span class="title">T</span>&gt;(<span class="params">T x ,T y</span>)</span>; </span><br></pre></td></tr></table></figure><h3 id="Action"><a href="#Action" class="headerlink" title="Action"></a>Action</h3><p>​    我们发现上面委托的MyRule名字其实不重要，叫啥其实无所谓。于是官方提供了强类型委托，即Action。所以Action即是一种没有返回值的委托。同理，Func其实就是有返回值的委托</p><blockquote><p>可以使用此委托将方法作为参数传递，而无需显式声明自定义委托。 封装的方法必须与此委托定义的方法签名相对应。 这意味着封装的方法必须没有参数，也没有返回值。 (C# 中，该方法必须返回 <code>void</code>）</p></blockquote><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">PickOne(<span class="number">10</span>,<span class="number">20</span>,MySpecialRule).Dump();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">int</span>  <span class="title">PickOne</span>(<span class="params"><span class="built_in">int</span> a,<span class="built_in">int</span> b,Func&lt;<span class="built_in">int</span>,<span class="built_in">int</span>,<span class="built_in">bool</span>&gt; rule</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(rule(a,b))<span class="keyword">return</span> a;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> b;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">bool</span> <span class="title">MySpecialRule</span> (<span class="params"><span class="built_in">int</span> x, <span class="built_in">int</span> y</span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2023/03/08/Csharp%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98Lambda%E9%97%AD%E5%8C%85/image-20230308203334447.png" class title="image-20230308203334447"><h3 id="匿名委托"><a href="#匿名委托" class="headerlink" title="匿名委托"></a>匿名委托</h3><p>反正名字也不重要了，为啥还要留一个委托名字是吧，于是匿名委托出现，请对比上图</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">PickOne(<span class="number">10</span>,<span class="number">20</span>, <span class="built_in">delegate</span>(<span class="built_in">int</span> a,<span class="built_in">int</span> b)&#123;<span class="keyword">return</span> <span class="literal">true</span>; &#125;).Dump();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">int</span>  <span class="title">PickOne</span>(<span class="params"><span class="built_in">int</span> a,<span class="built_in">int</span> b,Func&lt;<span class="built_in">int</span>,<span class="built_in">int</span>,<span class="built_in">bool</span>&gt; rule</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(rule(a,b))<span class="keyword">return</span> a;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> b;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h4><p>​    匿名函数就是没有名字的函数;匿名函数的使用主要是配合委托和事件进行使用的;脱离委托和事件是不会使用匿名函数的。</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.无参无返回</span></span><br><span class="line"><span class="comment">// ***注意:我们是无法申明匿名函数的,匿名函数是无法脱离了委托和事件存在的,所以匿名函数申明必须作为委托或者事件的右值赋值给委托或者事件,而无法单独存在.</span></span><br><span class="line">Action ac = <span class="built_in">delegate</span> ()&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 执行匿名函数</span></span><br><span class="line">ac();</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.有参数</span></span><br><span class="line">Action&lt;<span class="built_in">int</span> ,<span class="built_in">string</span>&gt; b = <span class="built_in">delegate</span> (<span class="built_in">int</span> a, <span class="built_in">string</span> b)&#123;</span><br><span class="line">    Console.WriteLine(a);</span><br><span class="line">    Console.WriteLine(b);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.有返回值</span></span><br><span class="line">Func&lt;<span class="built_in">string</span>&gt; func = <span class="built_in">delegate</span> ()&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;123123&quot;</span>;  </span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 执行</span></span><br><span class="line">Console.WriteLine(func());</span><br><span class="line"></span><br><span class="line"><span class="comment">//4.一般情况会作为函数参数传递或者作为函数返回值</span></span><br><span class="line"><span class="comment">// 作为参数传递时</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> Action action;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DoSomething</span>(<span class="params"><span class="built_in">int</span> a, Action fun</span>)</span>&#123;</span><br><span class="line">       Console.WriteLine(a);</span><br><span class="line">        fun();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Action <span class="title">GetFun</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">delegate</span> ()&#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Test2</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">// 参数传递</span></span><br><span class="line">        Test t = <span class="keyword">new</span> Test();</span><br><span class="line">        t.DoSomething(<span class="number">100</span>, <span class="built_in">delegate</span> ()&#123;</span><br><span class="line">           Console.WriteLine(<span class="string">&quot;随着参数传入的匿名函数&quot;</span>); </span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 返回值</span></span><br><span class="line">        Action ac = t.GetFun();</span><br><span class="line">        ac();</span><br><span class="line">        <span class="comment">// 我们也可以直接一步到位</span></span><br><span class="line">        <span class="comment">// 我们先看前一半ac()返回了一个函数名,函数名＋后一半&quot;()&quot;相当于调用这个 函数</span></span><br><span class="line">        ac()();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="匿名函数的缺点"><a href="#匿名函数的缺点" class="headerlink" title="匿名函数的缺点"></a><strong>匿名函数的缺点</strong></h4><p>添加到委托或者事件容器后,不记录下来的话,我们无法单独移除,因为我们的匿名函数没有函数名,所以唯一的方法是把委托或者事件容器全部清空才行.</p><h3 id="Lambda（更多看下列详解）"><a href="#Lambda（更多看下列详解）" class="headerlink" title="Lambda（更多看下列详解）"></a>Lambda（更多看下列详解）</h3><p>当然，现在没人会写上面这种形式的匿名委托了，大家都用Lambda表达式，仔细对比</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">PickOne(<span class="number">10</span>,<span class="number">20</span>, (a,b)=&gt;<span class="literal">true</span> ).Dump();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">int</span>  <span class="title">PickOne</span>(<span class="params"><span class="built_in">int</span> a,<span class="built_in">int</span> b,Func&lt;<span class="built_in">int</span>,<span class="built_in">int</span>,<span class="built_in">bool</span>&gt; rule</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(rule(a,b))<span class="keyword">return</span> a;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> b;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个表达式 <strong>(a,b)=&gt;true</strong> ，归根结底就是一种委托，它最终会被转成Action或者Func</p><blockquote><p>即：delegate(int a,int b){return true;}</p><p>等于 (a,b)=&gt;true</p></blockquote><h3 id="Unity中"><a href="#Unity中" class="headerlink" title="Unity中"></a>Unity中</h3><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="comment">//首先先说明一点，委托的本质是一个类</span></span><br><span class="line"><span class="comment">//委托(代理) 是存有对某个方法的引用的一种引用类型变量。</span></span><br><span class="line"><span class="comment">//委托语法:delegate &lt;return type&gt; &lt;delegate-name&gt; &lt;parameter list&gt;</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">DelegateTest</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//声明一个没有返回值的委托,委托可以写在类中也可以写在类名的外面</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">PrintString</span>(<span class="params"><span class="built_in">string</span> <span class="keyword">value</span></span>)</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//普通的方法,输出你传入的字符串</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DebugString</span>(<span class="params"><span class="built_in">string</span> s</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Debug.Log(s);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        DebugString(<span class="string">&quot;普通的方法&quot;</span>);</span><br><span class="line">        <span class="comment">//声明一个委托并且将和委托具有相同参数类型的方法DebugString传入</span></span><br><span class="line">        PrintString p1 = <span class="keyword">new</span> PrintString(DebugString);</span><br><span class="line">        <span class="comment">//此时这个委托具有和 DebugString方法相同的功能</span></span><br><span class="line">        p1(<span class="string">&quot;委托测试&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>​    委托即使得一个函数也能使用另一个函数的功能了？</p><img src="/2023/03/08/Csharp%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98Lambda%E9%97%AD%E5%8C%85/image-20230307174045922.png" alt="image-20230307174045922" style="zoom:80%;"><blockquote><p>​    例如，假设您有两个方法A和B，A需要调用B来完成某个任务。您可以使用委托将方法B作为参数传递给方法A，使得方法A可以通过委托调用方法B，从而完成该任务</p></blockquote><h3 id="多播委托"><a href="#多播委托" class="headerlink" title="多播委托"></a><strong>多播委托</strong></h3><p>​    <strong>多播</strong>：委托对象可使用 “+” 运算符进行合并。一个合并委托调用它所合并的两个委托。只有相同类型的委托可被合并。”-“ 运算符可用于从合并的委托中移除组件委托。 (上面出现过了，但我懒得删咯)</p><p>​    <strong>简单来说就是委托执行的时候可以执行多个方法</strong></p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="comment">//多播(组播),委托对象可使用 &quot;+&quot; 运算符进行合并。一个合并委托调用它所合并的两个委托。只有相同类型的委托可被合并。&quot;-&quot; 运算符可用于从合并的委托中移除组件委托。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">DelegateTest</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//声明一个没有返回值的委托,委托可以写在类中也可以写在类名的外面</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">PrintString</span>(<span class="params"><span class="built_in">string</span> <span class="keyword">value</span></span>)</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//声明一个委托并且将和委托具有相同参数类型的方法DebugString传入</span></span><br><span class="line">        PrintString p ;</span><br><span class="line">        PrintString p1 = <span class="keyword">new</span> PrintString(DebugStringOne);</span><br><span class="line">        PrintString p2 = <span class="keyword">new</span> PrintString(DebugStringTwo);</span><br><span class="line">       </span><br><span class="line">        p = p1;</span><br><span class="line">        p += p2;</span><br><span class="line">        <span class="comment">//调用多播</span></span><br><span class="line">        p(<span class="string">&quot;委托测试&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//普通的方法,输出你传入的字符串</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DebugStringOne</span>(<span class="params"><span class="built_in">string</span> s</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Debug.Log(<span class="string">&quot;DebugStringOne:&quot;</span> + s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DebugStringTwo</span>(<span class="params"><span class="built_in">string</span> s</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Debug.Log(<span class="string">&quot;DebugStringTwo:&quot;</span> + s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2023/03/08/Csharp%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98Lambda%E9%97%AD%E5%8C%85/image-20230307174027354.png" alt="image-20230307174027354" style="zoom: 67%;"><h1 id="事件-Event"><a href="#事件-Event" class="headerlink" title="事件 Event"></a>事件 Event</h1><p>​    <strong>事件是基于委托的存在，事件是委托的安全包裹，让委托的使用更具有安全性。</strong></p><p>​    上面可知，委托在声明时，必须立刻注册一个方法。但是用事件可以不用急。</p><p>​    事件在类中声明且生成，且通过使用同一个类或其他类中的委托与事件处理程序关联。包含事件的类用于发布事件。这被称为 <strong>发布器（publisher）</strong> 类。其他接受该事件的类被称为 <strong>订阅器（subscriber）</strong> 类。事件使用 <strong>发布-订阅（publisher-subscriber）</strong> 模型。（观察者模型？）</p><blockquote><p>​    <strong>发布器（publisher）</strong> 是一个包含事件和委托定义的对象。事件和委托之间的联系也定义在这个对象中。发布器（publisher）类的对象调用这个事件，并通知其他的对象。</p><p>​    <strong>订阅器（subscriber）</strong> 是一个接受事件并提供事件处理程序的对象。在发布器（publisher）类中的委托调用订阅器（subscriber）类中的方法（事件处理程序）。</p></blockquote><p>​    在类的内部声明事件，首先必须声明该事件的委托类型。例如：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">BoilerLogHandler</span>(<span class="params"><span class="built_in">string</span> status</span>)</span>;</span><br></pre></td></tr></table></figure><p>​    然后，声明事件本身，使用 <strong>event</strong> 关键字：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基于上面的委托定义事件</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">event</span> BoilerLogHandler BoilerEventLog;</span><br></pre></td></tr></table></figure><p>​    上面的代码定义了一个名为 <em>BoilerLogHandler</em> 的委托和一个名为 <em>BoilerEventLog</em> 的事件，该事件在生成的时候会调用委托。</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 首先我们要记住:</span></span><br><span class="line"><span class="comment">// 事件相对于委托的区别：</span></span><br><span class="line"><span class="comment">// 1.不能在类的外部赋值</span></span><br><span class="line"><span class="comment">// 2.不能在类外部调用</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 举例:</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">Test2</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        Test t = <span class="keyword">new</span> Test();</span><br><span class="line">        <span class="comment">// 我们会发现,我们的委托是可以在类的外部被点(.)出来使用的</span></span><br><span class="line">        t.myFun = <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">// 但是我们的Event不行,尽管它是Public的访问修饰符</span></span><br><span class="line">        <span class="comment">// Event能做的只能是在类的外部执行增(+=)和删(-=),不允许赋值操作</span></span><br><span class="line">    </span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 我们的委托是可以在类的外部被调用的</span></span><br><span class="line">        t.myFun();</span><br><span class="line">        t.myFun.Invoke();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 但是我们的事件Event是做不到的,如果我们需要调用Event是需要在类的内部进行封装方法的</span></span><br><span class="line">        <span class="comment">// ***注意:事件是不能作为临时变量在函数中使用的,也就是我们在函数中是无法申明事件的,它只能作为成员存在于类\接口\结构体中,但是委托是可以的        </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="没听懂？来看简单的"><a href="#没听懂？来看简单的" class="headerlink" title="没听懂？来看简单的"></a>没听懂？来看简单的</h3><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> demo =<span class="keyword">new</span> Demo();</span><br><span class="line">demo.MyEvent+= ()=&gt; <span class="string">&quot;hello&quot;</span>.Dump();</span><br><span class="line">demo.InvokeEvent();</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Demo</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">event</span> Action MyEvent;<span class="comment">//action就是一个委托，这里实例化一个event</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">InvokeEvent</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//MyEvent();//等于MyEvent.Invoke();</span></span><br><span class="line">MyEvent?.Invoke();<span class="comment">//同样的，Event注册的委托若为空，则报错</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为什么要在类里面声明事件？这里想到了观察者模式，当类中有东西发生变化，我们可以用事件对外界发出通知。</p><h3 id="Event与观察者模式"><a href="#Event与观察者模式" class="headerlink" title="Event与观察者模式"></a>Event与观察者模式</h3><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> demo =<span class="keyword">new</span> Demo();</span><br><span class="line">demo.MyValueChanged+= ()=&gt; <span class="string">&quot;value changed observed&quot;</span>.Dump();<span class="comment">//所谓的观测者，即注册了事件的</span></span><br><span class="line">demo.Myvalue = <span class="number">10</span>;</span><br><span class="line">demo.Myvalue = <span class="number">12</span>;</span><br><span class="line">demo.Myvalue = <span class="number">14</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Demo</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">int</span> myValue;</span><br><span class="line"><span class="keyword">public</span> <span class="built_in">int</span> Myvalue</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">get</span>&#123;<span class="keyword">return</span> myValue;&#125;</span><br><span class="line"><span class="keyword">set</span>&#123;</span><br><span class="line">myValue=<span class="keyword">value</span>;</span><br><span class="line">MyValueChanged?.Invoke();<span class="comment">//在调用Myvalue的set，即被赋值时，会发出通知</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">event</span> Action MyValueChanged;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2023/03/08/Csharp%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98Lambda%E9%97%AD%E5%8C%85/image-20230308205657186.png" class title="image-20230308205657186"><p>​    很明显，这时候成功完成了观察者模式。</p><h3 id="事件的作用"><a href="#事件的作用" class="headerlink" title="事件的作用"></a><strong>事件的作用</strong></h3><p>1.防止外部随意置空委托</p><p>2.防止外部随意调用委托</p><p>3.事件相当于对委托进行了一次封装让其更安全</p><blockquote><p>例如，假设您正在编写一个窗体应用程序，该应用程序包含一个按钮。您可以使用事件来处理当用户单击该按钮时发生的事件。在这种情况下，按钮是事件的发布者对象，窗体是事件的订阅者对象。当用户单击按钮时，按钮会触发Click事件，通知窗体执行特定的操作，例如弹出一个消息框或执行一些计算等。</p></blockquote><h1 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a><strong>Lambda表达式</strong></h1><p>​    Lambda表达式可以理解为<strong>匿名函数的简写形式</strong>，它除了写法上的不同外，使用上和功能上完全与匿名函数一模一样，优缺点也是一模一样的，同理，它也是需要配合委托或者事件使用的。（就是委托的简写哈哈）</p><blockquote><p>这个表达式 <strong>(a,b)=&gt;true</strong> ，归根结底就是一种委托，它最终会被转成Action或者Func    （来自本文Delegate部分的Lambda小部分）</p><blockquote><p>即：delegate(int a,int b){return true;}</p><p>等于 (a,b)=&gt;true</p></blockquote></blockquote><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.无参无返回值</span></span><br><span class="line"><span class="comment">// ***注意：Lambda表达式是无法单独使用的，是需要配合委托或者事件使用的</span></span><br><span class="line">Action ac = ()=&gt;&#123;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.有参数无返回值</span></span><br><span class="line">Action ac = (<span class="built_in">int</span> <span class="keyword">value</span>)=&gt;&#123;</span><br><span class="line">    Console.WriteLine(<span class="keyword">value</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.甚至参数类型都可以省略，只要参数类型和委托或事件容器一致的就行</span></span><br><span class="line"><span class="comment">// 因为我们通过泛型占位字母指定了我们的类型，所以我们可以省略参数类型</span></span><br><span class="line">Action&lt;<span class="built_in">int</span>&gt; ac = (<span class="keyword">value</span>)=&gt;&#123;</span><br><span class="line">    Console.WriteLine(<span class="keyword">value</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4.有返回值的</span></span><br><span class="line">Func&lt;<span class="built_in">string</span>, <span class="built_in">int</span>&gt; ac = (<span class="keyword">value</span>)=&gt;&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;123&quot;</span>;  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><img src="/2023/03/08/Csharp%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98Lambda%E9%97%AD%E5%8C%85/image-20230308212955037.png" alt="image-20230308212955037" style="zoom: 33%;"><h3 id="典型的lambda"><a href="#典型的lambda" class="headerlink" title="典型的lambda"></a>典型的lambda</h3><img src="/2023/03/08/Csharp%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98Lambda%E9%97%AD%E5%8C%85/image-20230308213048208.png" alt="image-20230308213048208" style="zoom: 50%;"><p>​    Func有返回值，所以第三个是返回类型。</p><img src="/2023/03/08/Csharp%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98Lambda%E9%97%AD%E5%8C%85/image-20230308213129591.png" alt="image-20230308213129591" style="zoom:50%;"><p>​    Action没有返回值</p><h4 id="predicate"><a href="#predicate" class="headerlink" title="predicate"></a>predicate</h4><img src="/2023/03/08/Csharp%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98Lambda%E9%97%AD%E5%8C%85/image-20230308213141662.png" alt="image-20230308213141662" style="zoom:50%;"><p>第三种是只能输入一个参数，只能返回一个bool值，这里表示s若全大写且相同即返回true。</p><h3 id="用在回调函数"><a href="#用在回调函数" class="headerlink" title="用在回调函数"></a>用在回调函数</h3><img src="/2023/03/08/Csharp%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98Lambda%E9%97%AD%E5%8C%85/image-20230308213401026.png" alt="image-20230308213401026" style="zoom:50%;"><h3 id="和List配合的过滤功能"><a href="#和List配合的过滤功能" class="headerlink" title="和List配合的过滤功能"></a>和List配合的过滤功能</h3><p>比如，过滤出List中大于3的值并输出。</p><img src="/2023/03/08/Csharp%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98Lambda%E9%97%AD%E5%8C%85/image-20230308213439001.png" alt="image-20230308213439001" style="zoom: 50%;"><p>​    可以用Lambda用一行写出</p><img src="/2023/03/08/Csharp%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98Lambda%E9%97%AD%E5%8C%85/image-20230308213513786.png" alt="image-20230308213513786" style="zoom: 50%;"><p>​    这里l1就是List，Where是List内置的方法，定位某一个元素。</p><p>​    n即为输入的，右边是决定条件，这一套就会遍历输出实现上述效果。</p><h3 id="性能问题（未深究）"><a href="#性能问题（未深究）" class="headerlink" title="性能问题（未深究）"></a>性能问题（未深究）</h3><p>​    unity中for循环使用lambda表达式注意闭包问题。同时Lambda表达式，使用不当会产生内存泄漏。</p><h1 id="闭包-closure"><a href="#闭包-closure" class="headerlink" title="闭包 closure"></a>闭包 closure</h1><h3 id="闭包是啥"><a href="#闭包是啥" class="headerlink" title="闭包是啥"></a>闭包是啥</h3><p>　　<strong>委托：</strong>委托是一个类，它定义了方法的类型，使得可以将方法当作另一个方法的参数来进行传递，这种将方法动态地赋给参数的做法，可以避免在程序中大量使用If-Else(Switch)语句，同时使得程序具有更好的可扩展性。(关于委托的讲解，网上已经有很多文章了，这里不再赘述，笼统一点你可以把委托简单地理解为函数指针)</p><p>​    　<strong>闭包其实就是使用的变量已经脱离其作用域，却由于和作用域存在上下文关系，从而可以在当前环境中继续使用其上文环境中所定义的一种函数对象。</strong></p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TCloser</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Func&lt;<span class="built_in">int</span>&gt; <span class="title">T1</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> n = <span class="number">999</span>;</span><br><span class="line">        <span class="keyword">return</span> () =&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(n);</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> a = <span class="keyword">new</span> TCloser();</span><br><span class="line">        <span class="keyword">var</span> b = a.T1();</span><br><span class="line">        Console.WriteLine(b());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    从上面的代码我们不难看到，变量n实际上是属于函数T1的局部变量，它本来的生命周期应该是伴随着函数T1的调用结束而被释放掉的，但这里我们却在返回的委托b中仍然能调用它，这里正是C#闭包的特性。</p><p>​    在T1调用返回的匿名委托的代码片段中我们用到了n，而在编译器看来，这些都是合法的，因为返回的委托b和函数T1存在上下文关系，也就是说匿名委托b是允许使用它所在的函数或者类里面的局部变量的，于是编译器通过一系列操作使b中调用的函数T1的局部变量自动闭合，从而使该局部变量满足新的作用范围。</p><h4 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a>小总结</h4><h5 id="怎么会产生闭包？"><a href="#怎么会产生闭包？" class="headerlink" title="怎么会产生闭包？"></a>怎么会产生闭包？</h5><p>​    内部函数使用了外部函数的局部变量。内部函数：是我对匿名函数，lambda表达式等函数嵌套情况的称呼。如上述例子：外部函数Addfun，内部函数是lambda表达式，i是外部函数for循环中的局部变量，内部函数lambda表达式使用了i这个局部变量。</p><h5 id="闭包会导致什么的结果？"><a href="#闭包会导致什么的结果？" class="headerlink" title="闭包会导致什么的结果？"></a>闭包会导致什么的结果？</h5><p>​    闭包会延长所用外部函数局部变量的生命周期，或者说是局部变量变成了全局变量。</p><h3 id="闭包问题"><a href="#闭包问题" class="headerlink" title="闭包问题"></a><a href="https://www.cnblogs.com/HQFZ/p/4903400.html">闭包问题</a></h3><p>​    <strong>如果在实际工作中用到了匿名函数和lamada表达式，那你就应该高度注意啦.</strong>    （其实问题更多出现在循环里面）</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;Starting.&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i)</span><br><span class="line">        Task.Run(() =&gt; Console.WriteLine(i));</span><br><span class="line"></span><br><span class="line">    Console.WriteLine(<span class="string">&quot;Finished. Press &lt;ENTER&gt; to exit.&quot;</span>);</span><br><span class="line">    Console.ReadLine();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上函数会输出</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Starting.</span><br><span class="line">Finished. Press &lt;ENTER&gt; to exit.</span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure><p>修改一下的话就能解决闭包问题</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;Starting.&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> j = i;</span><br><span class="line">        Task.Run(() =&gt; Console.WriteLine(j));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Console.WriteLine(<span class="string">&quot;Finished. Press &lt;ENTER&gt; to exit.&quot;</span>);</span><br><span class="line">    Console.ReadLine();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Starting.</span><br><span class="line">Finished. Press &lt;ENTER&gt; to exit.</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure><blockquote><p>​    In essence, a closure is a block of code which can be executed at a later time, but which maintains the environment in which it was first created - i.e. it can still use the local variables etc of the method which created it, even after that method has finished executing.</p><p>​    这段话的大意是：从本质上说，闭包是一段可以在晚些时候执行的代码块，但是这段代码块依然维护着它第一个被创建时环境（执行上下文）- 即它仍可以使用创建它的方法中局部变量，即使那个方法已经执行完了。    </p></blockquote><h3 id="在Unity中实际"><a href="#在Unity中实际" class="headerlink" title="在Unity中实际"></a>在Unity中实际</h3><p>在项目中动态地监听一组按钮，要求为按钮 <code>i</code> 注册函数 <code>ActiveBlueprint(i)</code> （带一个 <code>int</code> 参数的函数），初始代码如下：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Awake</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 初始化所有界面和对应按钮，监听按钮</span></span><br><span class="line">    blueprints = <span class="keyword">new</span> List&lt;GameObject&gt;();</span><br><span class="line">    blueprintButtons = <span class="keyword">new</span> List&lt;Button&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; panelNumber; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//Debug.Log(&quot;Blueprint&quot; + i.ToString().PadLeft(2, &#x27;0&#x27;));</span></span><br><span class="line">        blueprints.Add(transform.Find(<span class="string">&quot;Blueprint&quot;</span> + i.ToString().PadLeft(<span class="number">2</span>, <span class="string">&#x27;0&#x27;</span>)).gameObject);</span><br><span class="line">        blueprintButtons.Add(transform.Find(<span class="string">&quot;MainPanel/Button&quot;</span> + i.ToString().PadLeft(<span class="number">2</span>, <span class="string">&#x27;0&#x27;</span>)).GetComponent&lt;Button&gt;());</span><br><span class="line">        blueprintButtons[i].onClick.AddListener(() =&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            ActiveBlueprint(i);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    由于使用了 <strong>lambda 表达式</strong>作为 <strong>AddListener 的参数</strong>，变量 i 成为了被 lambda 表达式捕获的外部变量，所以变量 i 将不会被作为垃圾回收，直至引用变量的委托符合垃圾回收的条件。</p><p>​    i 的最终取值是 panelNumber，这导致所有按钮都被注册了 ActiveBlueprint(panelNumber)，和需求不符，解决方法是在每一轮循环中都定义新的变量，这样每一次 lambda 表达式都捕获了不同的变量，避免闭包陷阱。</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Awake</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 初始化所有界面和对应按钮，监听按钮</span></span><br><span class="line">    blueprints = <span class="keyword">new</span> List&lt;GameObject&gt;();</span><br><span class="line">    blueprintButtons = <span class="keyword">new</span> List&lt;Button&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; panelNumber; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//Debug.Log(&quot;Blueprint&quot; + i.ToString().PadLeft(2, &#x27;0&#x27;));</span></span><br><span class="line">        blueprints.Add(transform.Find(<span class="string">&quot;Blueprint&quot;</span> + i.ToString().PadLeft(<span class="number">2</span>, <span class="string">&#x27;0&#x27;</span>)).gameObject);</span><br><span class="line">        blueprintButtons.Add(transform.Find(<span class="string">&quot;MainPanel/Button&quot;</span> + i.ToString().PadLeft(<span class="number">2</span>, <span class="string">&#x27;0&#x27;</span>)).GetComponent&lt;Button&gt;());</span><br><span class="line">        <span class="comment">// 避免闭包陷阱</span></span><br><span class="line">        <span class="built_in">int</span> j = i;</span><br><span class="line">        blueprintButtons[j].onClick.AddListener(() =&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            ActiveBlueprint(j);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="缘由"><a href="#缘由" class="headerlink" title="缘由"></a>缘由</h3><p>​    因为**() = &gt; v** 返回<strong>变量 v 的当前值”<strong>，而不是创建该委托时”v“ 的返回值 。</strong>闭包”变量“，而不是闭包”值“。</strong></p><p>​    所以在”for“循环中的添加的匿名函数，只是<strong>返回了变量i</strong> 而不是i的值。所以<strong>知道f() 被真正执行时，i已经是values.Count 值</strong>啦，所以会抛出”超出索引范围“。</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> values = <span class="keyword">new</span> List&lt;<span class="built_in">int</span>&gt; &#123; <span class="number">100</span>, <span class="number">110</span>, <span class="number">120</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> funcs = <span class="keyword">new</span> List&lt;Func&lt;<span class="built_in">int</span>&gt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">foreach</span> (<span class="keyword">var</span> v <span class="keyword">in</span> values)</span><br><span class="line">    funcs.Add(() =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//Console.WriteLine(v);</span></span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">foreach</span> (<span class="keyword">var</span> f <span class="keyword">in</span> funcs)</span><br><span class="line">    Console.WriteLine(f());</span><br><span class="line"></span><br><span class="line">Console.WriteLine(<span class="string">&quot;&#123;0&#125;&#123;0&#125;&quot;</span>, Environment.NewLine);</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span>/</span></span><br><span class="line">funcs.Clear();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; values.Count; i++)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//var v2 = values[i];</span></span><br><span class="line"></span><br><span class="line">     funcs.Add(() =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">       <span class="keyword">var</span> v2 = values[i]; <span class="comment">//will throw exception </span></span><br><span class="line"></span><br><span class="line">          <span class="keyword">return</span> v2;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">foreach</span> (<span class="keyword">var</span> f <span class="keyword">in</span> funcs)</span><br><span class="line">    Console.WriteLine(f());</span><br></pre></td></tr></table></figure><p>​    那为啥foreach 没事呢？那就让我们接着看下闭包的来头。</p><p>​    闭包在C#2.0 的时候引入了闭包语法，选择将循环变量放在循环体外面，for 和foreach 在这方面处理都是一致的。但随着人们在使用过程中的种种不适，微软做出了”一点“让步，在C#5 中对”foreach“做了调整，但对”for“没有做改动。具体改动如下说：</p><blockquote><p>​    在C#5中我们做了巨大的调整，“foreach”的遍历中的定义的临时循环变量会被逻辑上限制在循环内，“foreach”的每次循环都会是循环变量的一个拷贝，这样闭包就看起来关闭了（没有了）。但“for”循环没有做修改。</p></blockquote><p>​    但尽量不用foreach，因为foreach产生GC</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>​    闭包是指：在函数外部，可以读取函数中的成员，及我们所说的局部变量。可以简单的理解为“定义在函数内的成员或者函数”。在本质上说，闭包是指将函数内部和函数外部连接起来的桥梁。</p><p>​    具体操作：当使用闭包时，这次修改的数据会存储在内存中，当下一次使用这些成员的时候，又重新将新的数据存储在内存中。</p><p>​    缺点：比较消耗内存吗，以及容易出现闭包问题。</p>]]></content>
      
      
      
        <tags>
            
            <tag> C# </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【C#】 随想笔记</title>
      <link href="/2023/03/07/Csharp%E7%AC%94%E8%AE%B0/"/>
      <url>/2023/03/07/Csharp%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>C#几乎遗忘，复习+学习一些知识</p><h1 id="属性get和set访问器（Accessor）"><a href="#属性get和set访问器（Accessor）" class="headerlink" title="属性get和set访问器（Accessor）"></a>属性get和set访问器（Accessor）</h1><p>​    在面向对象编程（OOP）中，是不允许外界直接对类的私有成员变量直接访问的。C#中就要用set和get方法来访问私有成员变量，它们相当于外界访问对象的一个通道，一个“接口”，又称<strong>成员属性的访问器</strong>。</p><p>​    属性（Property）的<strong>访问器（Accessor）</strong>包含有助于获取（读取或计算）或设置（写入）属性的可执行语句。访问器（Accessor）声明可包含一个 get 访问器、一个 set 访问器，或者同时包含二者。</p><p><a href="https://blog.csdn.net/weixin_44023930/article/details/123447507">https://blog.csdn.net/weixin_44023930/article/details/123447507</a></p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Class Person&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">string</span> name；</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">byte</span> age;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="keyword">return</span> name;&#125;      <span class="comment">//这里是给私有属性name赋值</span></span><br><span class="line">        <span class="keyword">set</span>&#123; name = <span class="keyword">value</span>; &#125;     <span class="comment">//这里取出私有属性name的值</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">byte</span> Age</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="keyword">return</span> age; &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123; age = <span class="keyword">value</span>; &#125;<span class="comment">//还可以加入条件判断，更方便</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    当我们使用属性来访问私有成员变量时就会调用里面的get方法，当我们要修改该变量时就会调用set方法，当然在定义的时候可以只定义一个get方法或只定义一个set方法。如果只定义get方法，那么这个相应变量就是“只读”的；如果只定义set方法，那么相应变量就是“只写”的。</p><p>　属性在调用者看来就像一个普通的变量，但作为类的设计者，你可以利用属性来隐藏你类中的一些字段，使外界只能通过属性来访问你的字段，你可以通过属性来限制外界对你的字段的存取，就利用get、set。如果想让用户随意存取你的字段，那么就实现get、set；如果只想让用户读取字段，就只实现get；若只想让用户写字段就只实现set。同时还可以在set和get中对用户传递的值进行一些验证工作，以确保你的字段将含有正确的值。</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 写法一</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title">Test</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="built_in">int</span> age;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">int</span> Age</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">get</span> &#123; <span class="keyword">return</span> age; &#125;</span><br><span class="line">            <span class="keyword">set</span> &#123; age = <span class="keyword">value</span>; &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 写法二</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title">Test</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="built_in">int</span> age;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">int</span> Age</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">get</span> =&gt; age;</span><br><span class="line">            <span class="keyword">set</span> =&gt; age = <span class="keyword">value</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//简化写法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">Test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Age</span><br><span class="line">    &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//或者直接省略</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//因此在赋值时，应该直接用首字母大写的访问器，否则赋值不进去。</span></span><br></pre></td></tr></table></figure><h1 id="索引器（Indexer）"><a href="#索引器（Indexer）" class="headerlink" title="索引器（Indexer）"></a>索引器（Indexer）</h1><p>当您为类定义一个索引器时，该类的行为就会像一个 <strong>虚拟数组（virtual array）</strong> 一样。您可以使用数组访问运算符 <strong>[ ]</strong> 来访问该类的的成员，即一个对象可以像数组一样使用下标的方式来访问。</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Class Person&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">string</span> name;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> Person[] friends;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 索引器的写法</span></span><br><span class="line">    <span class="keyword">public</span> Person <span class="keyword">this</span>[<span class="built_in">int</span> index]&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">set</span>&#123;</span><br><span class="line">            friends[index] = <span class="keyword">value</span>;    </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">get</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> friends[index];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Class Programe&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">// 索引器的使用</span></span><br><span class="line">        Person p = <span class="keyword">new</span> Person();</span><br><span class="line">        p[<span class="number">0</span>] = <span class="keyword">new</span> Person();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样的，索引器里面也能写逻辑。同样的，索引器也能重载。</p><p><a href="https://blog.csdn.net/weixin_40583225/article/details/125324568">https://blog.csdn.net/weixin_40583225/article/details/125324568</a></p><p>没看懂……</p><blockquote></blockquote><h1 id="关于static和const"><a href="#关于static和const" class="headerlink" title="关于static和const"></a>关于static和const</h1><p><a href="https://zhuanlan.zhihu.com/p/491643290">static &amp; const</a></p><p>一篇应该够了</p><h1 id="as"><a href="#as" class="headerlink" title="as"></a>as</h1><p>as是将一个对象转化为指定对象，成功返回执行类型对象，失败返回null。</p><p>基本语法：类对象 as 类名 该语句块会有一个对象返回值；如下</p><h1 id="sealed密封类"><a href="#sealed密封类" class="headerlink" title="sealed密封类"></a>sealed密封类</h1><p>密封类是使用sealed密封关键字修饰的类，其可以让类无法再被继承</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Father</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这时候这个Son这个类是无法被其他类继承的</span></span><br><span class="line"><span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">Son</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​     在面向对象程序的设计中，密封类的主要作用就是不允许底层子类被继承，可以保证程序的规范性、安全性，以便制作复杂系统和框架的时候更方便；</p><h1 id="浅拷贝和深拷贝"><a href="#浅拷贝和深拷贝" class="headerlink" title="浅拷贝和深拷贝"></a>浅拷贝和深拷贝</h1><p>​    对于所有面向对象的语言，复制永远是一个容易引发讨论的题目，C#中也不例外。</p><p>​    在System.Object类中，有一个受保护的方法object.MemberwiseClone(),这个方法实现了对象的复制。事实上，它所实现的就是我们所称的浅拷贝。</p><h3 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a><strong>深拷贝</strong></h3><p>​    指的是<strong>拷贝一个对象时，不仅仅把对象的引用进行复制，还把该对象引用的值也一起拷贝</strong>。这样进行<strong>深拷贝后的拷贝对象就和源对象互相独立，其中任何一个对象的改动都不会对另外一个对象造成影响</strong>。比如一个黄狗叫大黄，使用克隆术克隆另外一个黄狗叫小黄，这样大黄和小黄就相对独立了，他们不互相影响。在.NET中int,double以及结构体和枚举等。</p><p>​    相对于完全复制了过去，类似文件系统里面的硬链接。</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> a=<span class="number">12</span>;</span><br><span class="line"><span class="built_in">int</span> c=a;<span class="comment">//进行了深拷贝</span></span><br><span class="line">c=<span class="number">232</span> <span class="comment">//不影响</span></span><br></pre></td></tr></table></figure><h3 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a><strong>浅拷贝</strong></h3><p>​    指的是<strong>拷贝一个对象时，仅仅拷贝对象的引用进行拷贝，但是拷贝对象和源对象还是引用同一份实体</strong>。此时，<strong>其中一个对象的改变都会影响到另一个对象</strong>。就像一个人改名了一样，他还是这个人，只不过名字变了而已。相当于文件系统里面的软链接（来一个快捷方式的意思，其实还是同一个）。</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">YDog</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            YDog sourceP = <span class="keyword">new</span> YDog() &#123; Name = <span class="string">&quot;大黄&quot;</span> &#125;;</span><br><span class="line">            YDog copyP = sourceP; <span class="comment">// 浅拷贝</span></span><br><span class="line">            copyP.Name = <span class="string">&quot;小黄&quot;</span>; <span class="comment">// 拷贝对象改变Name值</span></span><br><span class="line">            <span class="comment">// 结果都是&quot;小黄&quot;,因为实现的是浅拷贝，一个对象的改变都会影响到另一个对象</span></span><br><span class="line">            Console.WriteLine(<span class="string">&quot;YDog.Name: [SourceP: &#123;0&#125;] [CopyP:&#123;1&#125;]&quot;</span>, sourceP.Name, copyP.Name);</span><br><span class="line">            Console.Read();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>​    所谓的浅拷贝，是指拷贝一个对象的时候，拷贝原始对象中所有的非静态值类型成员和所有的引用类型成员的引用。换言之，新的对象和原始对象将共享所有引用类型成员的实际对象。</p><p>​    而相对的，深拷贝是指不仅复制所有的非静态值类型成员，而且也复制所有引用类型成员的实际对象。深拷贝和浅拷贝的概念是递归的，也就是说当引用类型成员中包含另外一个引用类型成员时，拷贝的时候将对其内部成员实行同样的复制策略。</p><h1 id="协变逆变"><a href="#协变逆变" class="headerlink" title="协变逆变"></a><strong>协变逆变</strong></h1><p><strong>协变和逆变是用来修饰泛型的</strong></p><blockquote><p>协变：out</p><p>逆变：in</p><p><strong>用于在泛型中修饰泛型字母的，只有泛型接口和泛型委托能使用。</strong></p></blockquote><h3 id="协变："><a href="#协变：" class="headerlink" title="协变："></a>协变：</h3><p>​    简单的总结：协变就是和谐的变化，自然的变化。因为里氏替换原则父类可以装子类，所以子类变父类比如string变object是合理的和谐的。</p><h3 id="逆变："><a href="#逆变：" class="headerlink" title="逆变："></a>逆变：</h3><p>​    逆常规的变化，不正常的变化。因为里氏替换原则父类可以装子类，但是子类不能装父类的，所以父类变子类比如object 变成 string 感受是不和谐的。</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.返回值和参数</span></span><br><span class="line"><span class="comment">// 用out修饰的泛型只能作为返回值</span></span><br><span class="line"><span class="function"><span class="built_in">delegate</span> T <span class="title">TestOut</span>&lt;<span class="keyword">out</span> <span class="title">T</span>&gt;(<span class="params"></span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用in修饰的泛型只能作为参数</span></span><br><span class="line"><span class="function"><span class="built_in">delegate</span> T <span class="title">TestIn</span>&lt;<span class="keyword">in</span> <span class="title">T</span>&gt;(<span class="params">T t</span>)</span>;</span><br><span class="line"><span class="comment">// ***注意：协变out和逆变是只能在泛型接口和泛型委托中使用的</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  2.结合里氏替换原则理解</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">Father</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Son</span> : <span class="title">Father</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">// 协变</span></span><br><span class="line">        TestOut&lt;Son&gt; os = ()=&gt;&#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">new</span> Son();  </span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// ***注意：如果我们把TestOut类中的out修饰符去掉，会报错误的，说明当我们加上了out之后，编译器会帮我们判断，这里是否符合里氏替换原则，符合就进行里氏替换原则进行了转换。</span></span><br><span class="line">        TestOut&lt;Father&gt; of = os;<span class="comment">// 这里我们相当于是用一个父类TestOut&lt;Father&gt;装载了一个子类TestOut&lt;Son&gt;，符合里氏替换原则的，是协变。</span></span><br><span class="line">        <span class="comment">// 这一行代码就证实了我们的os确实是转换为了Father，发生了里氏替换原则</span></span><br><span class="line">        Father f = of();<span class="comment">// 实际上返回的是os里面装的函数，返回的是Son</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 逆变</span></span><br><span class="line">        TestIn&lt;Father&gt; iF = (<span class="keyword">value</span>)=&gt;&#123;</span><br><span class="line">            </span><br><span class="line">        &#125;;</span><br><span class="line">        TestIn&lt;Son&gt; iS = IF;<span class="comment">// 这里我们相当于是用一个子类TestOut&lt;Son&gt;装载了一个父类TestOut&lt;父类&gt;，是不符合里氏替换原则的，是逆变。</span></span><br><span class="line">        <span class="comment">// 我们TestIn&lt;Son&gt;指定了泛型类型是一个Son类型，所以这里我们必须传入的是一个new Son()，如果我们传入的是一个Father()是会报错误的。</span></span><br><span class="line">        iS(<span class="keyword">new</span> Son());<span class="comment">//实际上调用的是iF,而iF里面是一个TestIn&lt;Father&gt;，是个Father类型的，也就是说我们因该是要传入一个Father类型的。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="迭代器-iterator"><a href="#迭代器-iterator" class="headerlink" title="迭代器 iterator"></a>迭代器 iterator</h1><p>​    <strong>迭代器（iterator）有时候又被称为光标（cursor）</strong>，是程序设计的软件设计模式，迭代器模式提供了一个方法顺序访问一个聚合对象中的各个元素，而又不暴露其内部的标识。在表现效果上看，是可以在容器对象（例如：链表或者数组）上遍历访问的接口，设计人员无需关心容器对象的内存分配的实现细节。</p><p>​    <strong>注意</strong>：只要是可以用foreach遍历的类(数据结构)，都是实现了迭代器的。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 关键接口：IEnumerator,IEnumerable;</span></span><br><span class="line"><span class="comment">// 命名空间：using System.Collections;</span></span><br><span class="line"><span class="comment">// 可以通过同时继承IEnumerable和IEnumerator实现其中的方法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 首先写个测试类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">CustomList</span> : <span class="title">IEnumerable</span>, <span class="title">IEnumerator</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span>[] list;</span><br><span class="line">    <span class="comment">// 这里是指我们的光标位置，默认为-1(可以简单的理解为我们数组的下标)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> position = <span class="number">-1</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CustomList</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        list = <span class="keyword">new</span> <span class="built_in">int</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 实现IEnumerable接口的成员</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IEnumerator <span class="title">GetEnumerator</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        Reset();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 实现IEnumerator接口的成员</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">object</span> Current&#123;</span><br><span class="line">        <span class="keyword">get</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> list[position];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">MoveNext</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        ++position;</span><br><span class="line">        <span class="comment">// 是否溢出，溢出就不合法</span></span><br><span class="line">        <span class="keyword">return</span> position &lt; lits.Length;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// reset是重置光标位置，一般写在获取IEnumerator对象这个函数中，用于第一次重置光标位置，这个函数十分重要!!!</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Reset</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        position = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        CustomList list = <span class="keyword">new</span> CustomList();</span><br><span class="line">        <span class="comment">// foreach本质</span></span><br><span class="line">        <span class="comment">// 1.先获取in后面这个对象的IEnumerator,然后会调用对象其中的GetEnumerator方法来获取。</span></span><br><span class="line">        <span class="comment">// 2.执行得到这个IEnumerator对象中的MoveNext方法</span></span><br><span class="line">        <span class="comment">// 3.只要MoveNext方法的返回值为true时候，就会去得到Current,然后复制给item。</span></span><br><span class="line">        <span class="comment">// 注意：我们可以不用一定要继承IEnumerable这个接口，只要我们的类中实现了public IEnumerator GetEnumerator()；也是可以使用foreach语句的。</span></span><br><span class="line">        <span class="keyword">foreach</span>(<span class="built_in">int</span> item <span class="keyword">in</span> list)</span><br><span class="line">            Console.WriteLine(item);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="用yield-return语法糖实现迭代器"><a href="#用yield-return语法糖实现迭代器" class="headerlink" title="用yield return语法糖实现迭代器"></a>用yield return语法糖实现迭代器</h3><p>yield return 是C#提供给我们的语法糖，所谓语法糖，也称为糖衣语法。</p><p>主要作用就是将复杂逻辑简单化，可以增加程序的可读性，从而减少程序代码出错的机会。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 关键接口：IEnumerable</span></span><br><span class="line"><span class="comment">// 命名空间：using System.Collections;</span></span><br><span class="line"><span class="comment">// 让想要通过foreach遍历的自定义类实现接口中的方法GetEnumerator即可。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">CustomList2</span> : <span class="title">IEnumerable</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span>[] list;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CustomList2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        list = <span class="keyword">new</span> <span class="built_in">int</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> IEnumerator <span class="title">GetEnumerator</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; list,Length; i++)&#123;</span><br><span class="line">            <span class="comment">// yield关键字,配合迭代器使用</span></span><br><span class="line">            <span class="comment">// yield return其实就是实现IEnumerator接口中的成员一种简单写法，我们可以不必再去继承IEnumertor并且实现Current(),MoveNext(),Reset()这三个方法还有object属性。当编译器执行到这一句的时候，会默认的帮我实现以上的成员的，让我们自己省了自己去书写。</span></span><br><span class="line">            <span class="keyword">yield</span> <span class="keyword">return</span> list[i];</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 还有另一种复杂的方法</span></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            yield return list[0];</span></span><br><span class="line"><span class="comment">            yield return list[1];</span></span><br><span class="line"><span class="comment">            yield return list[2];</span></span><br><span class="line"><span class="comment">            yield return list[3];</span></span><br><span class="line"><span class="comment">            yield return list[4];</span></span><br><span class="line"><span class="comment">            yield return list[5];</span></span><br><span class="line"><span class="comment">            yield return list[6];</span></span><br><span class="line"><span class="comment">            yield return list[7];</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        CustomList list2 = <span class="keyword">new</span> CustomList2();</span><br><span class="line">        <span class="keyword">foreach</span>(<span class="built_in">int</span> item <span class="keyword">in</span> list2)&#123;</span><br><span class="line">            Console.WriteLine(item);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="用yield-return语法糖为泛型类实现迭代器"><a href="#用yield-return语法糖为泛型类实现迭代器" class="headerlink" title="用yield return语法糖为泛型类实现迭代器"></a>用yield return语法糖为泛型类实现迭代器</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">CustomList</span>&lt;<span class="title">T</span>&gt; : <span class="title">IEnumerable</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T[] array;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CustomList</span>(<span class="params"><span class="keyword">params</span> T[] array</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.array = array;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> IEnumerator <span class="title">GetEnumerator</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; array.Length; i++)&#123;</span><br><span class="line">            <span class="keyword">yield</span> <span class="keyword">return</span> array[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span>&#123;</span><br><span class="line">    <span class="function">staic <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        CustomList&lt;<span class="built_in">string</span>&gt; list = <span class="keyword">new</span> CustomList&lt;<span class="built_in">string</span>&gt;(<span class="string">&quot;123&quot;</span>, <span class="string">&quot;123123&quot;</span>, <span class="string">&quot;123123123&quot;</span>);</span><br><span class="line">        <span class="keyword">foreach</span>(<span class="built_in">string</span> item <span class="keyword">in</span> list)&#123;</span><br><span class="line">            Console.WriteLine(item);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="var隐式类型"><a href="#var隐式类型" class="headerlink" title="var隐式类型"></a>var隐式类型</h1><p>​    var是一种特殊的变量类型，它可以用来表示任意类型的变量。</p><blockquote><p>1.var不能作为类的成员，只能用于临时变量申明时，也就是一般写在函数语句块中。</p><p>2.var必须初始化。</p></blockquote><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">var</span> s = <span class="string">&quot;123&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> array = <span class="keyword">new</span> intp[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> list = <span class="keyword">new</span> List&lt;<span class="built_in">int</span>&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 温馨提示：一般在协同开发中很少使用var这类隐私类型，因为当别人在阅读自己写的代码的时候，如果遇到了var，我们在没有阅读到后面的初始化值的时候，我们是不知道这个变量的类型的。如果代码中大量的使用了var是很影响阅读效率的。</span></span><br></pre></td></tr></table></figure><h1 id="反射-Reflection"><a href="#反射-Reflection" class="headerlink" title="反射 Reflection"></a>反射 Reflection</h1><p>​    反射指<strong>程序运行时，可以动态获取类型信息，动态创建对象，动态访问成员的过程</strong>，也可以说是<strong>动态访问、检测和修改它本身状态或行为的一种行为</strong>。</p><p>​    <strong>又或者说： 一个正在运行的程序查看本身或者其他程序的元数据的行为</strong>就叫反射。</p><blockquote><p>​    元数据：编译后的最基本数据单元，就是一堆表，反射就是解析这些元数据。</p></blockquote><p>​    简单理解：在程序运行时候，通过反射可以得到其他程序集或者自己程序集代码的各种信息，例如：类、函数、变量、对象等等，实例化它们，执行它们，操作它们。</p><p>​    <strong>关键类：Type、Assembly、Activator。</strong>主要使用类库System.Reflection</p><p>​    为什么学习反射？Unity引擎的基本工作机制就是建立在反射的基础上的，学习反射是为了之后学习Unity引擎的基本工作原理做铺垫。</p><p>​    反射要点：如何获取类型，根据类型来动态创建对象，反射获取方法以及动态调用方法，动态创建委托</p><h3 id="用途："><a href="#用途：" class="headerlink" title="用途："></a>用途：</h3><ul><li>它允许在运行时查看特性（attribute）信息。</li><li>它允许审查集合中的各种类型，以及实例化这些类型。</li><li>它允许延迟绑定的方法和属性（property）。</li><li>它允许在运行时创建新类型，然后使用这些类型执行一些任务。</li></ul><h3 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h3><ul><li>1、反射提高了程序的灵活性和扩展性。</li><li>2、降低耦合性，提高自适应能力。</li><li>3、它允许程序创建和控制任何类的对象，无需提前硬编码目标类。</li></ul><h3 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h3><ul><li>1、性能问题：使用反射基本上是一种解释操作，用于字段和方法接入时要远慢于直接代码。因此反射机制主要应用在对灵活性和拓展性要求很高的系统框架上，普通程序不建议使用。</li><li>2、使用反射会模糊程序内部逻辑；程序员希望在源代码中看到程序的逻辑，反射却绕过了源代码的技术，因而会带来维护的问题，反射代码比相应的直接代码更复杂。</li></ul><h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><h4 id="一、动态获取类型信息"><a href="#一、动态获取类型信息" class="headerlink" title="一、动态获取类型信息"></a>一、动态获取类型信息</h4><p>1.System.Reflection.Assembly.Load(“XXXX.dll”) 动态加载程序集</p><p>2.System.Type.GetType(“XXXX类名”); //动态获取某程序集中某类信息</p><p>3.obj.GetType(); //已知对象获取类信息 ——或者——typeof(类型) //已知类类型</p><h4 id="二、动态创建对象实例（上一步操作后获得类对象）"><a href="#二、动态创建对象实例（上一步操作后获得类对象）" class="headerlink" title="二、动态创建对象实例（上一步操作后获得类对象）"></a>二、动态创建对象实例（上一步操作后获得类对象）</h4><p>System.Activator.CreateInstance(Type type);</p><h4 id="三、动态访问成员调用方法（上一步操作后已获取实例对象）"><a href="#三、动态访问成员调用方法（上一步操作后已获取实例对象）" class="headerlink" title="三、动态访问成员调用方法（上一步操作后已获取实例对象）"></a>三、动态访问成员调用方法（上一步操作后已获取实例对象）</h4><p>System.Reflection.MethodInfo method = type.GetMethod(“方法名”);//获得方法</p><p>System.Reflection.MethodInfo.Invoke(object , new object[]{参数}) //调用的类实例和实例参数</p><h1 id="特性-Attribute"><a href="#特性-Attribute" class="headerlink" title="特性 Attribute"></a>特性 Attribute</h1><p>​    特性是一种允许我们向程序的程序集添加元数据的语言结构，它是用于保存程序结构信息的某种特殊类型的类。特性提供功能强大的方法以将声明信息与C#代码（类型、方法、属性等）相关联。特性与程序实体关联后，即可在运行时使用反射查询特性信息。特性的目的是告诉编译器把程序结构的某组元数据嵌入程序集中，它可以放置在几乎所有的声明中（类、变量、函数等等申明）。</p><p>​    简单理解：特性本质是一个类，我们可以利用特性类为元数据添加额外信息，比如一个类、成员变量、成员方法等等为他们添加更多的额外信息，之后可以通过反射来获取得到这些额外信息。<img src="/2023/03/07/Csharp%E7%AC%94%E8%AE%B0/image-20230307210954813.png" alt style="zoom: 67%;"></p><p>​    如上即可将speed的值限制在-100到100之间，在unity的Inspector中显示为一个滑动条。</p><img src="/2023/03/07/Csharp%E7%AC%94%E8%AE%B0/image-20230307211649187.png" alt="image-20230307211649187" style="zoom:67%;"><p>​    又如图即可在仅改变代码不运行的情况下看到效果了。</p><p>​    当然，特性还有很多，自行查阅咯。</p>]]></content>
      
      
      
        <tags>
            
            <tag> C# </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【设计模式】SOLID原则</title>
      <link href="/2023/03/07/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8BSOLID%E5%8E%9F%E5%88%99/"/>
      <url>/2023/03/07/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8BSOLID%E5%8E%9F%E5%88%99/</url>
      
        <content type="html"><![CDATA[<h1 id="SOLID-原则"><a href="#SOLID-原则" class="headerlink" title="SOLID 原则"></a><strong>SOLID</strong> <strong>原则</strong></h1><p>​    SOLID 是让软件设计更易于理解、更加灵活和更易于维护的五个原则的简称。</p><blockquote><p>​    与生活中所有事情一样，盲目遵守这些原则可能会弊大于利。在程序架构中应用这些原则可能会使其变得过于复杂。我对于是否真的有能够同时应用所有这五条原则的成功软件产品表示怀疑。有原则是件好事，但是也要时刻从实用的角度来考量，不要把这里的每句话当作放之四海皆准的教条。</p></blockquote><h2 id="单一职责原则-Single-Responsibility-Principle"><a href="#单一职责原则-Single-Responsibility-Principle" class="headerlink" title="单一职责原则 Single Responsibility Principle"></a>单一职责原则 <strong>Single Responsibility Principle</strong></h2><blockquote><p>修改一个类的原因只能有一个。    </p></blockquote><p>​    尽量让每个类只负责软件中的一个功能，并将该功能完全封装在该类中。</p><p>​    这条原则的主要目的是减少复杂度。你不需要费尽心机地去构思如何仅用 200 行代码来实现复杂设计，实际上完全可以使用十几个清晰的方法。</p><p>​    如果类负责的东西太多，那么当其中任何一件事发生改变时，你都必须对类进行修改。而在进行修改时，你就有可能改动类中自己并不希望改动的部分。</p><img src="/2023/03/07/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8BSOLID%E5%8E%9F%E5%88%99/image-20230307124758770.png" alt="image-20230307124758770" style="zoom:80%;"><h2 id="开闭原则-Open-closed-Principle"><a href="#开闭原则-Open-closed-Principle" class="headerlink" title="开闭原则 Open/closed Principle"></a>开闭原则 <strong>Open/closed Principle</strong></h2><blockquote><p>对于扩展，类应该是“开放”的；对于修改，类则应是“封闭”的。</p></blockquote><p>​    本原则的主要理念是在实现新功能时能保持已有代码不变。</p><p>​    如果你可以对一个类进行扩展，可以创建它的子类并对其做任何事情（如新增方法或成员变量、重写基类行为等），那么它就是开放的。如果某个类已做好了充分的准备并可供其他类使用的话（即其接口已明确定义且以后不会修改），那么该类就是封闭（你可以称之为完整）的。</p><p>​    如果一个类已经完成开发、测试和审核工作，而且属于某个框架或者可被其他类的代码直接使用的话，对其代码进行修改就是有风险的。你可以创建一个子类并重写原始类的部分内容以完成不同的行为，而不是直接对原始类的代码进行修改。这样你既可以达成自己的目标，但同时又无需修改已有的原始类客户端。</p><p>​    这条原则并不能应用于所有对类进行的修改中。如果你发现类中存在缺陷，直接对其进行修复即可，不要为它创建子类。子类不应该对其父类的问题负责。</p><p><img src="/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8BSOLID%E5%8E%9F%E5%88%99/image-20230307125533596.png" alt="image-20230307125533596"><img src="/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8BSOLID%E5%8E%9F%E5%88%99/image-20230307125541888.png" alt="image-20230307125541888"></p><p>​    现在， 当需要实现一个新的运输方式时， 你可以通过扩展 运输方式 Shipping 接口来新建一个类， 无需修改任何订单类的代码。 当用户在 UI 中选择这种运输方式时，订单类客户端代码会将订单链接到新类的运输方式对象。</p><h2 id="里氏替换原则-Liskov-Substitution-Principle"><a href="#里氏替换原则-Liskov-Substitution-Principle" class="headerlink" title="里氏替换原则 Liskov Substitution Principle"></a>里氏替换原则 <strong>Liskov Substitution Principle</strong></h2><blockquote><p>当你扩展一个类时， 记住你应该要能在不修改客户端代码的情况下将子类的对象作为父类对象进行传递。</p></blockquote><p>​    这意味着子类必须保持与父类行为的兼容。在重写一个方法时，你要对基类行为进行扩展，而不是将其完全替换。</p><p>​    替换原则是用于预测子类是否与代码兼容，以及是否能与其超类对象协作的一组检查。这一概念在开发程序库和框架时非常重要，因为其中的类将会在他人的代码中使用——你是无法直接访问和修改这些代码的。</p><p>​    与有着多种解释方式的其他设计模式不同，替代原则包含一组对子类（特别是其方法）的形式要求。让我们来仔细看看这些要求：</p><ul><li><strong>子类方法的参数类型必须与其超类的参数类型相匹配或更加抽象。</strong></li><li><strong>子类方法的返回值类型必须与超类方法的返回值类型或是其子类别相匹配。</strong></li><li><strong>子类中的方法不应抛出基础方法预期之外的异常类型。</strong></li><li><strong>子类不应该加强其前置条件。</strong></li><li><strong>子类不能削弱其后置条件。</strong></li><li><strong>超类的不变量必须保留。</strong></li><li><strong>子类不能修改超类中私有成员变量的值。</strong></li></ul><img src="/2023/03/07/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8BSOLID%E5%8E%9F%E5%88%99/image-20230307131005660.png" class title="image-20230307131005660"><p>​    代码也将违反开闭原则，因为客户端代码将依赖于具体的文档类。如果你引入了新的文档子类，则需要修改客户端代码才能对其进行支持。</p><img src="/2023/03/07/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8BSOLID%E5%8E%9F%E5%88%99/image-20230307131025448.png" class title="image-20230307131025448"><p>​    没太懂~</p><h2 id="接口隔离原则-Interface-Segregation-Principle"><a href="#接口隔离原则-Interface-Segregation-Principle" class="headerlink" title="接口隔离原则 Interface Segregation Principle"></a>接口隔离原则 <strong>Interface Segregation Principle</strong></h2><blockquote><p>客户端不应被强迫依赖于其不使用的方法。</p></blockquote><p>​    尽量缩小接口的范围，使得客户端的类不必实现其不需要的行为。</p><p>​    根据接口隔离原则，你必须将“臃肿”的方法拆分为多个颗粒度更小的具体方法。客户端必须仅实现其实际需要的方法。否则，对于“臃肿”接口的修改可能会导致程序出错，即使客户端根本没有使用修改后的方法。</p><p>​    继承只允许类拥有一个超类，但是它并不限制类可同时实现的接口的数量。因此，你不需要将大量无关的类塞进单个接口。你可将其拆分为更精细的接口，如有需要可在单个类中实现所有接口，某些类也可只实现其中的一个接口。</p><h2 id="依赖倒置原则-Dependency-Inversion-Principle"><a href="#依赖倒置原则-Dependency-Inversion-Principle" class="headerlink" title="依赖倒置原则 Dependency Inversion Principle"></a>依赖倒置原则 <strong>Dependency Inversion Principle</strong></h2><blockquote><p>高层次的类不应该依赖于低层次的类。 两者都应该依赖于抽象接口。抽象接口不应依赖于具体实现。具体实现应该依赖于抽象接口。</p></blockquote><p>通常在设计软件时，你可以辨别出不同层次的类。</p><ul><li><strong>低层次的类</strong>实现基础操作（例如磁盘操作、传输网络数据和连接数据库等）。</li><li><strong>高层次类</strong>包含复杂业务逻辑以指导低层次类执行特定操作。</li></ul><p>​    有时人们会先设计低层次的类， 然后才会开发高层次的类。当你在新系统上开发原型产品时，这种情况很常见。由于低层次的东西还没有实现或不确定，你甚至无法确定高层次类能实现哪些功能。如果采用这种方式，业务逻辑类可能会更依赖于低层原语类。</p><p>​    <strong>依赖倒置原则建议改变这种依赖方式。</strong></p><p><img src="/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8BSOLID%E5%8E%9F%E5%88%99/image-20230307130258553.png" alt="image-20230307130258553"><img src="/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8BSOLID%E5%8E%9F%E5%88%99/image-20230307130305880.png" alt="image-20230307130305880"></p><p>相对于高层次写一个接口让别人去实现咯？</p>]]></content>
      
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Unity】存档系统 (PlayerPrefs Json)</title>
      <link href="/2023/03/07/Unity%E4%B9%8B%E5%AD%98%E6%A1%A3%E7%B3%BB%E7%BB%9F/"/>
      <url>/2023/03/07/Unity%E4%B9%8B%E5%AD%98%E6%A1%A3%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="Unity存档系统"><a href="#Unity存档系统" class="headerlink" title="Unity存档系统"></a><strong>Unity存档系统</strong></h1><p>​    本笔记参考以下内容：<a href="https://www.bilibili.com/video/BV1nQ4y1z7pZ">阿严-存档系统</a>      <a href="https://zhuanlan.zhihu.com/p/482843971">数据持久化-PlayerPrefs</a></p><h2 id="PlayerPrefs"><a href="#PlayerPrefs" class="headerlink" title="PlayerPrefs"></a><strong>PlayerPrefs</strong></h2><p>​    <strong>PlayerPrefs是Unity提供的可以用于存储/读取玩家数据的公共类。</strong></p><p><a href="https://docs.unity3d.com/ScriptReference/PlayerPrefs.html">Unity Documentation</a></p><h3 id="PlayerPrefs简单用法"><a href="#PlayerPrefs简单用法" class="headerlink" title="PlayerPrefs简单用法"></a><strong>PlayerPrefs简单用法</strong></h3><p>​    PlayerPrefs的数据存储类似键值对存储方式，一个键对应一个值。 PlayerPrefs只提供三种数据方法：int、float、string，其中其键的类型只能是String，值的类型可以是：int、float、string对应三种API，且这三种API都没有其他重载方法。</p><img src="/2023/03/07/Unity%E4%B9%8B%E5%AD%98%E6%A1%A3%E7%B3%BB%E7%BB%9F/image-20230307092323863.png" class title="image-20230307092323863"><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">PlayerPrefs.SetInt(<span class="string">&quot;Age&quot;</span>, <span class="number">1</span>);</span><br><span class="line">PlayerPrefs.SetString(<span class="string">&quot;Name&quot;</span>, <span class="string">&quot;asdasddddd&quot;</span>);</span><br><span class="line">PlayerPrefs.SetFloat(<span class="string">&quot;Float&quot;</span>, <span class="number">103.2f</span>);</span><br></pre></td></tr></table></figure><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">lesson1</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Start is called before the first frame update</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">region</span> PlayerPrefs是什么</span></span><br><span class="line">        <span class="comment">//是Unity提供的可以用于存储读取玩家数据的公共类</span></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">endregion</span></span></span><br><span class="line"> </span><br><span class="line">        <span class="meta">#<span class="meta-keyword">region</span> 存储相关</span></span><br><span class="line">        <span class="comment">//PlayerPrefs的数据存储 类似于键值对存储 一个键对应一个值</span></span><br><span class="line">        <span class="comment">//提供了存储3种数据的方法 int float string</span></span><br><span class="line">        <span class="comment">//键：string类型</span></span><br><span class="line">        <span class="comment">//值：int float string 对应3种API</span></span><br><span class="line"> </span><br><span class="line">        PlayerPrefs.SetInt(<span class="string">&quot;myAge&quot;</span>, <span class="number">18</span>);</span><br><span class="line">        PlayerPrefs.SetFloat(<span class="string">&quot;myHeight&quot;</span>, <span class="number">170.5f</span>);</span><br><span class="line">        PlayerPrefs.SetString(<span class="string">&quot;myName&quot;</span>, <span class="string">&quot;xx&quot;</span>);</span><br><span class="line">        <span class="comment">//直接调用Set相关方法 只会把数据存到内存里</span></span><br><span class="line">        <span class="comment">//当游戏结束时 Unity会自动把数据存到硬盘里</span></span><br><span class="line">        <span class="comment">//如果游戏不是正常结束的 而是崩溃 数据是不会存到硬盘中的</span></span><br><span class="line">        </span><br><span class="line">        PlayerPrefs.Save();</span><br><span class="line">        <span class="comment">//只要调用该方法 就会马上存储到硬盘中</span></span><br><span class="line"> </span><br><span class="line">        <span class="comment">//PlayerPrefs是有局限性的 它只能存三种类型的数据</span></span><br><span class="line">        <span class="comment">//如果你想要存储别的类型的数据 只能降低精度 或者上升精度来进行存储</span></span><br><span class="line">        <span class="built_in">bool</span> sex = <span class="literal">true</span>;</span><br><span class="line">        PlayerPrefs.SetInt(<span class="string">&quot;sex&quot;</span>, sex ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//如果不同类型用同一键名进行存储 会进行覆盖</span></span><br><span class="line">        <span class="comment">//PlayerPrefs.SetFloat(&quot;myAge&quot;, 20.2f);</span></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">endregion</span></span></span><br><span class="line"> </span><br><span class="line">        <span class="meta">#<span class="meta-keyword">region</span> 读取相关</span></span><br><span class="line">        <span class="comment">//注意：运行时 只要你Set了对应键值对</span></span><br><span class="line">        <span class="comment">//即使你没有马上存储Save在本地</span></span><br><span class="line">        <span class="comment">//也能够读取出信息</span></span><br><span class="line"> </span><br><span class="line">        <span class="comment">//int</span></span><br><span class="line">        <span class="built_in">int</span> age = PlayerPrefs.GetInt(<span class="string">&quot;myAge&quot;</span>);</span><br><span class="line">        print(age);</span><br><span class="line">        <span class="comment">//如果找不到myAge对应的值 就会返回函数的第二个参数 默认值</span></span><br><span class="line">        age = PlayerPrefs.GetInt(<span class="string">&quot;myAge&quot;</span>, <span class="number">100</span>);</span><br><span class="line">        print(age);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//float</span></span><br><span class="line">        <span class="built_in">float</span> height = PlayerPrefs.GetFloat(<span class="string">&quot;myHeight&quot;</span>);</span><br><span class="line">        print(height);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//string</span></span><br><span class="line">        <span class="built_in">string</span> name = PlayerPrefs.GetString(<span class="string">&quot;myName&quot;</span>);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//第二个参数 默认值 对于我们的作用</span></span><br><span class="line">        <span class="comment">//就是 在得到没有的数据的时候 就可以用它来进行基础数据的初始化</span></span><br><span class="line"> </span><br><span class="line">        <span class="comment">//判断数据是否存在</span></span><br><span class="line">        <span class="keyword">if</span> (PlayerPrefs.HasKey(<span class="string">&quot;myName&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            print(<span class="string">&quot;存在myName对应的键值对数据&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">endregion</span></span></span><br><span class="line"> </span><br><span class="line">        <span class="meta">#<span class="meta-keyword">region</span> 删除数据</span></span><br><span class="line">        <span class="comment">//删除指定键值对</span></span><br><span class="line">        PlayerPrefs.DeleteKey(<span class="string">&quot;myAge&quot;</span>);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//删除所有存储的信息</span></span><br><span class="line">        PlayerPrefs.DeleteAll();</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">endregion</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="comment">//https://blog.csdn.net/HAL2020/article/details/119883285 让我们一起飞翔</span></span><br></pre></td></tr></table></figure><p>​    上面的三句API就相当于把一个数据存储到了<strong>内存注册表</strong>中(注意，现在还是在内存上而不是在硬盘上)。使用Windows系统时，按下Win+R，输入regedit，找到对应Unity的目录即可搜索到。</p><blockquote><p><strong>Window</strong> PlayerPrefs存储在HKCU\SoftWare\ [公司名称]\ [产品名称]项下的注册表中 步骤：运行 regedit -&gt; HKEY_CURRENT_USER -&gt; SOFTWARE -&gt; Unity -&gt; UnityEditor -&gt; 公司名称 -&gt; 产品名称</p><p><strong>Android</strong> /data/data/包名/shared_prefs/pkg-name.xml</p><p><strong>IOS</strong> /Library/Preferences/ [应用ID].plist</p><img src="/2023/03/07/Unity%E4%B9%8B%E5%AD%98%E6%A1%A3%E7%B3%BB%E7%BB%9F/image-20230307100522105.png" class title="image-20230307100522105"></blockquote><p>​    如果我们想把内存的数据存储到硬盘中，只有两种方式，一种就是游戏自然结束，关闭后Unity会把数据存入硬盘中。另一种就是我们调用<strong>PlayerPrefs.Save()方法进行直接保存，只要调用这个方法就会马上存储到硬盘中</strong>。注意：如果不使用PlayerPrefs.Save()，如果游戏在运行中奔溃了那么数据是会丢失的。</p><h3 id="使用JsonUtility-ToJson-去存储更复杂的数据"><a href="#使用JsonUtility-ToJson-去存储更复杂的数据" class="headerlink" title="使用JsonUtility.ToJson()去存储更复杂的数据"></a>使用JsonUtility.ToJson()去存储更复杂的数据</h3><img src="/2023/03/07/Unity%E4%B9%8B%E5%AD%98%E6%A1%A3%E7%B3%BB%E7%BB%9F/image-20230307100631321.png" class title="image-20230307100631321"><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用JsonUtility.ToJson(Data); 可以使任何类型的值变成Json，如何就可以存储除了上述三种API以外的内容</span></span><br><span class="line"><span class="comment">//这里更推荐</span></span><br><span class="line"><span class="keyword">var</span> json = JsonUtility.ToJson(data,<span class="literal">true</span>);</span><br><span class="line"><span class="comment">//第二个参数为true则会生成更易读标准的Json格式！当然若不用true会更轻量快速。</span></span><br></pre></td></tr></table></figure><p>​    值得注意的是，如果我们传入的是单一类型，则会因为其不是可序列化的数据而转化出为空。我们可以直接在类中使用JsonUtility.ToJson(this); 即可将该类中所有变量转化为整体输出。</p><img src="/2023/03/07/Unity%E4%B9%8B%E5%AD%98%E6%A1%A3%E7%B3%BB%E7%BB%9F/image-20230307103243277.png" class title="image-20230307103243277"><img src="/2023/03/07/Unity%E4%B9%8B%E5%AD%98%E6%A1%A3%E7%B3%BB%E7%BB%9F/image-20230307103150116.png" class title="image-20230307103150116"><p>​    可以看到，ToJson()也只能转化公有的String和序列化之后的字段。<img src="/2023/03/07/Unity%E4%B9%8B%E5%AD%98%E6%A1%A3%E7%B3%BB%E7%BB%9F/image-20230307103341442.png" class title="image-20230307103341442"></p><p>​    其实能被序列化的字段，都会在inspector中显示出来。</p><h3 id="同样，还有FromJson"><a href="#同样，还有FromJson" class="headerlink" title="同样，还有FromJson();"></a>同样，还有FromJson();</h3><p><a href="https://docs.unity3d.com/ScriptReference/JsonUtility.ToJson.html">JsonUtility.ToJson - Unity Documentation - Scripting API</a></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h3><blockquote><p><strong>优点：</strong>快捷、简单、易懂、存储方便</p><p><strong>缺点：</strong>重复工作量繁多、自定义数据类需要自己去实现存储/读取的方式，而且代码的相似度极高。数据容易被修改，只要找到对应文件夹位置，就可以轻易的进行数据修改。</p></blockquote><h2 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h2><p>​    Json是一种很常见的数据存储格式，最大的特点就是它的键值对以及对象的格式。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一份正确格式的JSON案例</span></span><br><span class="line"><span class="comment">// 大括号表示一个对象</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 冒号代表键值对的对应关系</span></span><br><span class="line">    <span class="comment">// 逗号表示分割符类似C#分号“;”的作用</span></span><br><span class="line">    <span class="comment">// 注意：Json当中键一定要用双引号包裹</span></span><br><span class="line">    <span class="attr">&quot;age&quot;</span> : <span class="number">18</span>,</span><br><span class="line">    <span class="attr">&quot;sex&quot;</span> : <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">// 用于测试的浮点类型是支持浮点数的</span></span><br><span class="line">    <span class="attr">&quot;testF&quot;</span> : <span class="number">1.4</span>,</span><br><span class="line">    <span class="comment">// 中括号代表数组</span></span><br><span class="line">    <span class="attr">&quot;ids&quot;</span> : [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>],</span><br><span class="line">    <span class="attr">&quot;students&quot;</span> : [&#123;<span class="attr">&quot;name&quot;</span>:<span class="string">&quot;小红&quot;</span>, <span class="attr">&quot;age&quot;</span>:<span class="number">10</span>, <span class="attr">&quot;sex&quot;</span>:<span class="literal">false</span>&#125;,</span><br><span class="line">                 &#123;<span class="attr">&quot;name&quot;</span>:<span class="string">&quot;小红1&quot;</span>, <span class="attr">&quot;age&quot;</span>:<span class="number">7</span>, <span class="attr">&quot;sex&quot;</span>:<span class="literal">false</span>&#125;,</span><br><span class="line">                 &#123;<span class="attr">&quot;name&quot;</span>:<span class="string">&quot;小红2&quot;</span>, <span class="attr">&quot;age&quot;</span>:<span class="number">1</span>, <span class="attr">&quot;sex&quot;</span>:<span class="literal">false</span>&#125;,],</span><br><span class="line">    <span class="attr">&quot;home&quot;</span> : &#123;<span class="attr">&quot;address&quot;</span> : <span class="string">&quot;深圳&quot;</span>, <span class="attr">&quot;street&quot;</span> : <span class="string">&quot;111111&quot;</span>&#125;,</span><br><span class="line">    <span class="attr">&quot;isNull&quot;</span> : <span class="literal">null</span>,</span><br><span class="line">    <span class="comment">// 字典的话 键值会变成双引号，以后转换的时候需要注意！！</span></span><br><span class="line">    <span class="attr">&quot;dic&quot;</span> : &#123;<span class="attr">&quot;1&quot;</span>:<span class="string">&quot;123&quot;</span>, <span class="attr">&quot;2&quot;</span>:<span class="string">&quot;234&quot;</span>&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="JsonUtlity"><a href="#JsonUtlity" class="headerlink" title="JsonUtlity"></a>JsonUtlity</h3><p>​    JsonUtlity是Unity自带的用于解析Json的公共类，它可以将<strong>内存对象序列化为Json格式的字符串</strong>，该能将Json字符串反序列化为类对象。之前也已经使用过了。</p><h3 id="File-WriteAllText-path-data"><a href="#File-WriteAllText-path-data" class="headerlink" title="File.WriteAllText(path,data)"></a>File.WriteAllText(path,data)</h3><img src="/2023/03/07/Unity%E4%B9%8B%E5%AD%98%E6%A1%A3%E7%B3%BB%E7%BB%9F/image-20230307104734616.png" alt="image-20230307104734616" style="zoom:80%;"><p>该函数旨在将JSON数据存入到硬盘中，具体地址由于各个平台不同而回变化，图中使用Application.persistentDataPath，是Unity自带的一个跨平台存储地址。<a href="https://docs.unity3d.com/ScriptReference/Application-persistentDataPath.html">Application.persistentDataPath - Unity Documentation - Scripting API </a></p><p>同时也可以使用TryCatch捕获异常：<img src="/2023/03/07/Unity%E4%B9%8B%E5%AD%98%E6%A1%A3%E7%B3%BB%E7%BB%9F/image-20230307105131521.png" alt="image-20230307105131521" style="zoom:50%;"></p><h3 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h3><p>大体框架还是用的Up那一套，可以在下链接获得：<a href="https://github.com/AtCloudStudio/SaveSystemTutorial">Github地址</a></p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//SaveByJson.cs</span></span><br><span class="line"><span class="keyword">using</span> System.IO;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">SaveSystemTutorial</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SaveByJSON</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">SaveByJson</span>(<span class="params"><span class="built_in">string</span> fileName, <span class="built_in">object</span> data</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> json = JsonUtility.ToJson(data);</span><br><span class="line">            <span class="keyword">var</span> path = Path.Combine(Application.persistentDataPath, fileName);</span><br><span class="line"></span><br><span class="line">            File.WriteAllText(path, json);</span><br><span class="line">            Debug.Log(<span class="string">&quot;我已使用Json存档在&quot;</span> + path);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> T <span class="title">LoadFromJson</span>&lt;<span class="title">T</span>&gt;(<span class="params"><span class="built_in">string</span> fileName</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> path = Path.Combine(Application.persistentDataPath, fileName);</span><br><span class="line">            <span class="keyword">var</span> json = File.ReadAllText(path);  </span><br><span class="line">            <span class="keyword">var</span> data=JsonUtility.FromJson&lt;T&gt;(json);</span><br><span class="line">            Debug.Log(<span class="string">&quot;我已使用Json恢复存档在&quot;</span> + data);</span><br><span class="line">            <span class="keyword">return</span> data;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">DeleteJson</span>(<span class="params"><span class="built_in">string</span> fileName</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> path = Path.Combine(Application.persistentDataPath, fileName);</span><br><span class="line">            File.Delete(path);</span><br><span class="line">            Debug.Log(<span class="string">&quot;我已删除Json存档&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;<span class="comment">//PlayerData.cs</span></span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">SaveSystemTutorial</span></span><br><span class="line">&#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PlayerData</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">    &#123;</span><br><span class="line">        [<span class="meta">SerializeField</span>] <span class="built_in">string</span> playerName = <span class="string">&quot;Player Name&quot;</span>;</span><br><span class="line">        [<span class="meta">SerializeField</span>] <span class="built_in">int</span> level = <span class="number">0</span>;</span><br><span class="line">        [<span class="meta">SerializeField</span>] <span class="built_in">int</span> coin = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">const</span> <span class="built_in">string</span> FILE_NAME = <span class="string">&quot;JSON_SAVE.moximoxi&quot;</span>;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">string</span> Name =&gt; playerName;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">int</span> Level =&gt; level;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">int</span> Coin =&gt; coin;</span><br><span class="line">        <span class="keyword">public</span> Vector3 Position =&gt; transform.position;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">USERDATA</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="built_in">string</span> Name;</span><br><span class="line">            <span class="keyword">public</span> <span class="built_in">int</span> Level;</span><br><span class="line">            <span class="keyword">public</span> <span class="built_in">int</span> Coin;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="title">USERDATA</span>(<span class="params"><span class="built_in">string</span> n, <span class="built_in">int</span> l, <span class="built_in">int</span> c</span>)</span></span><br><span class="line">            &#123;</span><br><span class="line">                Name = n; Level = l; Coin = c;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Save</span>(<span class="params"></span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//SaveByPrefs();</span></span><br><span class="line">            SaveByJson();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Load</span>(<span class="params"></span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//LoadByPrefs();</span></span><br><span class="line">            LoadByJson();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">region</span> PlayerPrefs</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">SaveByPrefs</span>(<span class="params"></span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            PlayerPrefs.SetString(<span class="string">&quot;PlayerName&quot;</span>, playerName);</span><br><span class="line">            PlayerPrefs.SetInt(<span class="string">&quot;PlayerLever&quot;</span>, level);</span><br><span class="line">            PlayerPrefs.SetInt(<span class="string">&quot;PlayerCoin&quot;</span>, coin);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">LoadByPrefs</span>(<span class="params"></span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            playerName=PlayerPrefs.GetString(<span class="string">&quot;PlayerName&quot;</span>, playerName);</span><br><span class="line">            level=PlayerPrefs.GetInt(<span class="string">&quot;PlayerLever&quot;</span>, level);</span><br><span class="line">            coin=PlayerPrefs.GetInt(<span class="string">&quot;PlayerCoin&quot;</span>, coin);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">endregion</span></span></span><br><span class="line"></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">region</span> JSON</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">SaveByJson</span>(<span class="params"></span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            SaveByJSON.SaveByJson(FILE_NAME,SavingData());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">LoadByJson</span>(<span class="params"></span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> saveData = SaveByJSON.LoadFromJson&lt;USERDATA&gt;(FILE_NAME);</span><br><span class="line">            LoadData(saveData);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="built_in">object</span> <span class="title">SavingData</span>(<span class="params"></span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> USERDATA(playerName,level,coin);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">LoadData</span>(<span class="params">USERDATA data</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            playerName = data.Name; level = data.Level; coin = data.Coin;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">endregion</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>成果：<img src="/2023/03/07/Unity%E4%B9%8B%E5%AD%98%E6%A1%A3%E7%B3%BB%E7%BB%9F/image-20230307120333005.png" class title="image-20230307120333005"></p><p>随机输入一串数据，点击Save，显示已保存。</p><img src="/2023/03/07/Unity%E4%B9%8B%E5%AD%98%E6%A1%A3%E7%B3%BB%E7%BB%9F/image-20230307120453487.png" class title="image-20230307120453487"><img src="/2023/03/07/Unity%E4%B9%8B%E5%AD%98%E6%A1%A3%E7%B3%BB%E7%BB%9F/image-20230307120524902.png" class title="image-20230307120524902"><p>重新Load，也能实现读取，非常GOOD&lt;(￣︶￣)↗</p><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><img src="/2023/03/07/Unity%E4%B9%8B%E5%AD%98%E6%A1%A3%E7%B3%BB%E7%BB%9F/image-20230307110145181.png" class title="image-20230307110145181"><img src="/2023/03/07/Unity%E4%B9%8B%E5%AD%98%E6%A1%A3%E7%B3%BB%E7%BB%9F/image-20230307110332489.png" class title="image-20230307110332489"> <img src="/2023/03/07/Unity%E4%B9%8B%E5%AD%98%E6%A1%A3%E7%B3%BB%E7%BB%9F/image-20230307110424519.png" class title="image-20230307110424519">]]></content>
      
      
      
        <tags>
            
            <tag> Unity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【设计模式】对象池模式</title>
      <link href="/2023/03/06/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%AF%B9%E8%B1%A1%E6%B1%A0%E6%A8%A1%E5%BC%8F/"/>
      <url>/2023/03/06/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%AF%B9%E8%B1%A1%E6%B1%A0%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="Object-Pool-Pattern-对象池模式"><a href="#Object-Pool-Pattern-对象池模式" class="headerlink" title="Object Pool Pattern 对象池模式"></a>Object Pool Pattern 对象池模式</h1><p>​    使用固定的对象池重用对象，取代单独地分配和释放对象，以此来达到提升性能和优化内存使用的目的。（该模式不属于GOF23种模式范畴，但是在游戏开发中非常常见）</p><p>​    游戏中常常要创建大量的游戏对象，如果这些对象长期占用一些内存而没有触发<strong>垃圾回收机制（以下简称GC）</strong>或者过于频繁的触发GC就会导致游戏的帧数暴跌，在移动设备直接造成卡死的现象。引用对象池的概念，能让这些游戏对象在刚开始的时候就被初始实例化，而不会在游戏中频繁生成，也不用触发垃圾回收机制，对性能具有极大的提升。</p><h2 id="模式描述"><a href="#模式描述" class="headerlink" title="模式描述"></a>模式描述</h2><p>​    定义一个保持着可重用对象集合的对象池类。其中的每个对象支持对其“使用（in use）”状态的访问，以确定这一对象目前是否“存活（alive）”。在对象池初始化时，它预先创建整个对象集合（通常为一块连续堆区域），并将它们都置为“未使用（not in use）”状态。</p><p>​    当我们想要创建一个新对象时，就向对象池请求。它将搜索到一个可用的对象，将其初始化为“使用中（in use）”状态并返回给你。当该对象不再被使用时，它将被置回“未使用（not in use）”状态。使用该方法，对象便可以在无需进行内存或其他资源分配的情况下进行任意的创建和销毁。</p><h2 id="使用情形"><a href="#使用情形" class="headerlink" title="使用情形"></a>使用情形</h2><p>此模式被广泛地应用于游戏中的可见物体，如游戏实体对象、各种视觉特效。但是它也可在非可见的数据结构上使用，比如当前播放的声音。</p><p>满足以下情况可以使用对象池：</p><ul><li>需要频繁创建和销毁对象时。</li><li>对象大小一致时。</li><li>在堆上分配对象缓慢或者会导致内存碎片时。</li><li>每个对象都封装了很昂贵且又可以重用的资源，如数据库、网络的连接。</li></ul><h2 id="Unity中"><a href="#Unity中" class="headerlink" title="Unity中"></a>Unity中</h2><p>​    值得一提的是，在Unity2021.2以后的版本中已自带基于Stack实现的对象池 UnityEngine.Pool。</p><p>​    详情请看以下视频：<a href="https://www.bilibili.com/video/BV14T4y197bW">Unity对象池</a></p><p>​    <a href="https://docs.unity3d.com/2021.1/Documentation/ScriptReference/Pool.ObjectPool_1.html">官方DOC</a></p><p>​    其实最主要是其中的Initialize()函数，可以参考以下UP主的泛型代码：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> UnityEngine.Pool;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">BasePool</span>&lt;<span class="title">T</span>&gt; : <span class="title">MonoBehaviour</span> <span class="keyword">where</span> <span class="title">T</span> : <span class="title">Component</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">SerializeField</span>] <span class="keyword">protected</span> T prefab;</span><br><span class="line">    [<span class="meta">SerializeField</span>] <span class="built_in">int</span> defaultSize = <span class="number">100</span>;</span><br><span class="line">    [<span class="meta">SerializeField</span>] <span class="built_in">int</span> maxSize = <span class="number">500</span>;</span><br><span class="line">    </span><br><span class="line">    ObjectPool&lt;T&gt; pool;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> ActiveCount =&gt; pool.CountActive;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> InactiveCount =&gt; pool.CountInactive;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> TotalCount =&gt; pool.CountAll;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">Initialize</span>(<span class="params"><span class="built_in">bool</span> collectionCheck = <span class="literal">true</span></span>)</span> =&gt; </span><br><span class="line">        pool = <span class="keyword">new</span> ObjectPool&lt;T&gt;(</span><br><span class="line">        OnCreatePoolItem, <span class="comment">//创建对象池对象的函数 </span></span><br><span class="line">        OnGetPoolItem, </span><br><span class="line">        OnReleasePoolItem, </span><br><span class="line">        OnDestroyPoolItem, </span><br><span class="line">        collectionCheck, <span class="comment">//默认为true，编辑器中的调试功能</span></span><br><span class="line">        defaultSize,<span class="comment">//初始池大小（这里没有固定大小，建议调试测试）</span></span><br><span class="line">        maxSize);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">virtual</span> T <span class="title">OnCreatePoolItem</span>(<span class="params"></span>)</span> =&gt; Instantiate(prefab, transform);</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">OnGetPoolItem</span>(<span class="params">T obj</span>)</span> =&gt; obj.gameObject.SetActive(<span class="literal">true</span>);</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">OnReleasePoolItem</span>(<span class="params">T obj</span>)</span> =&gt; obj.gameObject.SetActive(<span class="literal">false</span>);</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">OnDestroyPoolItem</span>(<span class="params">T obj</span>)</span> =&gt; Destroy(obj.gameObject);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">Get</span>(<span class="params"></span>)</span> =&gt; pool.Get();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Release</span>(<span class="params">T obj</span>)</span> =&gt; pool.Release(obj);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Clear</span>(<span class="params"></span>)</span> =&gt; pool.Clear();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://github.com/AtCloudStudio/UnityObjectPoolTutorial">对象池_github地址</a></p><h2 id="实际体验"><a href="#实际体验" class="headerlink" title="实际体验"></a>实际体验</h2><img src="/2023/03/06/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%AF%B9%E8%B1%A1%E6%B1%A0%E6%A8%A1%E5%BC%8F/image-20230306233733457.png" class title="image-20230306233733457"><p>在使用最简单的直接生成250个对象并在落地后删除时，FPS已经低到了发指的10fps左右，同时存在大量GC。</p><p>使用对象池生成400个对象后，性能优化明显好了很多。</p><img src="/2023/03/06/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%AF%B9%E8%B1%A1%E6%B1%A0%E6%A8%A1%E5%BC%8F/image-20230306233841435.png" class title="image-20230306233841435">]]></content>
      
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【设计模式】命令模式</title>
      <link href="/2023/03/06/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/"/>
      <url>/2023/03/06/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="Command-Pattern-命令模式"><a href="#Command-Pattern-命令模式" class="headerlink" title="Command Pattern 命令模式"></a>Command Pattern 命令模式</h1><p>​    命令模式将“请求”封装成对象，以便使用不同的请求、队列或者日志来参数化其他对象，同时支持可撤消的操作。</p><p><a href="https://www.bilibili.com/video/BV1WF411N7jS">命令模式轻松实现撤销功能，解耦以及控制对象的可参数化</a></p><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><img src="/2023/03/06/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/image-20230306141521768.png" class title="image-20230306141521768"><p>​    <strong>发送者</strong>（Sender）——亦称“触发者（Invoker）”——类负责对请求进行初始化，其中必须包含一个成员变量来存储对于命令对象的引用。发送者触发命令，而不向接收者直接发送请求。注意，发送者并不负责创建命令对象：它通常会通过构造函数从客户端处获得预先生成的命令。</p><p>​    <strong>命令</strong>（Command）接口通常仅声明一个执行命令的方法。</p><p>​    <strong>具体命令</strong>（Concrete Commands） 会实现各种类型的请求。具体命令自身并不完成工作，而是会将调用委派给一个业务逻辑对象。但为了简化代码，这些类可以进行合并。接收对象执行方法所需的参数可以声明为具体命令的成员变量。你可以将命令对象设为不可变，仅允许通过构造函数对这些成员变量进行初始化。</p><p>​    <strong>接收者</strong>（Receiver）类包含部分业务逻辑。几乎任何对象都可以作为接收者。绝大部分命令只处理如何将请求传递到接收者的细节，接收者自己会完成实际的工作。</p><p>​    <strong>客户端</strong>（Client）会创建并配置具体命令对象。客户端必须将包括接收者实体在内的所有请求参数传递给命令的构造函数。此后，生成的命令就可以与一个或多个发送者相关联了。</p><h2 id="具体介绍"><a href="#具体介绍" class="headerlink" title="具体介绍"></a>具体介绍</h2><p>命令模式是对象行为型模式，通过将请求者和执行者之间的请求抽离出来封装成一个对象，从而使发出请求的职责和执行请求的职责分离。请求者和执行者通过命令对象来进行沟通，这样使得对命令对象进行存储，管理，传递等。</p><p>命令模式是行为型模式中十分常用的模式，在游戏开发中也十分重要。通过将大量的命令进行管理和存储，保证了命令的顺序和统一。在使用软件时，我们经常会用到撤销这个操作，软件是如何执行撤销的，显然是将你的每一步操作进行保存，通过读取每步操作进行还原。而这就是命令模式，其中每步操作就是一个命令。</p><p>在游戏中（比如地平线5）中的撤销会不会就是用命令模式进行的呢？</p><h2 id="实践："><a href="#实践：" class="headerlink" title="实践："></a>实践：</h2><h3 id="在Unity中对于玩家的移动，比较基本的写法如下："><a href="#在Unity中对于玩家的移动，比较基本的写法如下：" class="headerlink" title="在Unity中对于玩家的移动，比较基本的写法如下："></a>在Unity中对于玩家的移动，比较基本的写法如下：</h3><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">NormalMove</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> GameObject Player;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> m_speed = <span class="number">5f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//键盘控制移动</span></span><br><span class="line">        PlayerMove_KeyTransform();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过Transform组件 键盘控制移动</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PlayerMove_KeyTransform</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (Input.GetKey(KeyCode.W) | Input.GetKey(KeyCode.UpArrow)) <span class="comment">//前</span></span><br><span class="line">        &#123;</span><br><span class="line">            Player.transform.Translate(Vector3.forward * m_speed * Time.deltaTime);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (Input.GetKey(KeyCode.S) | Input.GetKey(KeyCode.DownArrow)) <span class="comment">//后</span></span><br><span class="line">        &#123;</span><br><span class="line">            Player.transform.Translate(Vector3.forward * -m_speed * Time.deltaTime);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (Input.GetKey(KeyCode.A) | Input.GetKey(KeyCode.LeftArrow)) <span class="comment">//左</span></span><br><span class="line">        &#123;</span><br><span class="line">            Player.transform.Translate(Vector3.right * -m_speed * Time.deltaTime);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (Input.GetKey(KeyCode.D) | Input.GetKey(KeyCode.RightArrow)) <span class="comment">//右</span></span><br><span class="line">        &#123;</span><br><span class="line">            Player.transform.Translate(Vector3.right * m_speed * Time.deltaTime);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="很明显，非常耦合。那如何把命令改成对象呢？"><a href="#很明显，非常耦合。那如何把命令改成对象呢？" class="headerlink" title="很明显，非常耦合。那如何把命令改成对象呢？"></a>很明显，非常耦合。那如何把命令改成对象呢？</h3><p>首先我们把命令写出一个抽象基类，然后各种不同的操作继承该基类。</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Command.cs</span></span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">Command</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">Execute</span>(<span class="params">GameObject player</span>)</span>; <span class="comment">//命令的执行</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">Undo</span>(<span class="params"></span>)</span>;<span class="comment">//使用命令模式还可以进行撤销操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后写出继承的类</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MoveCommand.cs</span></span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MoveForWard</span> : <span class="title">Command</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> GameObject _player;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Execute</span>(<span class="params">GameObject player</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        _player = player;</span><br><span class="line">        player.transform.Translate(Vector3.forward);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Undo</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        _player.transform.Translate(Vector3.back);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MoveLeft</span> : <span class="title">Command</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> GameObject _player;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Execute</span>(<span class="params">GameObject player</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        _player = player;</span><br><span class="line">        player.transform.Translate(Vector3.left);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Undo</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        _player.transform.Translate(Vector3.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MoveRight</span> : <span class="title">Command</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> GameObject _player;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Execute</span>(<span class="params">GameObject player</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        _player = player;</span><br><span class="line">        player.transform.Translate(Vector3.right);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Undo</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        _player.transform.Translate(Vector3.left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MoveBack</span> : <span class="title">Command</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> GameObject _player;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Execute</span>(<span class="params">GameObject player</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        _player = player;</span><br><span class="line">        player.transform.Translate(Vector3.back);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Undo</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        _player.transform.Translate(Vector3.forward);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时我们需要一个Manager对于命令进行管理，此处定义了一个命令List，用于记录所执行过的命令，于是我们也可以根据这个List进行操作的撤销。（此处用Stack也不是不行，或者用双向队列更好）</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//CommandManager.cs</span></span><br><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CommandManager</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> CommandManager Instance;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">readonly</span> <span class="title">List</span>&lt;<span class="title">Command</span>&gt; _commandList</span> = <span class="keyword">new</span> List&lt;Command&gt;();<span class="comment">//记录操作列表</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Awake</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (Instance) Destroy(Instance);</span><br><span class="line">        <span class="keyword">else</span> Instance = <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">AddCommands</span>(<span class="params">Command command</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        _commandList.Add(command);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IEnumerator <span class="title">UndoStart</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        _commandList.Reverse();</span><br><span class="line">        <span class="keyword">foreach</span> (Command command <span class="keyword">in</span> _commandList)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title">WaitForSeconds</span>(<span class="params"><span class="number">.2</span>f</span>)</span>;</span><br><span class="line">            command.Undo();</span><br><span class="line">        &#125;</span><br><span class="line">        _commandList.Clear();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>最后再写一个handler进行操作的监听即可</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">InputHandler</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> MoveForWard _moveForward = <span class="keyword">new</span> MoveForWard();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> MoveBack _moveBack = <span class="keyword">new</span> MoveBack();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> MoveLeft _moveLeft = <span class="keyword">new</span> MoveLeft();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> MoveRight _moveRight = <span class="keyword">new</span> MoveRight();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> GameObject _playerCube;</span><br><span class="line">    <span class="keyword">private</span> KeyCode[] _keyCodes;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        _playerCube = GameObject.Find(<span class="string">&quot;Player&quot;</span>);</span><br><span class="line">        _keyCodes = <span class="keyword">new</span>[] &#123;KeyCode.A, KeyCode.W, KeyCode.S, KeyCode.D,KeyCode.B&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Update</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        PlayerInputHandler();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">PlayerInputHandler</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (Input.GetKeyDown(_keyCodes[<span class="number">1</span>]))</span><br><span class="line">        &#123;</span><br><span class="line">            _moveForward.Execute(_playerCube);</span><br><span class="line">            CommandManager.Instance.AddCommands(_moveForward);<span class="comment">//顺序不能弄混，因为要等赋值完后再加入</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (Input.GetKeyDown(_keyCodes[<span class="number">0</span>]))</span><br><span class="line">        &#123;</span><br><span class="line">            _moveLeft.Execute(_playerCube);</span><br><span class="line">            CommandManager.Instance.AddCommands(_moveLeft);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (Input.GetKeyDown(_keyCodes[<span class="number">3</span>]))</span><br><span class="line">        &#123;</span><br><span class="line">            _moveRight.Execute(_playerCube);</span><br><span class="line">            CommandManager.Instance.AddCommands(_moveRight);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (Input.GetKeyDown(_keyCodes[<span class="number">2</span>]))</span><br><span class="line">        &#123;</span><br><span class="line">            _moveBack.Execute(_playerCube);</span><br><span class="line">            CommandManager.Instance.AddCommands(_moveBack);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (Input.GetKeyDown(_keyCodes[<span class="number">4</span>]))</span><br><span class="line">        &#123;</span><br><span class="line">            StartCoroutine(CommandManager.Instance.UndoStart());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后将InputHandler.cs 和 CommandManager.cs随便挂在空物体上，创建一个Cube重命名为Player即可运行。一顿操作之后，按下B键即可全部撤销。</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><img src="/2023/03/06/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/image-20230306144100649.png" class title="image-20230306144100649">]]></content>
      
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【设计模式】组合模式</title>
      <link href="/2023/03/06/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/"/>
      <url>/2023/03/06/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="Composite-Pattern-组合模式"><a href="#Composite-Pattern-组合模式" class="headerlink" title="Composite Pattern 组合模式"></a>Composite Pattern 组合模式</h1><p>​    <strong><a href="https://blog.csdn.net/hfmbook/article/details/7693069">组合模式概述</a></strong></p><p>​    <a href="https://refactoringguru.cn/design-patterns/composite">https://refactoringguru.cn/design-patterns/composite</a> </p><p>​    <a href="https://github.com/QianMo/Unity-Design-Pattern">https://github.com/QianMo/Unity-Design-Pattern</a></p><p>​    将对象组合成树形结构以表示”部分-整体”的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性。</p><h2 id="结构："><a href="#结构：" class="headerlink" title="结构："></a>结构：</h2><img src="/2023/03/06/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/image-20230306133533693.png" class title="image-20230306133533693"><p><strong>组件</strong>（Component）接口描述了树中简单项目和复杂项目所共有的操作。</p><p><strong>叶节点</strong>（Leaf）是树的基本结构，它不包含子项目。一般情况下，叶节点最终会完成大部分的实际工作，因为它们无法将工作指派给其他部分。</p><p><strong>容器</strong>（Container）——又名“组合（Composite）”——是包含叶节点或其他容器等子项目的单位。容器不知道其子项目所属的具体类，它只通过通用的组件接口与其子项目交互。<strong>容器接收到请求后会将工作分配给自己的子项目，处理中间结果，然后将最终结果返回给客户端。</strong></p><p><strong>客户端</strong>（Client）通过组件接口与所有项目交互。因此，客户端能以相同方式与树状结构中的简单或复杂项目交互。</p><h2 id="具体介绍："><a href="#具体介绍：" class="headerlink" title="具体介绍："></a>具体介绍：</h2><p>​    将不同的功能用不同的脚本实现，然后使用拖拽的方式自由组合，来实现不同的目的。因为在Unity中，一切物体都可当做组件(包括脚本)，这就极有利于实现组合模式。</p><p>​    将不同的类组合起来（一般分为高层类与低层类），使较高层的类能够像使用独立类一样，使用组合进来的类。提高代码的复用性，降低增加对象成本。</p><p>​    “组件模式（Composite）在面对一个复杂的树状结构大型对象时，只需要调用根节点的执行器（Driver），就可以将整个树每个结点的操作进行遍历执行。就是Unity那样，遍历GameObject，然后遍历每个GameObject的Component，其中GameObject有父子关系，Component中有先后关系，而采用组件模式，使整个游戏的启动，只需要唯一的接口调用，在制作游戏的过程中，也非常易于增减组件与物体，这也是Unity的一大特性。</p><h2 id="实践："><a href="#实践：" class="headerlink" title="实践："></a>实践：</h2><p>​    Unity中对每个对象可以拖拽同一个脚本上去的模式，就是组合模式的一种体现。在代码中，则可表现为树叶子的形式：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 组合模式 20230306 </span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CompositeMode</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Start is called before the first frame update</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        INode root = <span class="keyword">new</span> CompositeNode(<span class="string">&quot;Character&quot;</span>);</span><br><span class="line"></span><br><span class="line">        INode leftHand = <span class="keyword">new</span> LeafNode(<span class="string">&quot;LeftHand&quot;</span>);</span><br><span class="line">        INode body = <span class="keyword">new</span> CompositeNode(<span class="string">&quot;Body&quot;</span>);</span><br><span class="line">        INode rightHand = <span class="keyword">new</span> LeafNode(<span class="string">&quot;RightHand&quot;</span>);</span><br><span class="line"></span><br><span class="line">        root.AddChildNodes(leftHand, body, rightHand);</span><br><span class="line"></span><br><span class="line">        INode leftFoot = <span class="keyword">new</span> LeafNode(<span class="string">&quot;LeftFoot&quot;</span>);</span><br><span class="line">        INode rightFoot = <span class="keyword">new</span> LeafNode(<span class="string">&quot;RightFoot&quot;</span>);</span><br><span class="line"></span><br><span class="line">        body.AddChildNodes(leftFoot, rightFoot);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        ShowAllNode(root);</span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">      <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">      <span class="comment"><span class="doctag">///</span> 显示节点和其所有子节点</span></span><br><span class="line">      <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ShowAllNode</span>(<span class="params">INode node</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Debug.Log(node.Name);</span><br><span class="line"></span><br><span class="line">        List&lt;INode&gt; childNodeList = node.ChildNodeList;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span> || childNodeList == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">foreach</span> (INode item <span class="keyword">in</span> childNodeList)</span><br><span class="line">        &#123;</span><br><span class="line">            ShowAllNode(item);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 节点抽象类</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">INode</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="built_in">string</span> mName;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name &#123; <span class="keyword">get</span> &#123; <span class="keyword">return</span> mName; &#125; &#125;</span><br><span class="line">    <span class="keyword">protected</span> List&lt;INode&gt; mChildNodeList;</span><br><span class="line">    <span class="keyword">public</span> List&lt;INode&gt; ChildNodeList &#123; <span class="keyword">get</span> &#123; <span class="keyword">return</span> mChildNodeList; &#125; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">INode</span>(<span class="params"><span class="built_in">string</span> name</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        mChildNodeList = <span class="keyword">new</span> List&lt;INode&gt;();</span><br><span class="line">        mName = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加、移除、获取子节点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">AddChildNode</span>(<span class="params">INode node</span>)</span>;</span><br><span class="line">    <span class="comment">//如果我们想可以一次添加多个子节点，就可以这样写</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">AddChildNodes</span>(<span class="params"><span class="keyword">params</span> INode[] nodes</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">RemoveChildNode</span>(<span class="params">INode node</span>)</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> INode <span class="title">GetChildNode</span>(<span class="params"><span class="built_in">int</span> index</span>)</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 叶子节点</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">LeafNode</span> : <span class="title">INode</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LeafNode</span>(<span class="params"><span class="built_in">string</span> name</span>)</span></span><br><span class="line"><span class="function">        : <span class="title">base</span>(<span class="params">name</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//叶子节点无子节点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">AddChildNode</span>(<span class="params">INode node</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> System.NotImplementedException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">AddChildNodes</span>(<span class="params"><span class="keyword">params</span> INode[] nodes</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> System.NotImplementedException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> INode <span class="title">GetChildNode</span>(<span class="params"><span class="built_in">int</span> index</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> System.NotImplementedException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">RemoveChildNode</span>(<span class="params">INode node</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> System.NotImplementedException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 非叶子节点</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CompositeNode</span> : <span class="title">INode</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CompositeNode</span>(<span class="params"><span class="built_in">string</span> name</span>)</span></span><br><span class="line"><span class="function">    : <span class="title">base</span>(<span class="params">name</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">AddChildNode</span>(<span class="params">INode node</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        mChildNodeList.Add(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">AddChildNodes</span>(<span class="params"><span class="keyword">params</span> INode[] nodes</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">foreach</span> (INode node <span class="keyword">in</span> nodes)</span><br><span class="line">        &#123;</span><br><span class="line">            mChildNodeList.Add(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> INode <span class="title">GetChildNode</span>(<span class="params"><span class="built_in">int</span> index</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ((index &gt;= <span class="number">0</span> &amp;&amp; index &lt; mChildNodeList.Count) == <span class="literal">false</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Debug.LogError(index + <span class="string">&quot;下标不存在&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mChildNodeList[index];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">RemoveChildNode</span>(<span class="params">INode node</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (mChildNodeList.Contains(node) == <span class="literal">false</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Debug.LogError(node + <span class="string">&quot;在子节点中不存在&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        mChildNodeList.Remove(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Hexo】在hexo中添加图片格式_并且不用删除文件名</title>
      <link href="/2023/03/05/Hexo%E6%B7%BB%E5%8A%A0%E5%9B%BE%E7%89%87/"/>
      <url>/2023/03/05/Hexo%E6%B7%BB%E5%8A%A0%E5%9B%BE%E7%89%87/</url>
      
        <content type="html"><![CDATA[<h1 id="前置"><a href="#前置" class="headerlink" title="前置"></a>前置</h1><h2 id="若单纯想在hexo中插入图片，可以阅读以下博客内容："><a href="#若单纯想在hexo中插入图片，可以阅读以下博客内容：" class="headerlink" title="若单纯想在hexo中插入图片，可以阅读以下博客内容："></a>若单纯想在hexo中插入图片，可以阅读以下博客内容：</h2><p><a href="https://zhuanlan.zhihu.com/p/265077468">https://zhuanlan.zhihu.com/p/265077468</a></p><p><a href="https://blog.csdn.net/u010996565/article/details/89196612">https://blog.csdn.net/u010996565/article/details/89196612</a></p><p>（当然并不推荐直接使用上述操作，若想一步到位请移步至hexo-image-link部分，此处仅为记录问题过程而留）</p><p>​    本人也是在阅读以上文章之后，成功地部署了图片在博客中。但是与此同时也有一个很严重的问题，那就是在这些md文件中，<strong>我们必须手动删除掉图片相对地址中的文件名</strong>。</p><img src="/2023/03/05/Hexo%E6%B7%BB%E5%8A%A0%E5%9B%BE%E7%89%87/image-20230305152510090.png" class title="image-20230305152510090"><p>​    <strong>这样子对于有些本来就在本地进行md文件写作的朋友可能很不友好。虽然不少md编辑器（如obsidian）支持删除文件名之后依旧可以实时渲染出图片来，但是也有很多并不能（如Typora）。</strong></p><img src="/2023/03/05/Hexo%E6%B7%BB%E5%8A%A0%E5%9B%BE%E7%89%87/image-20230305152917684.png" class title="image-20230305152917684"><p>​    <strong>在删除文件名后，虽然在hexo中可以正常出现图片，但是在本地的md文件中的图片就不能实时出现了，观感很差，也影响后续对于博客的维护。</strong></p><p>​    当然也可以使用smms等图床，但我实在对这些不太信任，还是更喜欢本地存储。于是我开启了漫长的百度谷歌之旅~</p><p>​    终于让我找到了一位大神所写的插件，很完美地解决了该问题，使得<strong>以上图片格式也能正常部署到hexo上并显示出来</strong>了。</p><h2 id="hexo-image-link-插件"><a href="#hexo-image-link-插件" class="headerlink" title="hexo-image-link 插件"></a>hexo-image-link 插件</h2><p>​    感谢名为”cocowool”的开发者的无私分享。</p><p>​    github地址：<a href="https://github.com/cocowool/hexo-image-link">https://github.com/cocowool/hexo-image-link</a></p><p>​    安装教程：<a href="http://edulinks.cn/2020/03/14/20200314-write-hexo-with-typora/">http://edulinks.cn/2020/03/14/20200314-write-hexo-with-typora/</a></p><p>​    </p><p>​    安装过程教程中讲的更加详细，值得注意的是，在安装该插件之前，必须卸载例如 hexo-asset-image的插件。</p><img src="/2023/03/05/Hexo%E6%B7%BB%E5%8A%A0%E5%9B%BE%E7%89%87/image-20230305153625383.png" class title="image-20230305153625383"><h2 id="final"><a href="#final" class="headerlink" title="final"></a>final</h2><p>安装好之后就能发现直接使用图片插入再部署到hexo上已经没有问题了。</p><p>终于能自由地写作了，还是非常感谢cocowool大佬，祝一路顺风。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Unity】单机多人实时对战游戏 项目解析</title>
      <link href="/2023/03/04/Unity%E5%8D%95%E6%9C%BA%E5%A4%9A%E4%BA%BA%E6%B8%B8%E6%88%8F%E9%A1%B9%E7%9B%AE%E8%A7%A3%E6%9E%90/"/>
      <url>/2023/03/04/Unity%E5%8D%95%E6%9C%BA%E5%A4%9A%E4%BA%BA%E6%B8%B8%E6%88%8F%E9%A1%B9%E7%9B%AE%E8%A7%A3%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>对于之前用Unity做的课设有点遗忘，做点笔记回顾一下，顺便整理复习。<br>（今天骑车上了江上大桥，很开心）</p><h1 id="用单例传递全局数据"><a href="#用单例传递全局数据" class="headerlink" title="用单例传递全局数据"></a>用单例传递全局数据</h1><p><a href="https://blog.csdn.net/u011492260/article/details/113836431">https://blog.csdn.net/u011492260/article/details/113836431</a></p><p>在GameManager中</p><img src="/2023/03/04/Unity%E5%8D%95%E6%9C%BA%E5%A4%9A%E4%BA%BA%E6%B8%B8%E6%88%8F%E9%A1%B9%E7%9B%AE%E8%A7%A3%E6%9E%90/img1.png" class><p>去使用单例获得</p><img src="/2023/03/04/Unity%E5%8D%95%E6%9C%BA%E5%A4%9A%E4%BA%BA%E6%B8%B8%E6%88%8F%E9%A1%B9%E7%9B%AE%E8%A7%A3%E6%9E%90/img2.png" class><h1 id="关于Unity的协程"><a href="#关于Unity的协程" class="headerlink" title="关于Unity的协程"></a>关于Unity的协程</h1><p><a href="https://blog.csdn.net/fdyshlk/article/details/72667814">https://blog.csdn.net/fdyshlk/article/details/72667814</a><br><a href="https://blog.csdn.net/qq_44705559/article/details/118052537">https://blog.csdn.net/qq_44705559/article/details/118052537</a><br><a href="https://blog.csdn.net/qq_42385019/article/details/107809482">https://blog.csdn.net/qq_42385019/article/details/107809482</a></p><img src="/2023/03/04/Unity%E5%8D%95%E6%9C%BA%E5%A4%9A%E4%BA%BA%E6%B8%B8%E6%88%8F%E9%A1%B9%E7%9B%AE%E8%A7%A3%E6%9E%90/img3.png" class><p>这里用协程是希望使用其wait功能去做一个缓执行，改善游戏的节奏感。（嗯抄就）<br><a href="https://blog.csdn.net/cbbbc/article/details/50456761">https://blog.csdn.net/cbbbc/article/details/50456761</a></p><img src="/2023/03/04/Unity%E5%8D%95%E6%9C%BA%E5%A4%9A%E4%BA%BA%E6%B8%B8%E6%88%8F%E9%A1%B9%E7%9B%AE%E8%A7%A3%E6%9E%90/img4.png" class><p>在其他地方可以更方便地看到协程的用处：<img src="/2023/03/04/Unity%E5%8D%95%E6%9C%BA%E5%A4%9A%E4%BA%BA%E6%B8%B8%E6%88%8F%E9%A1%B9%E7%9B%AE%E8%A7%A3%E6%9E%90/img11.png" class><br>例如这里用了个Timer强制固定了每次近战攻击的间隔是1s</p><h1 id="Interface"><a href="#Interface" class="headerlink" title="Interface"></a>Interface</h1><img src="/2023/03/04/Unity%E5%8D%95%E6%9C%BA%E5%A4%9A%E4%BA%BA%E6%B8%B8%E6%88%8F%E9%A1%B9%E7%9B%AE%E8%A7%A3%E6%9E%90/img6.png" class><p>在本游戏中添加了很多interface，主要对同类型的物品都提供接口，方便调用，减耦合。</p><img src="/2023/03/04/Unity%E5%8D%95%E6%9C%BA%E5%A4%9A%E4%BA%BA%E6%B8%B8%E6%88%8F%E9%A1%B9%E7%9B%AE%E8%A7%A3%E6%9E%90/img7.png" class><img src="/2023/03/04/Unity%E5%8D%95%E6%9C%BA%E5%A4%9A%E4%BA%BA%E6%B8%B8%E6%88%8F%E9%A1%B9%E7%9B%AE%E8%A7%A3%E6%9E%90/img8.png" class><p>例如上图中，对于不同武器的shoot，我们会有不同的效果。使用Interface可以爽爽地调用。例下图：此处是normalWeapon.cs中继承的接口，调用了内部函数LeftHit();</p><img src="/2023/03/04/Unity%E5%8D%95%E6%9C%BA%E5%A4%9A%E4%BA%BA%E6%B8%B8%E6%88%8F%E9%A1%B9%E7%9B%AE%E8%A7%A3%E6%9E%90/img9.png" class><img src="/2023/03/04/Unity%E5%8D%95%E6%9C%BA%E5%A4%9A%E4%BA%BA%E6%B8%B8%E6%88%8F%E9%A1%B9%E7%9B%AE%E8%A7%A3%E6%9E%90/img10.png" class><p>实现了如果玩家手持的是近战武器，则接口会直接调用近战武器的攻击函数，很方便！！（这个近战攻击的函数是不是太复杂了)<br>GREAT！</p><h1 id><a href="#" class="headerlink" title></a></h1>]]></content>
      
      
      
        <tags>
            
            <tag> Unity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【计算机视觉】图像的局部特征信息及全景图像拼接</title>
      <link href="/2022/01/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89_%E5%85%A8%E6%99%AF%E5%9B%BE%E5%83%8F%E6%8B%BC%E6%8E%A5/"/>
      <url>/2022/01/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89_%E5%85%A8%E6%99%AF%E5%9B%BE%E5%83%8F%E6%8B%BC%E6%8E%A5/</url>
      
        <content type="html"><![CDATA[<p>兜兜转转，又到了一年的末尾，只是这一年还有期末大作业留到了考试结束之后<br><a href="https://juejin.cn/post/6844904088094638094">https://juejin.cn/post/6844904088094638094</a></p><h1 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h1><p>​    本次作业包含了Harris角点检测，RANSAC以及HOG描述符，最终将会利用这些工具来完成全景拼接。当然，你可以通过增加新的内容，例如可以通过SIFT算法来进行特征的检测和描述、利用透视变换来增加对out of plane图像的支持。同时，也鼓励大家自己拍摄照片来实现全景的拼接，这样才能获取额外的分数。</p><p>​    提示：如果你要实现360°的拼接，可能需要把affine变换改为透视变换才能有比较好的结果。求解透视变换时候可能会遇到求解Ax=0的问题，这时候可以参考下DLT算法，即direct linear transform算法。简单而言，就是对矩阵A做一把SVD，找出V中最小的奇异值所对应的特征向量就是其中的一个解（参见PPT）。</p><p>​    除了代码之外，你还需要完成提交一份文档，对你的算法流程以及代码进行原理说明和注释。</p><pre><code>基于Matlab；</code></pre><h1 id="内容概述："><a href="#内容概述：" class="headerlink" title="内容概述："></a>内容概述：</h1><h2 id="全景拼接简介"><a href="#全景拼接简介" class="headerlink" title="全景拼接简介"></a>全景拼接简介</h2><p>​    全景拼接技术是计算机视觉的一项早期实践。早在2007年，Matthew Brown 以及 David G. Lowe两人就发表了一篇著名的全景拼接文章panoramic image stitching paper.自那之后，自动全景拼接技术便被广泛地应用开来。这期中包括了Google街景，手机里面的全景模式，以及各类的全景拼接软件（例如Photosynth 以及 Auto Stitch）。<br>​    在本次作业中，我们将会<strong>从多张照片中检测并且匹配关键点，从而构建一张全景图片</strong>。这其中包含了以下几个任务：</p><ol><li>利用Harris角点检测算子来寻找关键点</li><li>建构用于描述每个关键点的算子（descriptor） 比较来自两幅不同图片的两组关键点，并且将它们匹配起来。</li><li>给定一组匹配的关键点，利用最小二乘法找到仿射变换矩阵（affine transformation matrix）将一幅图片上的点映射到另一幅图片上。</li><li>利用RANSAC算法估计一个更加准确、稳定的仿射变换矩阵。 给定变换矩阵，利用它来变换图片并且拼接到另一幅图片上来，从而形成全景图片。</li><li>利用另一组描述算子（HOG）得到另一组拼接结果。</li></ol><h1 id="前置知识（复制粘贴）"><a href="#前置知识（复制粘贴）" class="headerlink" title="前置知识（复制粘贴）"></a>前置知识（复制粘贴）</h1><h2 id="模块-1-Harris-角点检测"><a href="#模块-1-Harris-角点检测" class="headerlink" title="模块 1 Harris 角点检测"></a>模块 1 Harris 角点检测</h2><p>在本节中，你将会利用Harris角点检测算子来定位图片的关键点。Harris角点检测算法包括了如下几个步骤：</p><h3 id="目的："><a href="#目的：" class="headerlink" title="目的："></a>目的：</h3><ul><li>可重复检测</li><li>精确定位</li><li>包含图像的高频信息</li></ul><h3 id="本质："><a href="#本质：" class="headerlink" title="本质："></a>本质：</h3><p>寻找图像的二维信号变化，在角点区域附近，图像的梯度有两个或更多的变化方向。</p><p> 而角点有如下的数理规律：</p><p>​    对于平坦区域，在水平和竖直方向上的梯度小；对于边缘区域，在水平和竖直两个方向上有一者梯度大，一者梯度小；对于角点，则在两个方向上都有较大的梯度。下图较形象地描述了三者的区别。<img src="/2022/01/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89_%E5%85%A8%E6%99%AF%E5%9B%BE%E5%83%8F%E6%8B%BC%E6%8E%A5/image-20220112130422729.png" class title="image-20220112130422729"></p><h3 id="Harris角点检测的数学表达："><a href="#Harris角点检测的数学表达：" class="headerlink" title="Harris角点检测的数学表达："></a>Harris角点检测的数学表达：</h3><img src="/2022/01/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89_%E5%85%A8%E6%99%AF%E5%9B%BE%E5%83%8F%E6%8B%BC%E6%8E%A5/image-20220112144305491.png" class title="image-20220112144305491"><img src="/2022/01/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89_%E5%85%A8%E6%99%AF%E5%9B%BE%E5%83%8F%E6%8B%BC%E6%8E%A5/image-20220112144319928.png" class title="image-20220112144319928"><p>​    Harris角点检测可以保证图像特征的平移不变性、旋转不变性、强度（光照）不变性，但缺陷在于无法保证尺度不变（缩放不变），因此对于不同的窗口大小，能够检测出的角点有所不同。这就导致了特征因拍摄距离的变化而发生变化，无法做到特征的稳定性。</p><h2 id="模块-2-关键点的描述及其匹配"><a href="#模块-2-关键点的描述及其匹配" class="headerlink" title="模块 2 关键点的描述及其匹配"></a>模块 2 关键点的描述及其匹配</h2><p>​    我们已经能够利用Harris角点检测算法来定位两张图片中的关键点。接下来我们需要对检测到的关键点进行匹配，确定好两张图片中哪些点是一一对应的。这就需要我们<strong>先对关键点进行描述</strong>。那如何进行关键点描述呢？一个简单的方法是，<strong>选取关键点周围的一个固定区域，并利用该区域的信息生成一组描述向量descriptors.</strong></p><h3 id="模块-2-1-生成描述向量"><a href="#模块-2-1-生成描述向量" class="headerlink" title="模块 2.1 生成描述向量"></a>模块 2.1 生成描述向量</h3><p>​    首先，利用前面的代码完成图像特征点的选取</p><p>​    然后，你需要完成 describe_key points 函数，从而对<strong>每个特征点生成对应的描述符</strong>。</p><p>​    由于用于测试的两张图片并没有发生过多的几何变化，因此我们可以简单地认为它们的scale都相同。所以在进行描述的时候，我们可以简单地在特征点周围框定一个固定大小的window来进行特征点描述(比如，选择一个16<em>16大小的窗口，从而截出一个*<em>patch image</em></em>)。<br>​    由于该实例比较简单，我们也可以<strong>直接用像素值来进行来当描述好的向量（即展开成一维向量）</strong>。当然，为了增加光照稳定性，我们可以<strong>将这个向量进行标准正态化</strong>。</p><p>​    (是不是意味着我绕着这个点把相邻的截取下来就可以了)</p><h3 id="模块-2-2-匹配描述子"><a href="#模块-2-2-匹配描述子" class="headerlink" title="模块 2.2 匹配描述子"></a>模块 2.2 匹配描述子</h3><p>​    接着, 完成 match_descriptors 函数并找到两组描述子集合中相匹配的向量。首先，从两张图片中各取一个描述子（也就是关键点生成的向量），计算它们的欧氏距离。利用欧氏距离来判定它们是不是对应的一组描述子: 如果这一对描述子的距离显著小于其他的距离，那么我们认为它们是一组对应的特征点。我们将对应的特征点连接到一起，并将匹配的点连接到一起。</p><h1 id="代码实战体验"><a href="#代码实战体验" class="headerlink" title="代码实战体验"></a>代码实战体验</h1><h2 id="首先是寻找角点"><a href="#首先是寻找角点" class="headerlink" title="首先是寻找角点"></a>首先是寻找角点</h2><p>算出偏导数，X=imfilter(img,[-1 0 1]);再根据公式计算X2,XY等等。  <br><code>h=fspecial(&#39;gaussian&#39;,[9 9],2);</code><br>用高斯卷积核进行平滑处理，然后计算最重要的M矩阵M=[A(h,w) C(h,w);C(h,w) B(h,w)];同时用R(h,w)=det(M) - k*(trace(M)^2);进行角点的检测。</p><p>这里记录一个Mmax用于确定判断角点的阈值。先用阈值过滤掉一部分的角点，然后再用非极大值抑制进行细化R_corner=(R&gt;=(Q*RMax)).*R；寻找3x3邻域内的最大值，只有一个交点在8邻域内是该邻域的最大点时，才认为该点是角点，R_localMax = nlfilter(R,[3 3],fun);</p><p>最后</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[row,col]=find(R_localMax(<span class="number">2</span>:height<span class="number">-1</span>,<span class="number">2</span>:width<span class="number">-1</span>)==R_corner(<span class="number">2</span>:height<span class="number">-1</span>,<span class="number">2</span>:width<span class="number">-1</span>))</span><br></pre></td></tr></table></figure><p>即可得出坐标。 </p><p>本来得到的结果是角点的行列分开的一维向量，但是不方便计算，于是就进行了更改。</p><h2 id="然后需要对找到的角点进行描述，方便后续对比连线"><a href="#然后需要对找到的角点进行描述，方便后续对比连线" class="headerlink" title="然后需要对找到的角点进行描述，方便后续对比连线"></a>然后需要对找到的角点进行描述，方便后续对比连线</h2><p>这里根据之前的角点检测结果进行一个循环，找到角点就对其进行周边16*16进行获取，进行俩个for循环，获取位置值和相对位置值，以便后续操作。在进行描述之后，就要对于描述好的向量进行一个匹配了，这里用到欧氏距离计算。通过计算两点之间的欧氏距离来完成特征点的匹配，然后分组进行配对，从第一组中任选一个特征向量v1，计算它与第二组每个特征向量之间的距离，我们就得到了v1与其他特征向量之间的距离。 如果离v1最近的特征向量分别是v21,v22,v1和v21的距离远小于v1和v22的距离，那么认为v1和v21就是一组。 也就是说d(v1,v21)/d(v1,v22)需要小于某个阈值，据此，可以找出所有的匹配点。</p><h2 id="变换矩阵"><a href="#变换矩阵" class="headerlink" title="变换矩阵"></a>变换矩阵</h2><p>然后利用这组对应的像素点计算从图片二映射到图片一的变换矩阵，也就是拟合 affine变换矩阵，使得 p2 * H = p1、</p><h2 id="RANSAC"><a href="#RANSAC" class="headerlink" title="RANSAC"></a>RANSAC</h2><p>随机选取若干组match点rd = randi([1 length],1,fpoints);计算affine的变换矩阵：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">rref_P = h* matcher2;</span><br><span class="line">rref_P(<span class="number">1</span>,:) = rref_P(<span class="number">1</span>,:)./rref_P(<span class="number">3</span>,:);</span><br><span class="line">rref_P(<span class="number">2</span>,:) = rref_P(<span class="number">2</span>,:)./rref_P(<span class="number">3</span>,:); </span><br><span class="line">error = (rref_P(<span class="number">1</span>,:) - matcher1(<span class="number">1</span>,:)).^<span class="number">2</span> + (rref_P(<span class="number">2</span>,:) - matcher1(<span class="number">2</span>,:)).^<span class="number">2</span>;</span><br><span class="line"><span class="comment">//计算有效数据点(inliers)的数目  </span></span><br><span class="line"><span class="keyword">if</span>(n &gt;= length*<span class="number">.95</span>) num=h;</span><br><span class="line">inliers = find(error&lt;errorhold);</span><br></pre></td></tr></table></figure><p>记录有效点数目最大的那组参数，返回输出即可。</p><h2 id="HOG梯度直方图"><a href="#HOG梯度直方图" class="headerlink" title="HOG梯度直方图"></a>HOG梯度直方图</h2><p>换用HOG来计算特征点的特征，先求出图像的梯度和每个像素点对应的梯度方向。首先进行一个图像的扩展，用于方便进行边缘的梯度计算。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">calculate_image = <span class="built_in">zeros</span>(row+<span class="number">2</span>,col+<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span> i = <span class="number">2</span>:row+<span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> j = <span class="number">2</span>:col+<span class="number">1</span></span><br><span class="line">            <span class="built_in">calculate_image</span>(i,j) = <span class="built_in">double_image</span>(i<span class="number">-1</span>,j<span class="number">-1</span>);</span><br><span class="line">        end</span><br><span class="line">    end</span><br><span class="line"><span class="comment">//然后就开始用3*3的窗口求梯度即可，用俩个for循环求，分别把求出来的值塞入</span></span><br><span class="line"><span class="built_in">gradx_image</span>(i+<span class="number">1</span>,j+<span class="number">1</span>) = <span class="built_in">sum</span>(<span class="built_in">sum</span>(Sx));</span><br><span class="line"><span class="built_in">grady_image</span>(i+<span class="number">1</span>,j+<span class="number">1</span>) = <span class="built_in">sum</span>(<span class="built_in">sum</span>(Sy));</span><br><span class="line"></span><br><span class="line"><span class="built_in">tidu</span>(i,j) = <span class="built_in">floor</span>(ang/angle_range);</span><br><span class="line"><span class="comment">//计算梯度直方图 将图片分成若干个cell，并对每个cell计算梯度直方图（2*2个cell）</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> b&lt;=width&amp;&amp;a&lt;=height</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">ceil</span>(k/<span class="number">16</span>)&lt;=<span class="number">8</span> &amp;&amp; (k-<span class="built_in">ceil</span>(k/<span class="number">16</span>)*<span class="number">16</span>)&lt;=<span class="number">8</span>)</span><br><span class="line">                <span class="built_in">temp</span>(<span class="number">1</span>,<span class="built_in">tidu</span>(a,b)+<span class="number">1</span>)=<span class="built_in">temp</span>(<span class="number">1</span>,<span class="built_in">tidu</span>(a,b)+<span class="number">1</span>)+<span class="built_in">sqrt</span>(<span class="built_in">gradx</span>(a,b)*<span class="built_in">gradx</span>(a,b)+<span class="built_in">grady</span>(a,b)*<span class="built_in">grady</span>(a,b));</span><br><span class="line">                end……</span><br><span class="line"></span><br><span class="line"><span class="comment">//然后  %将若干个cell合成一个block，并将里面的梯度直方图转成特征向量 （将4个cell合并成一个block生成特征向量）</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> u=<span class="number">1</span>:<span class="number">36</span></span><br><span class="line">           <span class="built_in">universe</span>(i,u)= <span class="built_in">temp</span>(u);</span><br><span class="line">        end即可。</span><br></pre></td></tr></table></figure><h2 id="线性融合"><a href="#线性融合" class="headerlink" title="线性融合"></a>线性融合</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">%确定融合区域的左边界和右边界</span><br><span class="line"></span><br><span class="line">warped_image(isnan(warped_image))=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">%给图片<span class="number">1</span>确定一个权重矩阵: - 从图片<span class="number">1</span>的最左边到融合区域的最左边，weight为<span class="number">1</span> - 从融合区域的最左边到图片<span class="number">1</span>的最右边，weight从<span class="number">1</span>到<span class="number">0</span>进行分布</span><br><span class="line"></span><br><span class="line">maskA = (warped_image(:,:,<span class="number">1</span>)&gt;<span class="number">0</span> |warped_image(:,:,<span class="number">2</span>)&gt;<span class="number">0</span> | warped_image(:,:,<span class="number">3</span>)&gt;<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">newImage = zeros(size(warped_image));</span><br><span class="line"></span><br><span class="line">newImage(y:y+size(unwarped_image,<span class="number">1</span>)<span class="number">-1</span>, x: x+size(unwarped_image,<span class="number">2</span>)<span class="number">-1</span>,:) = unwarped_image;</span><br><span class="line"></span><br><span class="line">mask = (newImage(:,:,<span class="number">1</span>)&gt;<span class="number">0</span> | newImage(:,:,<span class="number">2</span>)&gt;<span class="number">0</span> | newImage(:,:,<span class="number">3</span>)&gt;<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">mask = <span class="keyword">and</span>(maskA, mask);</span><br><span class="line"></span><br><span class="line">% 分别对左右两张图片应用权重矩阵</span><br><span class="line"></span><br><span class="line">[~,col] = find(mask);</span><br><span class="line"></span><br><span class="line">left = min(col);</span><br><span class="line"></span><br><span class="line">right = max(col);</span><br><span class="line"></span><br><span class="line">mask = ones(size(mask));</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>( x&lt;<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    mask(:,left:right) = repmat(linspace(<span class="number">0</span>,<span class="number">1</span>,right-left+<span class="number">1</span>),size(mask,<span class="number">1</span>),<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"></span><br><span class="line">    mask(:,left:right) = repmat(linspace(<span class="number">1</span>,<span class="number">0</span>,right-left+<span class="number">1</span>),size(mask,<span class="number">1</span>),<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">中间还有一点处理，最后相加即可</span><br><span class="line"></span><br><span class="line">%将两张图相加</span><br><span class="line"></span><br><span class="line">newImage(:,:,<span class="number">1</span>) = warped_image(:,:,<span class="number">1</span>) + newImage(:,:,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">newImage(:,:,<span class="number">2</span>) = warped_image(:,:,<span class="number">2</span>) + newImage(:,:,<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">newImage(:,:,<span class="number">3</span>) = warped_image(:,:,<span class="number">3</span>) + newImage(:,:,<span class="number">3</span>);</span><br></pre></td></tr></table></figure><p>Code已上传Github</p>]]></content>
      
      
      
        <tags>
            
            <tag> 计算机视觉 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【OpenGL】期末复习提纲</title>
      <link href="/2022/01/06/OpenGL%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E6%8F%90%E7%BA%B2/"/>
      <url>/2022/01/06/OpenGL%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E6%8F%90%E7%BA%B2/</url>
      
        <content type="html"><![CDATA[<h1 id="第一、二章："><a href="#第一、二章：" class="headerlink" title="第一、二章："></a>第一、二章：</h1><h2 id="1、OpenGL中能渲染的基本元素是什么？GLU-可以渲染哪些基本元素？"><a href="#1、OpenGL中能渲染的基本元素是什么？GLU-可以渲染哪些基本元素？" class="headerlink" title="1、OpenGL中能渲染的基本元素是什么？GLU 可以渲染哪些基本元素？"></a>1、OpenGL中能渲染的基本元素是什么？GLU 可以渲染哪些基本元素？</h2><p>​    OpenGL仅限生成简单的几何图元，如下所示：<img src="/2022/01/06/OpenGL%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E6%8F%90%E7%BA%B2/image-20220106194239945.png" class title="image-20220106194239945"></p><p>​    GLU即OpenGL工具函数库，可以绘制三维物体、球体、圆环面、茶壶、NUBRS曲线曲面,二次曲面等。</p><ul><li>NUBRS非均匀有理B样条曲线</li><li>NURBS非均匀有理B样条曲面</li><li>二次曲面</li></ul><h1 id="第三章"><a href="#第三章" class="headerlink" title="第三章"></a>第三章</h1><h2 id="2、用框图说明OpenGL的渲染流程，并简要说明每个坐标系。"><a href="#2、用框图说明OpenGL的渲染流程，并简要说明每个坐标系。" class="headerlink" title="2、用框图说明OpenGL的渲染流程，并简要说明每个坐标系。"></a>2、用框图说明OpenGL的渲染流程，并简要说明每个坐标系。</h2><p>​    对我们来说比较重要的总共有5个不同的坐标系统：</p><ul><li>局部空间(Local Space，或者称为物体空间(Object Space))</li><li>世界空间(World Space)</li><li>观察空间(View Space，或者称为视觉空间(Eye Space))</li><li>裁剪空间(Clip Space)</li><li>屏幕空间(Screen Space)</li></ul><p>​       为了将坐标从一个坐标系变换到另一个坐标系，我们需要用到几个变换矩阵，最重要的几个分别是模型(Model)、观察(View)、投影(Projection)三个矩阵。我们的顶点坐标起始于局部空间(Local Space)，在这里它称为局部坐标(Local Coordinate)，它在之后会变为世界坐标(World Coordinate)，观察坐标(View Coordinate)，裁剪坐标(Clip Coordinate)，并最后以屏幕坐标(Screen Coordinate)的形式结束。下面的这张图展示了整个流程以及各个变换过程做了什么：</p><img src="/2022/01/06/OpenGL%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E6%8F%90%E7%BA%B2/image-20220106194855491.png" class title="image-20220106194855491"><ol><li>局部坐标是对象相对于局部原点的坐标，也是物体起始的坐标。</li><li>下一步是将局部坐标变换为世界空间坐标，世界空间坐标是处于一个更大的空间范围的。这些坐标相对于世界的全局原点，它们会和其它物体一起相对于世界的原点进行摆放。</li><li>接下来我们将世界坐标变换为观察空间坐标，使得每个坐标都是从摄像机或者说观察者的角度进行观察的。</li><li>坐标到达观察空间之后，我们需要将其投影到裁剪坐标。裁剪坐标会被处理至-1.0到1.0的范围内，并判断哪些顶点将会出现在屏幕上。</li><li>最后，我们将裁剪坐标变换为屏幕坐标，我们将使用一个叫做视口变换(Viewport Transform)的过程。视口变换将位于-1.0到1.0范围的坐标变换到由glViewport函数所定义的坐标范围内。最后变换出来的坐标将会送到光栅器，将其转化为片段。</li></ol><img src="/2022/01/06/OpenGL%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E6%8F%90%E7%BA%B2/image-20220106195142772.png" class title="image-20220106195142772"><p> 最后还有4测试3操作（？）</p><p>片元的测试按下列的顺序进行，如果在前面的测试中片元被删除，则不在进行后续的测试或操作。</p><ol><li><pre><code>  剪取测试：利用glScissor()函数定义窗口中的一个矩形，并将图限制在其中。</code></pre></li><li><pre><code>  alpha测试：利用alpha值来确定或是拒绝一个片元。利用glEnable()使用参数GL_ALPHA_TEST激活。哟哦那个glAlphaFunc()来比较。用来实现透明算法和纹理图制作贴花。</code></pre></li><li><pre><code>  模板测试：对存储于模板缓存中的像素值与参考值进行比较，根据比较的结果来对模板缓存中的值进行修改。glStencilOp().</code></pre></li></ol><p>4.深度测试：用于消除隐藏表面的操作。glDepthFunc()来设置比较函数。 </p><h2 id="3、投影变换的设置，gluPerspective-glFrustum-glOrtho等的具体含义，gluLookAt函数的具体参数和使用方法。"><a href="#3、投影变换的设置，gluPerspective-glFrustum-glOrtho等的具体含义，gluLookAt函数的具体参数和使用方法。" class="headerlink" title="3、投影变换的设置，gluPerspective, glFrustum, glOrtho等的具体含义，gluLookAt函数的具体参数和使用方法。"></a>3、投影变换的设置，gluPerspective, glFrustum, glOrtho等的具体含义，gluLookAt函数的具体参数和使用方法。</h2><h3 id="1-glFrustum"><a href="#1-glFrustum" class="headerlink" title="1.glFrustum()"></a>1.glFrustum()</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">glFrustum</span><span class="params">(GLdouble left, GLdouble right,</span></span></span><br><span class="line"><span class="params"><span class="function">               GLdouble bottom, GLdouble top, </span></span></span><br><span class="line"><span class="params"><span class="function">               GLdouble near,GLdouble far)</span></span></span><br></pre></td></tr></table></figure><ul><li>left、right、bottom、top：表示近平面四个边的坐标</li><li>near：近平面距离</li><li>far：远平面距离</li></ul><p>glFrustum老透视投影了呀，这个函数定义了一个平截头体，计算一个用于实现透视投影的矩阵，位于视景体之外的物体会被裁剪掉。<img src="/2022/01/06/OpenGL%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E6%8F%90%E7%BA%B2/image-20220106200544468.png" class title="image-20220106200544468"></p><h3 id="2-gluPerspective"><a href="#2-gluPerspective" class="headerlink" title="2.gluPerspective()"></a>2.gluPerspective()</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">gluPerspective</span> <span class="params">(GLdouble fovy, GLdouble aspect,</span></span></span><br><span class="line"><span class="params"><span class="function">                     GLdouble zNear, GLdouble zFar)</span></span></span><br></pre></td></tr></table></figure><ul><li>fovy：上下的（y轴方向）FOV视角</li><li>aspect：投影面长宽比</li><li>zNear：近平面距离</li><li>zFar：远平面距离</li></ul><p>前者实际使用上并不方便，于是就有了gluPerspective()，同样创建视景体，但是是不同方式，这个是直接指定y方向上视野的角度和横纵比。<img src="/2022/01/06/OpenGL%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E6%8F%90%E7%BA%B2/image-20220106200813854.png" class title="image-20220106200813854"></p><h3 id="3-glOrtho"><a href="#3-glOrtho" class="headerlink" title="3. glOrtho()"></a>3. glOrtho()</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">glOrtho</span><span class="params">(GLdouble left, GLdouble right,</span></span></span><br><span class="line"><span class="params"><span class="function">             GLdouble bottom, GLdouble top, </span></span></span><br><span class="line"><span class="params"><span class="function">             GLdouble near, GLdouble far)</span></span></span><br></pre></td></tr></table></figure><ul><li>left、right、bottom、top：表示近平面四个边的坐标</li><li>near：近平面距离</li><li>far：远平面距离</li></ul><p>glOrtho()老正交了啊，也就是说它的视景体是平行的（长方体）。</p><img src="/2022/01/06/OpenGL%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E6%8F%90%E7%BA%B2/image-20220106200921669.png" class title="image-20220106200921669"><h3 id="4-gluLookAt（）"><a href="#4-gluLookAt（）" class="headerlink" title="4.gluLookAt（）"></a>4.gluLookAt（）</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">gluLookAt</span><span class="params">(GLdouble eyex, GLdouble eyey,GLdouble eyez,</span></span></span><br><span class="line"><span class="params"><span class="function">               GLdouble centerx,GLdouble centery,GLdouble centerz,</span></span></span><br><span class="line"><span class="params"><span class="function">               GLdouble upx,GLdouble upy,GLdouble upz)</span></span></span><br></pre></td></tr></table></figure><ul><li>eyex, eyey,eyez：相机在世界坐标的位置</li><li>centerx,centery,centerz：相机镜头对准的点在世界坐标的位置</li><li>upx,upy,upz：相机向上的方向（世界坐标）</li></ul><p>它接受参数去定义了观测点的位置，照相机瞄准的参考点和朝上的方向。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reshape</span> <span class="params">(<span class="keyword">int</span> w, <span class="keyword">int</span> h)</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">       glViewport (<span class="number">0</span>, <span class="number">0</span>, (GLsizei) w, (GLsizei) h);</span><br><span class="line">       glMatrixMode (GL_PROJECTION);<span class="comment">//投影变换矩阵</span></span><br><span class="line">       glLoadIdentity ();</span><br><span class="line">       gluPerspective(<span class="number">60.0</span>, (GLfloat) w/(GLfloat) h, <span class="number">4</span>, <span class="number">10.0</span>);</span><br><span class="line"></span><br><span class="line">       <span class="comment">//下面使用gluLookAt()函数</span></span><br><span class="line">       glMatrixMode(GL_MODELVIEW);<span class="comment">//模型和视点变换矩阵</span></span><br><span class="line">       glLoadIdentity();<span class="comment">//设置为单位矩阵（初始化)</span></span><br><span class="line">       gluLookAt (<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">5.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">0.0</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h1 id="第四、五章"><a href="#第四、五章" class="headerlink" title="第四、五章"></a>第四、五章</h1><h2 id="4、写出OpenGL中局部光照的方程，要包含的系数有光源参数、材料参数、聚光灯的参数、衰减参数等，方程要表示是多个光源的。"><a href="#4、写出OpenGL中局部光照的方程，要包含的系数有光源参数、材料参数、聚光灯的参数、衰减参数等，方程要表示是多个光源的。" class="headerlink" title="4、写出OpenGL中局部光照的方程，要包含的系数有光源参数、材料参数、聚光灯的参数、衰减参数等，方程要表示是多个光源的。"></a>4、写出OpenGL中局部光照的方程，要包含的系数有光源参数、材料参数、聚光灯的参数、衰减参数等，方程要表示是多个光源的。</h2><hr><img src="/2022/01/06/OpenGL%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E6%8F%90%E7%BA%B2/image-20220106223111433.png" class title="image-20220106223111433"><img src="/2022/01/06/OpenGL%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E6%8F%90%E7%BA%B2/image-20220106223128244.png" class title="image-20220106223128244"><h2 id="5、请看下面的一段程序，并计算三个顶点①、②和③处的光照的颜色值。"><a href="#5、请看下面的一段程序，并计算三个顶点①、②和③处的光照的颜色值。" class="headerlink" title="5、请看下面的一段程序，并计算三个顶点①、②和③处的光照的颜色值。"></a>5、请看下面的一段程序，并计算三个顶点①、②和③处的光照的颜色值。</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   GLfloat mat_specular[] = &#123; <span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span> &#125;;</span><br><span class="line">   GLfloat mat_shininess[] = &#123; <span class="number">50.0</span> &#125;;</span><br><span class="line">   GLfloat light_position[] = &#123; <span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">0.0</span> &#125;;</span><br><span class="line"></span><br><span class="line">   glClearColor (<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>);</span><br><span class="line">   glShadeModel (GL_SMOOTH);</span><br><span class="line"></span><br><span class="line">   glLightModelf(GL_LIGHT_MODEL_LOCAL_VIEWER, GL_FALSE);<span class="comment">//这个调用把视点放在视点坐标系的原点处</span></span><br><span class="line">   <span class="comment">//glLightModelf(GL_LIGHT_MODEL_TWO_SIDE, GL_FALSE);//双面光照</span></span><br><span class="line">   glMaterialfv(GL_FRONT, GL_SPECULAR, mat_specular);<span class="comment">//这里设定了材料镜面高光反射指数</span></span><br><span class="line">   glMaterialfv(GL_FRONT, GL_SHININESS, mat_shininess);<span class="comment">//这里设定了镜面高光指数</span></span><br><span class="line">   glLightfv(GL_LIGHT0, GL_POSITION, light_position);</span><br><span class="line"></span><br><span class="line">   glEnable(GL_LIGHTING);</span><br><span class="line">   glEnable(GL_LIGHT0);</span><br><span class="line">   glEnable(GL_DEPTH_TEST);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   glClear (GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);</span><br><span class="line">   glBegin(GL_TRIANGLES);</span><br><span class="line">   glNormal3f(..);</span><br><span class="line">   glVertex3f(<span class="number">1.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>);<span class="comment">//①第一个点</span></span><br><span class="line">   glVertex3f(<span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">0.0</span>);<span class="comment">//②第二个点</span></span><br><span class="line">   glVertex3f(<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>);<span class="comment">//③第三个点</span></span><br><span class="line">   glEnd();</span><br><span class="line">   glFlush ();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reshape</span> <span class="params">(<span class="keyword">int</span> w, <span class="keyword">int</span> h)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   glViewport (<span class="number">0</span>, <span class="number">0</span>, (GLsizei) w, (GLsizei) h);</span><br><span class="line">   glMatrixMode (GL_PROJECTION);</span><br><span class="line">   glLoadIdentity();</span><br><span class="line">   <span class="keyword">if</span> (w &lt;= h)</span><br><span class="line">      glOrtho (<span class="number">-1.5</span>, <span class="number">1.5</span>, <span class="number">-1.5</span>*(GLfloat)h/(GLfloat)w,</span><br><span class="line">         <span class="number">1.5</span>*(GLfloat)h/(GLfloat)w, <span class="number">-10.0</span>, <span class="number">10.0</span>);</span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">      glOrtho (<span class="number">-1.5</span>*(GLfloat)w/(GLfloat)h,</span><br><span class="line">         <span class="number">1.5</span>*(GLfloat)w/(GLfloat)h, <span class="number">-1.5</span>, <span class="number">1.5</span>, <span class="number">-10.0</span>, <span class="number">10.0</span>);</span><br><span class="line">   glMatrixMode(GL_MODELVIEW);</span><br><span class="line">   glLoadIdentity();</span><br><span class="line">   <span class="comment">//ModelView变换矩阵为单位阵的时候，在世界坐标系下，视点位置在(0,0,0),观察方向指向位于(0,0,1)的点，视点上方指向(0,1,0)方向</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">keyboard</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> key, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">switch</span> (key) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">27</span>:</span><br><span class="line">         <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">         <span class="keyword">break</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   glutInit(&amp;argc, argv);</span><br><span class="line">   glutInitDisplayMode (GLUT_SINGLE | GLUT_RGB | GLUT_DEPTH);</span><br><span class="line">   glutInitWindowSize (<span class="number">500</span>, <span class="number">500</span>);</span><br><span class="line">   glutInitWindowPosition (<span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line">   glutCreateWindow (argv[<span class="number">0</span>]);</span><br><span class="line">   init ();</span><br><span class="line">   glutDisplayFunc(display);</span><br><span class="line">   glutReshapeFunc(reshape);</span><br><span class="line">   glutKeyboardFunc(keyboard);</span><br><span class="line">   glutMainLoop();</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    写在Pad上了~</p><h1 id="第9章"><a href="#第9章" class="headerlink" title="第9章"></a>第9章</h1><h2 id="6、在OpenGL中，使用纹理的步骤是什么？纹理坐标和纹理都可以通过程序计算出来，自动生成纹理的原理是什么？"><a href="#6、在OpenGL中，使用纹理的步骤是什么？纹理坐标和纹理都可以通过程序计算出来，自动生成纹理的原理是什么？" class="headerlink" title="6、在OpenGL中，使用纹理的步骤是什么？纹理坐标和纹理都可以通过程序计算出来，自动生成纹理的原理是什么？"></a>6、在OpenGL中，使用纹理的步骤是什么？纹理坐标和纹理都可以通过程序计算出来，自动生成纹理的原理是什么？</h2><p>​    </p><h3 id="使用纹理的步骤（4步，如果导入纹理图像不算的话）-第七版中文版P248"><a href="#使用纹理的步骤（4步，如果导入纹理图像不算的话）-第七版中文版P248" class="headerlink" title="使用纹理的步骤（4步，如果导入纹理图像不算的话）(第七版中文版P248)"></a><strong>使用纹理的步骤</strong>（4步，如果导入纹理图像不算的话）(第七版中文版P248)</h3><ol><li><strong>创建纹理对象并指定该对象的纹理</strong>，绑定bind。</li><li>用纹理坐标指示，<strong>确定纹理如何应用于每个像素</strong>。</li><li><strong>启用纹理贴图功能</strong>。<ol><li>glEnable(GL_TEXTURE_2D);</li></ol></li><li><strong>绘制场景</strong>，<strong>提供纹理和几何坐标</strong>。</li></ol><h3 id="自动生成纹理由glTexGen-函数来实现。要自动生成纹理坐标，首先要指定以什么样的模式来生成纹理坐标。纹理坐标生成模式有："><a href="#自动生成纹理由glTexGen-函数来实现。要自动生成纹理坐标，首先要指定以什么样的模式来生成纹理坐标。纹理坐标生成模式有：" class="headerlink" title="自动生成纹理由glTexGen()函数来实现。要自动生成纹理坐标，首先要指定以什么样的模式来生成纹理坐标。纹理坐标生成模式有："></a>自动生成纹理由glTexGen()函数来实现。要自动生成纹理坐标，首先要指定以什么样的模式来生成纹理坐标。纹理坐标生成模式有：</h3><ol><li><p><strong>GL_TEXTURE_GEN_MODE</strong>和<strong>GL_OBJECT_LINEAR</strong><br>在这个模式下，其纹理生成函数是顶点坐标(x0,y0,z0,w0)的线性组合<br>生成的坐标为：p0<em>x0+p1</em>y0+p2<em>z0+p3</em>w0<br>其中的值是由glTexGen<em>v()函数的param参数提供的。</em></p><p>可以看出：此模式下生成的坐标相当于顶点坐标到特定平面的距离。</p></li><li><p><strong>GL_EYE_LINEAR</strong><br>在这个模式下，其纹理生成函数是顶点的人眼坐标(xe,ye,ze,we)的线性组合<br>生成的坐标为：p0’*xe+p1’*ye+p2’*ze+p3’*we<br>其中:(p0’,p1’,p2’,p3’)=(p0,p1,p2,p3)*inverse(M)</p><p>可以看出：GL_EYE_LINEAR和GL_OBJECT_LINEAR模式具有类似的纹理生成函数，唯一的差别在于GL_OBJECT_LINEAR是物体空间内，在视发生变化的情况下，纹理坐标不会随着视的改变而改变；而GL_EYE_LINEAR是在视空间内，在视发生变化的情况下，纹理坐标会随着视的改变而改变，用而改变贴图后的效果。</p></li><li><p><strong>GL_SPHERE_MAP</strong>和<strong>GL_REFLECTION_MAP</strong><br>主要用于生成球体纹理</p></li><li><p><strong>GL_NORMAL_MAP</strong><br>主要用于生成立方图纹理</p></li></ol><blockquote><p><a href="https://its401.com/article/houdy/145444">https://its401.com/article/houdy/145444</a></p></blockquote><h2 id><a href="#" class="headerlink" title></a></h2><h2 id="7、如何实现纹理的反走样？说明其原理。Mipmap"><a href="#7、如何实现纹理的反走样？说明其原理。Mipmap" class="headerlink" title="7、如何实现纹理的反走样？说明其原理。Mipmap"></a>7、如何实现纹理的反走样？说明其原理。Mipmap</h2><p>​        <strong>走样的一种情况（很大的纹理强行贴到很小的物体上）</strong></p><ul><li><ul><li>有些物体会很远，但其纹理会拥有与近处物体同样高的分辨率。由于远处的物体可能只有很少的像素需要显示，OpenGL从高分辨率纹理中为这些像素获取正确的纹理颜色值就很困难，因为它需要对一个纹理坐标跨度很大的像素只拾取一个纹理颜色。</li><li>举例子：400x400的纹理像素映射在20x20的像素内，一个像素需要映射20x20的纹理像素，如果直接进行纹理映射，那么在使用线性过滤的情况下，只会使用纹理坐标映射点的周围4个纹理像素进行计算，那么其他的396个纹理像素就没了参考价值，浪费显存且取色不精确。</li></ul></li><li><p><strong>多级渐远纹理(Mipmap)反走样</strong></p></li><li><ul><li><p>Mipmap简单来说就是一系列的纹理图像，后一个纹理图像的长和宽是前一个图像的二分之一。多级渐远纹理背后的理念很简单：距观察者的距离超过一定的阈值，OpenGL会使用不同的多级渐远纹理，即最适合物体的距离的那个。</p></li><li><p>使用Mipmap的渲染过程：</p></li><li><ul><li>400x400的纹理需要映射到20x20的物体时，我们会在mipmap纹理中里寻找最接近20x20大小的纹理，并使用此纹理进行采样。</li><li>此时采样用的纹理也是从上一级的纹理采样而来，此多级渐远纹理在之前已经预先插值计算好了20x20大小的纹理颜色，取色的效果比一个像素直接对原图20x20范围直接进行采样要好得多，使用mipmap就避免了采样的纹理像素过少而失真的问题。</li></ul></li></ul></li></ul><p>OpenGL有一个glGenerateMipmaps函数，在创建完一个纹理后调用它OpenGL就会承担接下来的所有工作了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> glTexImage2D(GL_TEXTURE_2D, <span class="number">0</span>, GL_RGB, width, height, <span class="number">0</span>, GL_RGB, GL_UNSIGNED_BYTE, data);</span><br><span class="line">glGenerateMipmap(GL_TEXTURE_2D);</span><br></pre></td></tr></table></figure><h2 id="8、帧缓存有几种，什么叫片元，片元的测试和操作有哪些？明白stencilbuffer的使用。-第七版P310"><a href="#8、帧缓存有几种，什么叫片元，片元的测试和操作有哪些？明白stencilbuffer的使用。-第七版P310" class="headerlink" title="8、帧缓存有几种，什么叫片元，片元的测试和操作有哪些？明白stencilbuffer的使用。(第七版P310)"></a>8、帧缓存有几种，什么叫片元，片元的测试和操作有哪些？明白stencilbuffer的使用。(第七版P310)</h2><h3 id="一、帧缓存有几种（4种）"><a href="#一、帧缓存有几种（4种）" class="headerlink" title="一、帧缓存有几种（4种）"></a><strong>一、帧缓存有几种（4种）</strong></h3><ul><li><p><strong>Color Buffer（颜色缓冲）</strong></p></li><li><ul><li>存储视口中每个像素的颜色</li></ul></li><li><p><strong>Depth Buffer（深度缓冲）</strong></p></li><li><ul><li>存储视口中每个像素的深度</li></ul></li><li><p><strong>Stencil Buffer（模版缓冲）</strong></p><ul><li><strong>用途之一就是把绘画限制在屏幕的某个区域中</strong></li></ul></li><li><ul><li>为视口上的每个像素保存一个无符号整数值</li><li>在渲染过程中，可以用模版缓冲区保存的值与一个预先设定的值相比较，根据比较的结果来决定是否更新颜色缓冲的颜色值。这个比较的过程称为模板测试。</li><li>通过模板测试的像素会允许储存到颜色缓冲中，从而显示出来，而未通过的则不会保存到颜色缓冲区中，从而达到了过滤的功能</li></ul></li><li><p><strong>Accumulation Buffer（累积缓冲）</strong></p><ul><li><strong>通常用于把一系列的图像合成为一幅图像</strong></li></ul></li><li><ul><li>累积缓冲允许你把渲染到颜色缓冲区的值，拷贝到累积缓冲区。</li><li>当我们多次向累积缓冲区内传入颜色数据时，我们可以选择使用不同的方式的把传入累积缓冲区的颜色内容和当前累积缓冲区已有的内容进行混合。</li><li>当我们在累积缓冲区完成多幅图像的混合之后，可以把累积缓冲区的颜色数据复制到颜色缓冲区中。</li></ul></li></ul><h3 id="二、什么叫片元"><a href="#二、什么叫片元" class="headerlink" title="二、什么叫片元"></a>二、<strong>什么叫片元</strong></h3><ul><li>每个片元包含与像素位置对应的坐标位置，颜色和深度的数据</li><li>片元在通过了一系列测试之后就可以在帧缓冲中修改像素的值</li><li>片元本质不是像素，它是潜在的像素。光栅化流程将几何图元分解，覆盖到每个像素，成为像素大小的片元。只有通过光栅化测试后，片元才会成为帧缓冲区的像素。</li></ul><h3 id="三、片元的测试和操作有哪些（4个测试，3个操作）"><a href="#三、片元的测试和操作有哪些（4个测试，3个操作）" class="headerlink" title="三、片元的测试和操作有哪些（4个测试，3个操作）"></a>三、片元的测试和操作有哪些（4个测试，3个操作）</h3><ul><li><p><strong>测试</strong>（有先后顺序，1-4）（写入帧缓冲前）</p></li><li><ul><li><p>1、<strong>裁剪测试</strong> <strong>glScissor()</strong></p></li><li><ul><li>抛弃不位于视景体范围内的片元。</li></ul></li><li><p>2、<strong>alpha测试</strong> <strong>glAlphaFunc()</strong></p></li><li><ul><li>打开alpha测试后，OpenGL会测试每一个片元的Alpha值是否满足某一个特定的条件，如果满足，则该片元保留，如果不满足则抛弃。</li></ul></li><li><p>3、<strong>模版测试</strong> <strong>glStencilFunc()</strong></p></li><li><ul><li>打开模版测试后，OpenGL会比较模版缓冲区保存的值与用户预先设定的值，根据比较的结果来决定片元是否被抛弃。</li></ul></li><li><p>4、<strong>深度测试</strong> <strong>glDepthFunc()</strong></p></li><li><ul><li>打开深度测试后，OpenGL会把该片元的深度值和已经存在于深度缓冲中的深度值进行比较，比较逻辑允许用户自行设置，如果不通过则抛弃该片元。</li></ul></li></ul></li><li><p><strong>操作</strong>（有先后顺序，1-3）（写入帧缓冲后）</p></li><li><ul><li><p>1、<strong>混合操作</strong></p></li><li><ul><li>通过所有测试的片元在写入颜色缓冲区时，片元颜色值和颜色缓冲中已存在的颜色值进行混合运算，决定最终留在屏幕上的颜色是什么，混合方式允许用户自行设置。</li></ul></li><li><p>2、<strong>抖动操作</strong></p></li><li><ul><li>抖动是一种针对对于可用颜色较少的显示系统，以牺牲分辨率为代价，通过颜色值的快速切换闪烁来增加显示颜色数量的技术。抖动操作是和硬件相关的，允许用户所做的操作就只有打开或关闭抖动操作。</li></ul></li><li><p>3、<strong>逻辑操作</strong></p></li><li><ul><li>在片元和帧缓冲区对应的值之间会进行一个逻辑操作，其运算结果将替换掉当前帧缓冲区中对应的值。逻辑运算方式允许用户自行设置。</li></ul></li></ul></li></ul><h3 id="四、StencilBuffer（模版缓冲）的使用-⭐"><a href="#四、StencilBuffer（模版缓冲）的使用-⭐" class="headerlink" title="四、StencilBuffer（模版缓冲）的使用 ⭐"></a>四、StencilBuffer（模版缓冲）的使用 ⭐</h3><ul><li>启用模板缓冲的写入。</li><li>渲染物体，更新模板缓冲的内容。</li><li>禁用模板缓冲的写入。</li><li>渲染（其它）物体，这次根据模板缓冲的内容丢弃特定的片段。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">glEnable(GL_STENCIL_TEST);<span class="comment">//启用模板测试</span></span><br><span class="line">glStencilOp(GL_KEEP, GL_KEEP, GL_REPLACE);<span class="comment">//设置测试通过或失败时的行为</span></span><br><span class="line">glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT | GL_STENCIL_BUFFER_BIT);<span class="comment">//清除颜色缓冲、深度缓冲和模版缓冲</span></span><br><span class="line"></span><br><span class="line">glStencilFunc(GL_ALWAYS, <span class="number">1</span>, <span class="number">0xFF</span>);<span class="comment">//允许所有的片元通过模版测试并修改模板缓冲</span></span><br><span class="line">glStencilMask(<span class="number">0xFF</span>);<span class="comment">//启用模板缓冲写入</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//更改模版缓冲的内容</span></span><br><span class="line"></span><br><span class="line">glStencilFunc(GL_NOTEQUAL, <span class="number">1</span>, <span class="number">0xFF</span>);<span class="comment">//只允许绘制模版缓冲上值为1的对应像素</span></span><br><span class="line">glStencilMask(<span class="number">0x00</span>);<span class="comment">//禁止模板缓冲的写入</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//渲染其他物体</span></span><br></pre></td></tr></table></figure><h2 id="9、请列举出3种以上的三维模型常见的表示格式"><a href="#9、请列举出3种以上的三维模型常见的表示格式" class="headerlink" title="9、请列举出3种以上的三维模型常见的表示格式"></a>9、请列举出3种以上的三维模型常见的表示格式</h2><ul><li>OBJ</li><li>FBX</li><li>STL</li><li>3ds</li><li>DAE</li><li>ABC</li></ul><h2 id="10、已知一个立方体环境映射对应的六个面上的图片"><a href="#10、已知一个立方体环境映射对应的六个面上的图片" class="headerlink" title="10、已知一个立方体环境映射对应的六个面上的图片"></a>10、已知一个立方体环境映射对应的六个面上的图片</h2><p>​    <strong>分别假定为X_POSITVIE_PIC.jpg, X_NEGATIVE_PIC.jpg, Y_POSITIVE_PIC.jpg, Y_NEGATIVE_PIC.jpg, Z_POSITIVE_PIC.jpg, Z_NEGATIVE_PIC.jpg，请用OBJ格式表示一个长度为1的立方体，并把每个面分别贴上给定的六个图片。</strong>（？？？？？）</p><p>​    </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"># 顶点坐标（正方体几何中心在世界坐标原点） # v（vertex）数据段: 模型顶点列表</span><br><span class="line"># 顶点位置信息，是xyz三维坐标</span><br><span class="line"># v开头的每一行描述一个顶点，行数等于顶点数。8个顶点所以有8行</span><br><span class="line">    #Z_NEGATIVE</span><br><span class="line">    v 0.5 -0.5  0.5</span><br><span class="line">    v 0.5 -0.5 -0.5</span><br><span class="line">    v 0.5  0.5 -0.5</span><br><span class="line">    v 0.5  0.5 0.5</span><br><span class="line">    #Z_POSITIVE </span><br><span class="line">    v -0.5 -0.5 0.5</span><br><span class="line">    v -0.5 -0.5 -0.5</span><br><span class="line">    v -0.5  0.5 -0.5</span><br><span class="line">    v -0.5  0.5 0.5</span><br><span class="line">    </span><br><span class="line"># vn（vertex normal）数据段：顶点法线列表</span><br><span class="line"># 三维法向量，xyz</span><br><span class="line"># vn开头的每一行描述一个法向量，行数大于等于顶点数。 前面介绍了，法线是与面相关的概念，但是现在的面是靠顶点来描述，拿示意图中的点&quot;1&quot;为例，它与参与构成了三个面，所以&quot;顶点1&quot;对应有3条法线</span><br><span class="line"># 可能你已经发现了，在这个立方体模型中，共面顶点的法向量的方向是相同的，也就是说这里面的数据会重复，所以在建模软件导出obj文件时有个优化的选项，勾选后的导出的法线列表数据中就不会有重复项，这里的例子优化后有6条法线*</span><br><span class="line"># 顶点法线（实际上并没有用到） </span><br><span class="line">    vn 0 0 -1 </span><br><span class="line">    vn 0 0 1 </span><br><span class="line">    vn 1 0 0 </span><br><span class="line">    vn -1 0 0 </span><br><span class="line">    vn 0 1 0 </span><br><span class="line">    vn 0 -1 0 </span><br><span class="line">    </span><br><span class="line"># vt（vertex texture）数据段：模型顶点的纹理坐标列表</span><br><span class="line"># 顶点的纹理坐标信息，是xy二维坐标</span><br><span class="line"># vt开头的每一行描述一个纹理坐标，行数大于等于顶点数，因为一个模型顶点在贴图的UV坐标系中很可能对应多个顶点/纹理坐标。且坐标值范围是在0~1之间，这个模型中有14行。</span><br><span class="line">    # 纹理坐标（0,0是左下角） </span><br><span class="line">    vt 0.0 0.0 </span><br><span class="line">    vt 0.0 1.0 </span><br><span class="line">    vt 1.0 0.0 </span><br><span class="line">    vt 1.0 1.0 </span><br><span class="line"></span><br><span class="line"># f（face）：模型的三角面列表</span><br><span class="line"># f开头的每一行描述一个面 ，关键的来了，三个点组成一个面，怎样拿到这三个点呢？通过从1开始的索引，去前面的v、vt、vn列表中去取。</span><br><span class="line"># 总结一下就是：每一行定义1个面，1个面包含3个点，1个点具有“顶点/纹理坐标/法线”3个索引值，索引的是前面3个列表的信息。</span><br><span class="line">f  1/1/1  2/2/1  3/3/1      # 顶点1、顶点2、顶点3 组成的面</span><br><span class="line">    # 面的索引（顶点索引/纹理坐标索引/顶点法线索引） </span><br><span class="line">    f 3/1/1 4/2/1 2/3/1 1/4/1 </span><br><span class="line">    f 6/1/2 7/2/2 5/3/2 8/4/2 </span><br><span class="line">    f 7/1/3 8/2/3 3/3/3 4/4/3 </span><br><span class="line">    f 2/1/4 1/2/4 6/3/4 5/4/4 </span><br><span class="line">    f 4/1/5 8/2/5 1/3/5 5/4/5 </span><br><span class="line">    f 6/1/6 7/2/6 2/3/6 6/4/6</span><br></pre></td></tr></table></figure><h2 id="11、分析下面的程序并计算"><a href="#11、分析下面的程序并计算" class="headerlink" title="11、分析下面的程序并计算"></a>11、分析下面的程序并计算</h2><p>​    <strong>在下面的例子中，计算对应1234四个顶点所对应的四边形上的一个点（-1.0, 0.5, 0.0）对应的纹理坐标是多少？按照最近邻域滤波方法，该点对应的颜色是什么？</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*Create checkerboard texture*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>checkImageWidth 64</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>checkImageHeight 64</span></span><br><span class="line"><span class="keyword">static</span> GLubyte checkImage[checkImageHeight][checkImageWidth][<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> GL_VERSION_1_1</span></span><br><span class="line"><span class="keyword">static</span> GLuint texName;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//生成8X8的黑白相间棋盘格子</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">makeCheckImage</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">int</span> i, j, c;</span><br><span class="line">   <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; checkImageHeight; i++)</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; checkImageWidth; j++)</span><br><span class="line">      &#123;</span><br><span class="line">         c = ((((i &amp; <span class="number">0x8</span>) == <span class="number">0</span>) ^ ((j &amp; <span class="number">0x8</span>)) == <span class="number">0</span>)) * <span class="number">255</span>;</span><br><span class="line">         checkImage[i][j][<span class="number">0</span>] = (GLubyte) c;</span><br><span class="line">         checkImage[i][j][<span class="number">1</span>] = (GLubyte) c;</span><br><span class="line">         checkImage[i][j][<span class="number">2</span>] = (GLubyte) c;</span><br><span class="line">         checkImage[i][j][<span class="number">3</span>] = (GLubyte) <span class="number">255</span>;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   glClearColor (<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>);</span><br><span class="line">   glShadeModel(GL_FLAT);</span><br><span class="line">   glEnable(GL_DEPTH_TEST);</span><br><span class="line"></span><br><span class="line">   makeCheckImage();</span><br><span class="line">   glPixelStorei(GL_UNPACK_ALIGNMENT, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> GL_VERSION_1_1</span></span><br><span class="line">   glGenTextures(<span class="number">1</span>, &amp;texName);</span><br><span class="line">   glBindTexture(GL_TEXTURE_2D, texName);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">   glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);</span><br><span class="line">   glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);</span><br><span class="line">   glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);</span><br><span class="line">   glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> GL_VERSION_1_1</span></span><br><span class="line">   glTexImage2D(GL_TEXTURE_2D, <span class="number">0</span>, GL_RGBA, checkImageWidth, checkImageHeight, <span class="number">0</span>, GL_RGBA, GL_UNSIGNED_BYTE, checkImage);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">   glTexImage2D(GL_TEXTURE_2D, <span class="number">0</span>, <span class="number">4</span>, checkImageWidth, checkImageHeight, <span class="number">0</span>, GL_RGBA, GL_UNSIGNED_BYTE, checkImage);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);</span><br><span class="line">   glEnable(GL_TEXTURE_2D);</span><br><span class="line">   glTexEnvf(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_DECAL);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> GL_VERSION_1_1</span></span><br><span class="line">   glBindTexture(GL_TEXTURE_2D, texName);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">   glBegin(GL_QUADS);</span><br><span class="line">   <span class="comment">//第一个</span></span><br><span class="line">   glTexCoord2f(<span class="number">0.0</span>, <span class="number">0.0</span>); glVertex3f(<span class="number">-2.0</span>, <span class="number">-1.0</span>, <span class="number">0.0</span>);</span><br><span class="line">   <span class="comment">//第二个</span></span><br><span class="line">   glTexCoord2f(<span class="number">0.0</span>, <span class="number">1.0</span>); glVertex3f(<span class="number">-2.0</span>, <span class="number">1.0</span>, <span class="number">0.0</span>);</span><br><span class="line">   <span class="comment">//第三个</span></span><br><span class="line">   glTexCoord2f(<span class="number">1.0</span>, <span class="number">1.0</span>); glVertex3f(<span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">0.0</span>);</span><br><span class="line">   <span class="comment">//第四个</span></span><br><span class="line">   glTexCoord2f(<span class="number">1.0</span>, <span class="number">0.0</span>); glVertex3f(<span class="number">0.0</span>, <span class="number">-1.0</span>, <span class="number">0.0</span>);</span><br><span class="line"></span><br><span class="line">   glTexCoord2f(<span class="number">0.0</span>, <span class="number">0.0</span>); glVertex3f(<span class="number">1.0</span>, <span class="number">-1.0</span>, <span class="number">0.0</span>);</span><br><span class="line">   glTexCoord2f(<span class="number">0.0</span>, <span class="number">1.0</span>); glVertex3f(<span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">0.0</span>);</span><br><span class="line">   glTexCoord2f(<span class="number">1.0</span>, <span class="number">1.0</span>); glVertex3f(<span class="number">2.41421</span>, <span class="number">1.0</span>, <span class="number">-1.41421</span>);</span><br><span class="line">   glTexCoord2f(<span class="number">1.0</span>, <span class="number">0.0</span>); glVertex3f(<span class="number">2.41421</span>, <span class="number">-1.0</span>, <span class="number">-1.41421</span>);</span><br><span class="line">   glEnd();</span><br><span class="line">   glFlush();</span><br><span class="line">   glDisable(GL_TEXTURE_2D);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reshape</span><span class="params">(<span class="keyword">int</span> w, <span class="keyword">int</span> h)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   glViewport(<span class="number">0</span>, <span class="number">0</span>, (GLsizei) w, (GLsizei) h);</span><br><span class="line">   glMatrixMode(GL_PROJECTION);</span><br><span class="line">   glLoadIdentity();</span><br><span class="line">   gluPerspective(<span class="number">60.0</span>, (GLfloat) w/(GLfloat) h, <span class="number">1.0</span>, <span class="number">30.0</span>);</span><br><span class="line">   glMatrixMode(GL_MODELVIEW);</span><br><span class="line">   glLoadIdentity();</span><br><span class="line">   glTranslatef(<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">-3.6</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">keyboard</span> <span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> key, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">switch</span> (key) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">27</span>:</span><br><span class="line">         <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">         <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">         <span class="keyword">break</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   glutInit(&amp;argc, argv);</span><br><span class="line">   glutInitDisplayMode(GLUT_SINGLE | GLUT_RGB | GLUT_DEPTH);</span><br><span class="line">   glutInitWindowSize(<span class="number">250</span>, <span class="number">250</span>);</span><br><span class="line">   glutInitWindowPosition(<span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line">   glutCreateWindow(argv[<span class="number">0</span>]);</span><br><span class="line">   init();</span><br><span class="line">   glutDisplayFunc(display);</span><br><span class="line">   glutReshapeFunc(reshape);</span><br><span class="line">   glutKeyboardFunc(keyboard);</span><br><span class="line">   glutMainLoop();</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="12、采用GPU编程，请说明Vertex-Shader-和-Fragment-Shader-的输入输出坐标系是什么-输入输出的主要参数是什么？"><a href="#12、采用GPU编程，请说明Vertex-Shader-和-Fragment-Shader-的输入输出坐标系是什么-输入输出的主要参数是什么？" class="headerlink" title="12、采用GPU编程，请说明Vertex Shader 和 Fragment Shader 的输入输出坐标系是什么? 输入输出的主要参数是什么？"></a>12、采用GPU编程，请说明Vertex Shader 和 Fragment Shader 的输入输出坐标系是什么? 输入输出的主要参数是什么？</h2><h3 id="一、Vertex-Shader"><a href="#一、Vertex-Shader" class="headerlink" title="一、Vertex Shader"></a>一、Vertex Shader</h3><ul><li><p>输入的是局部空间坐标 世界空间 （<strong>顶点坐标从模型空间变换到裁切空间</strong>）</p></li><li><p>输出的是裁剪空间坐标</p></li><li><p>主要输入参数</p></li><li><ul><li><p>用户定义的顶点属性</p></li><li><p>用户定义的uniform变量</p></li><li><p>内置的属性输入变量</p></li><li><ul><li>gl_Vertex</li><li>gl_Normal</li><li>gl_Color</li><li>gl_SecondaryColor</li><li>gl_TexCoordn</li><li>gl_FogCoord</li></ul></li></ul></li><li><p>主要输出参数</p></li><li><ul><li><p>用户定义的varying变量</p></li><li><p>内置的属性输出变量</p></li><li><ul><li><p>gl_Position</p></li><li><p>gl_FrontColor</p></li><li><p>gl_BackColor</p></li><li><p>gl_FrontSecondaryColor</p></li><li><p>gl_BackSecondaryColor</p></li><li><p>gl_TexCoord[n]</p></li><li><p>gl_FogFragCoord</p></li><li><p>gl_PointSize</p></li><li><p>gl_ClipVertex</p><img src="/2022/01/06/OpenGL%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E6%8F%90%E7%BA%B2/image-20220109001917728.png" class title="image-20220109001917728"></li></ul></li></ul></li></ul><h3 id="二、Fragment-Shader"><a href="#二、Fragment-Shader" class="headerlink" title="二、Fragment Shader"></a>二、Fragment Shader</h3><ul><li><p>输入的是屏幕空间坐标（顶点着色器到片元着色器之间，裁剪空间坐标会转换到标准化设备坐标（NDC），再转换到屏幕空间坐标，这过程是无法编程的）</p></li><li><p>屏幕空间坐标(应该)</p></li><li><p>主要输入参数</p></li><li><ul><li><p>用户定义的顶点属性</p></li><li><p>用户定义的uniform变量</p></li><li><p>内置的属性输入变量</p></li><li><ul><li>gl_FragCoord</li><li>gl_Color</li><li>gl_SecondaryColor</li><li>gl_TexCoord[n]</li><li>gl_FogFragCoord</li><li>gl_FrontFacing</li></ul></li></ul></li><li><p>主要输出参数</p></li><li><ul><li><p>discard fragment被丢弃的片元</p></li><li><p>内置的属性输出变量</p></li><li><ul><li>gl_FragColor</li><li>gl_FragDepth</li><li>gl_FragData[n]</li></ul></li><li><img src="/2022/01/06/OpenGL%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E6%8F%90%E7%BA%B2/image-20220109001941440.png" class title="image-20220109001941440"></li></ul></li></ul><blockquote><p><a href="https://hello-david.github.io/archives/e8814f3.html">https://hello-david.github.io/archives/e8814f3.html</a></p></blockquote><h2 id="13、在shader编程中，如何使用多重纹理。"><a href="#13、在shader编程中，如何使用多重纹理。" class="headerlink" title="13、在shader编程中，如何使用多重纹理。"></a>13、在shader编程中，如何使用<strong>多重</strong>纹理。</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////片源着色器中</span></span><br><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line">    in vec2 tex_coord0;</span><br><span class="line">    in vec2 tex_coord1;</span><br><span class="line">    layout (location = <span class="number">0</span>) out vec4 color;</span><br><span class="line">    uniform sampler2D tex1;<span class="comment">//第一个2D纹理采样对象</span></span><br><span class="line">    uniform sampler2D tex2;<span class="comment">//第二个2D纹理采样对象</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        color = texture(tex1, tex_coord0) + texture(tex2, tex_coord1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////Main程序中</span></span><br><span class="line"> GLuint tex1,tex2;<span class="comment">//主程序中纹理的id</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建纹理tex1</span></span><br><span class="line">glGenTextures(<span class="number">1</span>, &amp;tex1);</span><br><span class="line">glBindTexture(GL_TEXTURE_2D, tex1);</span><br><span class="line">glTexImage2D(GL_TEXTURE_2D, <span class="number">0</span>, GL_RGB, width, height, <span class="number">0</span>, GL_BGR, GL_UNSIGNED_BYTE, data1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设定纹理过滤与纹理环绕方式</span></span><br><span class="line">glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);</span><br><span class="line">glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);</span><br><span class="line">glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);</span><br><span class="line">glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR);</span><br><span class="line">glGenerateMipmap(GL_TEXTURE_2D);</span><br><span class="line"></span><br><span class="line">     <span class="comment">//创建纹理tex2</span></span><br><span class="line">glGenTextures(<span class="number">1</span>, &amp;tex2);</span><br><span class="line">glBindTexture(GL_TEXTURE_2D, tex2);</span><br><span class="line">glTexImage2D(GL_TEXTURE_2D, <span class="number">0</span>, GL_RGB, width, height, <span class="number">0</span>, GL_BGR, GL_UNSIGNED_BYTE, data2);</span><br><span class="line"></span><br><span class="line">glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);</span><br><span class="line">glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);</span><br><span class="line">glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);</span><br><span class="line">glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR);</span><br><span class="line">glGenerateMipmap(GL_TEXTURE_2D);</span><br><span class="line"></span><br><span class="line">    glUseProgram(prog); <span class="comment">//prog是已绑定顶点和片元着色器的链接程序</span></span><br><span class="line"></span><br><span class="line">    GLint tex1_uniform_loc = glGetUniformLocation(prog, <span class="string">&quot;tex1&quot;</span>);<span class="comment">//对于第一个纹理，我们需要获取到片元着色器中第一个纹理采样对象（uniform sampler2D tex1）</span></span><br><span class="line">    glUniform1i(tex1_uniform_loc, <span class="number">0</span>);<span class="comment">//指定这个纹理采样对象使用0这个值</span></span><br><span class="line">    glActiveTexture(GL_TEXTURE0);<span class="comment">//激活GL_TEXTURE0纹理单元</span></span><br><span class="line">    glBindTexture(GL_TEXTURE_2D, tex1);<span class="comment">//把tex1纹理绑定到激活的纹理单元上</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//重复操作</span></span><br><span class="line">    GLint tex2_uniform_loc = glGetUniformLocation(prog, <span class="string">&quot;tex2&quot;</span>);<span class="comment">//uniform sampler2D tex2</span></span><br><span class="line">    glUniform1i(tex2_uniform_loc, <span class="number">1</span>);</span><br><span class="line">    glActiveTexture(GL_TEXTURE1);<span class="comment">//这里激活了另一个纹理对象</span></span><br><span class="line">    glBindTexture(GL_TEXTURE_2D, tex2);<span class="comment">//把第二个纹理绑定上去</span></span><br></pre></td></tr></table></figure><blockquote><p>或者去看<a href="https://learnopengl-cn.github.io/02%20Lighting/04%20Lighting%20maps/#:~:text=%E5%BA%A6%E5%B0%B1%E5%A5%BD%E4%BA%86%E3%80%82-,%E9%87%87%E6%A0%B7%E9%95%9C%E9%9D%A2%E5%85%89%E8%B4%B4%E5%9B%BE,-%E9%95%9C%E9%9D%A2%E5%85%89">https://learnopengl-cn.github.io/02%20Lighting/04%20Lighting%20maps/#:~:text=%E5%BA%A6%E5%B0%B1%E5%A5%BD%E4%BA%86%E3%80%82-,%E9%87%87%E6%A0%B7%E9%95%9C%E9%9D%A2%E5%85%89%E8%B4%B4%E5%9B%BE,-%E9%95%9C%E9%9D%A2%E5%85%89</a></p></blockquote><h2 id="14、在Compute-Shader中，-workgroup-和-工作单元等的关系"><a href="#14、在Compute-Shader中，-workgroup-和-工作单元等的关系" class="headerlink" title="14、在Compute Shader中， workgroup 和 工作单元等的关系"></a>14、在Compute Shader中， workgroup 和 工作单元等的关系</h2><img src="/2022/01/06/OpenGL%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E6%8F%90%E7%BA%B2/image-20220109005651316.png" class title="image-20220109005651316"><p>​    在计算着色器中，并行性更为直接：任务以组为单位进行执行，称为<strong>工作组（workgroup）</strong>。</p><p>​    拥有邻居的工作组杯称为<strong>本地工作组（local workgroup）</strong>。</p><p>​    这些本地工作组可以组成更大的组，称为<strong>全局工作组（global workgroup）</strong>，通常作为执行命令的一个单位。</p><p>​    <strong>计算着色器会被全局工作组中的每一个本地工作组中的每一个单元调用一次</strong>。工作组的每一个单元被称为<strong>工作项（work item）</strong>。每一次调用被称为一次执行，工作项之间可以通过变量和显存进行通信。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 430 core<span class="comment">//xyz声明了本地工作组的大小，如果忽略z，就是xy的二维工作组</span></span></span><br><span class="line">layout (local_size_x = <span class="number">32</span>, local_size_y = <span class="number">32</span>, local_size_z = <span class="number">32</span>) in;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Do nothing</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>一个4x4x1全局工作组示例，一个全局工作组内包含若干个局部工作组，在一个局部工作组内又会包含多个工作单元。</strong></p><p>事实上它们都是3维的，为了适应1维、2维的任务，只需把额外的2维或1维设为0即可。</p><p><strong>计算着色器有5个内建变量</strong>：</p><ul><li>1、<strong>本地工作组</strong>的大小（三维向量）（gl_WorkGroupSize），就是上述的local_size_x/y/z</li><li>2、全局工作组的大小（三维向量）（gl_NumWorkGroups）</li><li>3、当前工作单元在本地工作组中的坐标（三维向量）（gl_LocalInvocationID）</li><li>4、本地工作组在全局工作组中的坐标（三维向量）（gl_WorkGroupID）</li></ul><p>基于上面三个还能进一步算出：</p><ul><li>5、工作单元在全局工作组的三维索引（三维向量）（gl_GlobalInvocationID）</li><li>6、工作单元在本地工作组的一维索引（一维的值）（gl_LocalInvocationIndex）</li></ul><blockquote><p><a href="https://www.jianshu.com/p/9881630fb542">https://www.jianshu.com/p/9881630fb542</a></p></blockquote><h2 id="15、Buffer-Texture-Buffer-Image-Buffer-之间的区别和联系"><a href="#15、Buffer-Texture-Buffer-Image-Buffer-之间的区别和联系" class="headerlink" title="15、Buffer, Texture Buffer, Image Buffer 之间的区别和联系"></a>15、Buffer, Texture Buffer, Image Buffer 之间的区别和联系</h2><ol><li>   Texture buffer 和 image buffer都是BUFFER大类的子项</li><li>   对于多实例绘制，在shader里，Texture Buffer的程序需要采用texelFetch(samplerBuffer的实例 , 索引)去获取纹理，而image buffer则是调用imageload(imagebuffer的实例,索引).</li><li>   在主程序中，Texture Buffer的程序多通过uniform的形式将纹理缓冲传入shader，而image buffer则是调用glBindImageTexture ,(相应的shader里就需要布局（layout(rgba32f,binding=1)uniform imagebuffer …）)</li></ol><h2 id="16、Shader和主程序之间如何传递数据。"><a href="#16、Shader和主程序之间如何传递数据。" class="headerlink" title="16、Shader和主程序之间如何传递数据。"></a>16、Shader和主程序之间如何传递数据。</h2><h3 id="一、使用location这一元数据指定输入的-Attribute变量"><a href="#一、使用location这一元数据指定输入的-Attribute变量" class="headerlink" title="一、使用location这一元数据指定输入的 Attribute变量"></a>一、使用<code>location</code>这一元数据指定输入的 Attribute变量</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *vertexShaderSource =<span class="string">&quot;#version 330 core\n&quot;</span></span><br><span class="line">    <span class="string">&quot;layout (location = 0) in vec3 aPos;\n&quot;</span></span><br><span class="line">    <span class="string">&quot;layout (location = 1) in vec3 aColor;\n&quot;</span></span><br><span class="line">    <span class="string">&quot;out vec3 ourColor;\n&quot;</span></span><br><span class="line">    <span class="string">&quot;void main()\n&quot;</span></span><br><span class="line">    <span class="string">&quot;&#123;\n&quot;</span></span><br><span class="line">    <span class="string">&quot;   gl_Position = vec4(aPos, 1.0);\n&quot;</span></span><br><span class="line">    <span class="string">&quot;   ourColor = aColor;\n&quot;</span></span><br><span class="line">    <span class="string">&quot;&#125;\0&quot;</span>;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> <span class="keyword">unsigned</span> <span class="keyword">int</span> VBO, VAO;</span><br><span class="line">    glGenVertexArrays(<span class="number">1</span>, &amp;VAO);</span><br><span class="line">    glGenBuffers(<span class="number">1</span>, &amp;VBO);</span><br><span class="line">    <span class="comment">// bind the Vertex Array Object first, then bind and set vertex buffer(s), and then configure vertex attributes(s).</span></span><br><span class="line">    glBindVertexArray(VAO);</span><br><span class="line"></span><br><span class="line">    glBindBuffer(GL_ARRAY_BUFFER, VBO);</span><br><span class="line">    glBufferData(GL_ARRAY_BUFFER, <span class="keyword">sizeof</span>(vertices), vertices, GL_STATIC_DRAW);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// position attribute</span></span><br><span class="line">    glVertexAttribPointer(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">6</span> * <span class="keyword">sizeof</span>(<span class="keyword">float</span>), (<span class="keyword">void</span>*)<span class="number">0</span>);</span><br><span class="line">    glEnableVertexAttribArray(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// color attribute</span></span><br><span class="line">    glVertexAttribPointer(<span class="number">1</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">6</span> * <span class="keyword">sizeof</span>(<span class="keyword">float</span>), (<span class="keyword">void</span>*)(<span class="number">3</span> * <span class="keyword">sizeof</span>(<span class="keyword">float</span>)));</span><br><span class="line">    glEnableVertexAttribArray(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><h3 id="二、Uniform变量"><a href="#二、Uniform变量" class="headerlink" title="二、Uniform变量"></a>二、Uniform变量</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">uniform <span class="keyword">float</span> myUniform1;</span><br><span class="line"> layout (location = <span class="number">17</span>) uniform vec4 myUniform2;<span class="comment">//指定位置的Uniform变量</span></span><br><span class="line"> <span class="comment">//获取uniform变量位置</span></span><br><span class="line"> GLint myUniform1Location = glGetUniformLocation(myProgram, <span class="string">&quot;myUniform1&quot;</span>);</span><br><span class="line"></span><br><span class="line"> glUseProgram(myProgram);</span><br><span class="line"> <span class="comment">//根据glGetUniformLocation函数获取的位置向着色器传值</span></span><br><span class="line"> glUniform1f(myUniform1Location, <span class="number">45.2f</span>);</span><br><span class="line"> <span class="comment">//或者直接对指定位置传值</span></span><br><span class="line"> glUniform4f(<span class="number">17</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>);</span><br></pre></td></tr></table></figure><h3 id="三、使用Uniform-Block-（UBO）"><a href="#三、使用Uniform-Block-（UBO）" class="headerlink" title="三、使用Uniform Block （UBO）"></a>三、使用Uniform Block （UBO）</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//layout(std140)语句告诉OpenGL这个Uniform块使用的是std140布局</span></span><br><span class="line">  layout (std140) uniform ExampleBlock</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="keyword">float</span> value;</span><br><span class="line">       vec3 <span class="built_in">vector</span>;</span><br><span class="line">       mat4 matrix;</span><br><span class="line">       <span class="keyword">float</span> values[<span class="number">3</span>];</span><br><span class="line">       <span class="keyword">bool</span> boolean;</span><br><span class="line">       <span class="keyword">int</span> integer;</span><br><span class="line">   &#125;;</span><br><span class="line">  <span class="comment">//使用Uniform缓冲对象UBO</span></span><br><span class="line">   GLuint uboExampleBlock;</span><br><span class="line">   glGenBuffers(<span class="number">1</span>, &amp;uboExampleBlock);</span><br><span class="line">   glBindBuffer(GL_UNIFORM_BUFFER, uboExampleBlock);</span><br><span class="line">   glBufferData(GL_UNIFORM_BUFFER, <span class="number">150</span>, <span class="literal">NULL</span>, GL_STATIC_DRAW); <span class="comment">// 分配150个字节的内存空间</span></span><br><span class="line">   glBindBuffer(GL_UNIFORM_BUFFER, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">   <span class="comment">//通过UniformBlock的名字找到对应的索引</span></span><br><span class="line">   GLuint block_index = glGetUniformBlockIndex(ProgramID, <span class="string">&quot;ExampleBlock&quot;</span>);</span><br><span class="line">   <span class="comment">//把ExampleBlock绑定到0号绑定点上</span></span><br><span class="line">   glUniformBlockBinding(ProgramID, block_index, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">   <span class="comment">//把Uniform缓冲对象绑定到同样的绑定点上</span></span><br><span class="line">   glBindBufferBase(GL_UNIFORM_BUFFER, <span class="number">0</span>, uboExampleBlock);</span><br><span class="line">   <span class="comment">// 或者</span></span><br><span class="line">   glBindBufferRange(GL_UNIFORM_BUFFER, <span class="number">0</span>, uboExampleBlock, <span class="number">0</span>, <span class="number">150</span>);</span><br><span class="line"></span><br><span class="line">   <span class="comment">//修改UBO内的数据来更新UniformBlock</span></span><br><span class="line">   glBindBuffer(GL_UNIFORM_BUFFER, uboExampleBlock);</span><br><span class="line">   GLint b = <span class="literal">true</span>; <span class="comment">//GLSL中的布尔值是4个字节大小</span></span><br><span class="line">   glBufferSubData(GL_UNIFORM_BUFFER, <span class="number">142</span>, <span class="number">4</span>, &amp;b);</span><br><span class="line">   glBindBuffer(GL_UNIFORM_BUFFER, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><h3 id="注：Varying变量不是着色器与程序传递数据"><a href="#注：Varying变量不是着色器与程序传递数据" class="headerlink" title="注：Varying变量不是着色器与程序传递数据"></a>注：Varying变量不是着色器与程序传递数据</h3><h3 id="varying：在顶点着色器和片元着色器中传递参数，在顶点着色器中被修改，在片元着色器中只读。"><a href="#varying：在顶点着色器和片元着色器中传递参数，在顶点着色器中被修改，在片元着色器中只读。" class="headerlink" title="varying：在顶点着色器和片元着色器中传递参数，在顶点着色器中被修改，在片元着色器中只读。"></a>varying：在顶点着色器和片元着色器中传递参数，在顶点着色器中被修改，在片元着色器中只读。</h3>]]></content>
      
      
      
        <tags>
            
            <tag> OpenGL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【OpenGL】期末汇总2-纹理</title>
      <link href="/2022/01/02/OpenGL%E6%9C%9F%E6%9C%AB%E6%B1%87%E6%80%BB2/"/>
      <url>/2022/01/02/OpenGL%E6%9C%9F%E6%9C%AB%E6%B1%87%E6%80%BB2/</url>
      
        <content type="html"><![CDATA[<p>hh我又来了</p><p>上一章讲了VAO、VBO、EBO和Shader的内容，这节课我们来学习纹理咯~</p><h2 id="1、导入纹理资源"><a href="#1、导入纹理资源" class="headerlink" title="1、导入纹理资源"></a>1、导入纹理资源</h2><p>​    这里我们选用了stb_image.h（一个非常流行的单头文件图像加载库）进行导入。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STB_IMAGE_IMPLEMENTATION</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stb_image.h&quot;</span></span></span><br><span class="line"><span class="keyword">int</span> width, height, nrChannels;</span><br><span class="line"><span class="comment">//这个函数首先接受一个图像文件的位置作为输入。</span></span><br><span class="line"><span class="comment">//接下来它需要三个int作为它的第二、第三和第四个参数，stb_image.h将会用图像的宽度、高度和颜色通道的个数填充这三个变量。</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> *data = stbi_load(<span class="string">&quot;container.jpg&quot;</span>, &amp;width, &amp;height, &amp;nrChannels, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>​    在成功导入纹理之后，我们要做的就是生成纹理了！</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//有点类似之前的VAOVBO</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> texture;</span><br><span class="line"><span class="comment">//需要输入生成纹理的数量，然后把它们储存在第二个参数的unsigned int数组中</span></span><br><span class="line">glGenTextures(<span class="number">1</span>, &amp;texture);</span><br><span class="line"><span class="comment">//需要绑定它，让之后任何的纹理指令都可以配置当前绑定的纹理：</span></span><br><span class="line">glBindTexture(GL_TEXTURE_2D, texture);</span><br><span class="line"><span class="comment">//然后就可以通过glTexImage2D来生成纹理了</span></span><br><span class="line">glTexImage2D(GL_TEXTURE_2D, <span class="number">0</span>, GL_RGB, width, height, <span class="number">0</span>, GL_RGB, GL_UNSIGNED_BYTE, data);</span><br><span class="line">glGenerateMipmap(GL_TEXTURE_2D);</span><br><span class="line"><span class="comment">//当调用glTexImage2D时，当前绑定的纹理对象就会被附加上纹理图像</span></span><br><span class="line"><span class="comment">//如需要多级渐变纹理，需要多次调用，或者，直接在生成纹理之后调用glGenerateMipmap。这会为当前绑定的纹理自动生成所有需要的多级渐远纹理。</span></span><br><span class="line"><span class="comment">//释放图像的内存</span></span><br><span class="line">stbi_image_free(data);</span><br></pre></td></tr></table></figure><blockquote><ul><li>glTexImage2D（）函数的解读</li><li>第一个参数指定了纹理目标(Target)。设置为GL_TEXTURE_2D意味着会生成与当前绑定的纹理对象在同一个目标上的纹理（任何绑定到GL_TEXTURE_1D和GL_TEXTURE_3D的纹理不会受到影响）。</li><li>第二个参数为纹理指定多级渐远纹理的级别，如果你希望单独手动设置每个多级渐远纹理的级别的话。这里我们填0，也就是基本级别。</li><li>第三个参数告诉OpenGL我们希望把纹理储存为何种格式。我们的图像只有<code>RGB</code>值，因此我们也把纹理储存为<code>RGB</code>值。</li><li>第四个和第五个参数设置最终的纹理的宽度和高度。我们之前加载图像的时候储存了它们，所以我们使用对应的变量。</li><li>下个参数应该总是被设为<code>0</code>（历史遗留的问题）。</li><li>第七第八个参数定义了源图的格式和数据类型。我们使用RGB值加载这个图像，并把它们储存为<code>char</code>(byte)数组，我们将会传入对应值。</li><li>最后一个参数是真正的图像数据。</li></ul></blockquote><h2 id="2、应用纹理！"><a href="#2、应用纹理！" class="headerlink" title="2、应用纹理！"></a>2、应用纹理！</h2><p>​    我们直接在顶点坐标里加入纹理坐标！</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> vertices[] = &#123;</span><br><span class="line"><span class="comment">//     ---- 位置 ----       ---- 颜色 ----     - 纹理坐标 -</span></span><br><span class="line">     <span class="number">0.5f</span>,  <span class="number">0.5f</span>, <span class="number">0.0f</span>,   <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>,   <span class="number">1.0f</span>, <span class="number">1.0f</span>,   <span class="comment">// 右上</span></span><br><span class="line">     <span class="number">0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,   <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>,   <span class="number">1.0f</span>, <span class="number">0.0f</span>,   <span class="comment">// 右下</span></span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,   <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>,   <span class="number">0.0f</span>, <span class="number">0.0f</span>,   <span class="comment">// 左下</span></span><br><span class="line">    <span class="number">-0.5f</span>,  <span class="number">0.5f</span>, <span class="number">0.0f</span>,   <span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>,   <span class="number">0.0f</span>, <span class="number">1.0f</span>    <span class="comment">// 左上</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//随之而来，我们需要更新输入的函数</span></span><br><span class="line"><span class="comment">//之前的省略一下......</span></span><br><span class="line">glVertexAttribPointer(<span class="number">2</span>, <span class="number">2</span>, GL_FLOAT, GL_FALSE, <span class="number">8</span> * <span class="keyword">sizeof</span>(<span class="keyword">float</span>), (<span class="keyword">void</span>*)(<span class="number">6</span> * <span class="keyword">sizeof</span>(<span class="keyword">float</span>)));</span><br><span class="line">glEnableVertexAttribArray(<span class="number">2</span>);</span><br></pre></td></tr></table></figure><p>​    同样的，调整俩个着色器！</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"><span class="keyword">layout</span> (<span class="keyword">location</span> = <span class="number">0</span>) <span class="keyword">in</span> <span class="type">vec3</span> aPos;</span><br><span class="line"><span class="keyword">layout</span> (<span class="keyword">location</span> = <span class="number">1</span>) <span class="keyword">in</span> <span class="type">vec3</span> aColor;</span><br><span class="line"><span class="keyword">layout</span> (<span class="keyword">location</span> = <span class="number">2</span>) <span class="keyword">in</span> <span class="type">vec2</span> aTexCoord;</span><br><span class="line"></span><br><span class="line"><span class="keyword">out</span> <span class="type">vec3</span> ourColor;</span><br><span class="line"><span class="keyword">out</span> <span class="type">vec2</span> TexCoord;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">gl_Position</span> = <span class="type">vec4</span>(aPos, <span class="number">1.0</span>);</span><br><span class="line">    ourColor = aColor;</span><br><span class="line">    TexCoord = aTexCoord;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    但是，我们需要把纹理对象传入到fragment着色器上去，怎么才能实现呢？</p><p>​    GLSL有一个供纹理对象使用的内建数据类型，叫做**采样器(Sampler)**，它以纹理类型作为后缀，比如例子中的 sampler2D ourTexture，我们可以说明uniform，然后在外部传入纹理对象！</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"><span class="keyword">out</span> <span class="type">vec4</span> FragColor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">in</span> <span class="type">vec3</span> ourColor;</span><br><span class="line"><span class="keyword">in</span> <span class="type">vec2</span> TexCoord;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">sampler2D</span> ourTexture;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    FragColor = <span class="built_in">texture</span>(ourTexture, TexCoord);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3、停-在下一步之前加点新东西吧—纹理环绕方式"><a href="#3、停-在下一步之前加点新东西吧—纹理环绕方式" class="headerlink" title="3、停!在下一步之前加点新东西吧—纹理环绕方式"></a>3、停!在下一步之前加点新东西吧—纹理环绕方式</h2><p>​    纹理坐标的范围通常是从(0, 0)到(1, 1)，那如果我们把纹理坐标设置在范围之外会发生什么？OpenGL默认的行为是重复这个纹理图像，但是也有更多选择！</p><img src="/2022/01/02/OpenGL%E6%9C%9F%E6%9C%AB%E6%B1%87%E6%80%BB2/image-20220102225201158.png" class title="image-20220102225201158"><p>​    可以在绑定纹理对象之后使用这个函数进行改变：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//可以使用glTexParameter*函数对单独的一个坐标轴设置（s、t（如果是使用3D纹理那么还有一个r）它们和x、y、z是等价的）</span></span><br><span class="line">glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_MIRRORED_REPEAT);</span><br><span class="line">glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_MIRRORED_REPEAT);</span><br><span class="line"></span><br><span class="line"><span class="comment">//上文选择了GL_MIRRORED_REPEAT，如果我们选择GL_CLAMP_TO_BORDER选项，我们还需要指定一个边缘的颜色。这需要使用glTexParameter函数的fv后缀形式，用GL_TEXTURE_BORDER_COLOR作为它的选项，并且传递一个float数组作为边缘的颜色值：</span></span><br><span class="line"><span class="keyword">float</span> borderColor[] = &#123; <span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span> &#125;;</span><br><span class="line">glTexParameterfv(GL_TEXTURE_2D, GL_TEXTURE_BORDER_COLOR, borderColor);</span><br></pre></td></tr></table></figure><p>​    </p><h2 id="4、再来点–纹理过滤"><a href="#4、再来点–纹理过滤" class="headerlink" title="4、再来点–纹理过滤"></a>4、再来点–纹理过滤</h2><p>​    纹理过滤是对于你给定的纹理坐标和纹理本身的像素不对等而产生的弥补方法。例如，你发现你的两个相邻的纹理坐标，对应到纹理像素上都是一个像素，那我到底怎么取呢？这就用到了纹理过滤。</p><p>​    GL_NEAREST（也叫邻近过滤，Nearest Neighbor Filtering）是OpenGL默认的纹理过滤方式，OpenGL会选择中心点最接近纹理坐标的那个像素。</p><img src="/2022/01/02/OpenGL%E6%9C%9F%E6%9C%AB%E6%B1%87%E6%80%BB2/filter_nearest.png" class title="img"><p>​    GL_LINEAR（也叫线性过滤，(Bi)linear Filtering）它会基于纹理坐标附近的纹理像素，计算出一个插值，近似出这些纹理像素之间的颜色。一个纹理像素的中心距离纹理坐标越近，那么这个纹理像素的颜色对最终的样本颜色的贡献越大。</p><img src="/2022/01/02/OpenGL%E6%9C%9F%E6%9C%AB%E6%B1%87%E6%80%BB2/filter_linear.png" class title="img"><img src="/2022/01/02/OpenGL%E6%9C%9F%E6%9C%AB%E6%B1%87%E6%80%BB2/image-20220102230636954.png" class title="image-20220102230636954"><p>​    我们需要使用glTexParameter*函数为其指定过滤方式。这段代码看起来会和纹理环绕方式的设置很相似：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);</span><br><span class="line">glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);</span><br></pre></td></tr></table></figure><h2 id="5、来点多级渐远纹理Mipmap"><a href="#5、来点多级渐远纹理Mipmap" class="headerlink" title="5、来点多级渐远纹理Mipmap"></a>5、来点多级渐远纹理Mipmap</h2><p>​    当你看远处的景物时，比如远山上的树，其只能产生很少的片段，但是却必须从很大的纹理中取纹理颜色，这不仅视觉上很怪，还会有很大的内存浪费。</p><blockquote><p>OpenGL使用一种叫做多级渐远纹理(Mipmap)的概念来解决这个问题，它简单来说就是一系列的纹理图像，后一个纹理图像是前一个的二分之一。多级渐远纹理背后的理念很简单：距观察者的距离超过一定的阈值，OpenGL会使用不同的多级渐远纹理，即最适合物体的距离的那个。由于距离远，解析度不高也不会被用户注意到。同时，多级渐远纹理另一加分之处是它的性能非常好。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//OpenGL有一个glGenerateMipmaps函数，在创建完一个纹理后调用它OpenGL就会承担接下来的所有工作了。</span></span><br><span class="line">glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR);</span><br><span class="line">glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);</span><br></pre></td></tr></table></figure><p>​    在渲染中切换多级渐远纹理级别(Level)时，OpenGL在两个不同级别的多级渐远纹理层之间会产生不真实的生硬边界。就像普通的纹理过滤一样，切换多级渐远纹理级别时你也可以在两个不同多级渐远纹理级别之间使用NEAREST和LINEAR过滤。</p><img src="/2022/01/02/OpenGL%E6%9C%9F%E6%9C%AB%E6%B1%87%E6%80%BB2/image-20220103101428137.png" class title="image-20220103101428137"><p>​    最重要的事情别忘了，mipmap只适用看远处的物体（也就是缩小纹理），你可不能指望它去放大纹理！</p><h2 id="7、阶段性总结"><a href="#7、阶段性总结" class="headerlink" title="7、阶段性总结"></a>7、阶段性总结</h2><p>​    大概，纹理加载的代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// load and create a texture </span></span><br><span class="line">    <span class="comment">// -------------------------</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> texture;</span><br><span class="line">    glGenTextures(<span class="number">1</span>, &amp;texture);</span><br><span class="line">    glBindTexture(GL_TEXTURE_2D, texture); <span class="comment">// all upcoming GL_TEXTURE_2D operations now have effect on this texture object</span></span><br><span class="line">    <span class="comment">// set the texture wrapping parameters</span></span><br><span class="line">    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);<span class="comment">// set texture wrapping to GL_REPEAT (default wrapping method)</span></span><br><span class="line">    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);</span><br><span class="line">    <span class="comment">// set texture filtering parameters</span></span><br><span class="line">    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR);</span><br><span class="line">    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);</span><br><span class="line">    <span class="comment">// load image, create texture and generate mipmaps</span></span><br><span class="line">    <span class="keyword">int</span> width, height, nrChannels;</span><br><span class="line">    <span class="comment">// The FileSystem::getPath(...) is part of the GitHub repository so we can find files on any IDE/platform; replace it with your own image path.</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *data = stbi_load(FileSystem::getPath(<span class="string">&quot;resources/textures/container.jpg&quot;</span>).c_str(), &amp;width, &amp;height, &amp;nrChannels, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (data)</span><br><span class="line">    &#123;</span><br><span class="line">        glTexImage2D(GL_TEXTURE_2D, <span class="number">0</span>, GL_RGB, width, height, <span class="number">0</span>, GL_RGB, GL_UNSIGNED_BYTE, data);</span><br><span class="line">        glGenerateMipmap(GL_TEXTURE_2D);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Failed to load texture&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    stbi_image_free(data);</span><br><span class="line"></span><br><span class="line"><span class="comment">//在loop中绘制</span></span><br><span class="line"><span class="comment">// bind Texture</span></span><br><span class="line">glBindTexture(GL_TEXTURE_2D, texture);</span><br><span class="line"></span><br><span class="line"><span class="comment">// render container</span></span><br><span class="line">    ourShader.use();</span><br><span class="line">    glBindVertexArray(VAO);</span><br><span class="line">    glDrawElements(GL_TRIANGLES, <span class="number">6</span>, GL_UNSIGNED_INT, <span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>​    是的，或许你发现了华点！我们都没给fragment着色器中的uniform sampler2D量赋值呢！！！</p><p>​    emm好吧，原来在调用glDrawElements之前绑定纹理了，它会自动把纹理赋值给片段着色器的采样器！！</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">glBindTexture(GL_TEXTURE_2D, texture);</span><br><span class="line">glBindVertexArray(VAO);</span><br><span class="line">glDrawElements(GL_TRIANGLES, <span class="number">6</span>, GL_UNSIGNED_INT, <span class="number">0</span>);</span><br><span class="line"><span class="comment">//此时已经默认传入纹理了！</span></span><br></pre></td></tr></table></figure><h2 id="8、纹理单元"><a href="#8、纹理单元" class="headerlink" title="8、纹理单元"></a>8、纹理单元</h2><p>​    但是，为什么明明是Uniform变量，我们却不用glUniform给它赋值呢？别急，慢慢看。</p><p>​    一个纹理的位置值通常称为一个纹理单元(Texture Unit)。例如上面的纹理的默认纹理单元是0，它是默认的激活纹理单元，所以只需要绑定纹理即可直接传输。</p><p>​    但是当纹理一多，我们就不能全用默认的传输方式了，所以这里用到了纹理单元。纹理单元的主要目的是让我们在着色器中可以使用多于一个的纹理。</p><p>​    通过把纹理单元赋值给采样器，我们可以一次绑定多个纹理，只要我们首先激活对应的纹理单元。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//就像glBindTexture一样，我们可以使用glActiveTexture激活纹理单元，传入我们需要使用的纹理单元：</span></span><br><span class="line">glActiveTexture(GL_TEXTURE0); <span class="comment">// 在绑定纹理之前先激活纹理单元</span></span><br><span class="line">glBindTexture(GL_TEXTURE_2D, texture);</span><br></pre></td></tr></table></figure><blockquote><p>激活纹理单元之后，接下来的glBindTexture函数调用会绑定这个纹理到当前激活的纹理单元，纹理单元GL_TEXTURE0默认总是被激活，所以我们在前面的例子里当我们使用<code>glBindTexture</code>的时候，无需激活任何纹理单元。</p><p>OpenGL至少保证有16个纹理单元供你使用，也就是说你可以激活从GL_TEXTURE0到GL_TEXTRUE15。</p></blockquote><p>​    当然仅仅是这样，我们还没有完全实现与shader之内的sampler2D变量完全对应，我们还需要使用glUniform1i设置每个采样器的方式告诉OpenGL每个着色器采样器属于哪个纹理单元。我们只需要设置一次即可，所以这个会放在渲染循环的前面：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ourShader.use(); <span class="comment">// 不要忘记在设置uniform变量之前激活着色器程序！</span></span><br><span class="line">glUniform1i(glGetUniformLocation(ourShader.ID, <span class="string">&quot;texture1&quot;</span>), <span class="number">0</span>); <span class="comment">// 手动设置、这里的0应该对应的是GL_TEXTURE0</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//你可能注意到纹理上下颠倒了！这是因为OpenGL要求y轴0.0坐标是在图片的底部的，但是图片的y轴0.0坐标通常在顶部。很幸运，stb_image.h能够在图像加载时帮助我们翻转y轴，只需要在加载任何图像前加入以下语句即可：</span></span><br><span class="line">stbi_set_flip_vertically_on_load(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure><p>至此，加载纹理的代码大致如下：<a href="https://learnopengl.com/code_viewer_gh.php?code=src/1.getting_started/4.2.textures_combined/textures_combined.cpp">https://learnopengl.com/code_viewer_gh.php?code=src/1.getting_started/4.2.textures_combined/textures_combined.cpp</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// load and create a texture </span></span><br><span class="line">    <span class="comment">// -------------------------</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> texture1, texture2;</span><br><span class="line">    <span class="comment">// texture 1</span></span><br><span class="line">    <span class="comment">// ---------</span></span><br><span class="line">    glGenTextures(<span class="number">1</span>, &amp;texture1);</span><br><span class="line">    glBindTexture(GL_TEXTURE_2D, texture1); </span><br><span class="line">     <span class="comment">// set the texture wrapping parameters</span></span><br><span class="line">    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);<span class="comment">// set texture wrapping to GL_REPEAT (default wrapping method)</span></span><br><span class="line">    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);</span><br><span class="line">    <span class="comment">// set texture filtering parameters</span></span><br><span class="line">    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);</span><br><span class="line">    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);</span><br><span class="line">    <span class="comment">// load image, create texture and generate mipmaps</span></span><br><span class="line">    <span class="keyword">int</span> width, height, nrChannels;</span><br><span class="line">    stbi_set_flip_vertically_on_load(<span class="literal">true</span>); <span class="comment">// tell stb_image.h to flip loaded texture&#x27;s on the y-axis.</span></span><br><span class="line">    <span class="comment">// The FileSystem::getPath(...) is part of the GitHub repository so we can find files on any IDE/platform; replace it with your own image path.</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *data = stbi_load(FileSystem::getPath(<span class="string">&quot;resources/textures/container.jpg&quot;</span>).c_str(), &amp;width, &amp;height, &amp;nrChannels, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (data)</span><br><span class="line">    &#123;</span><br><span class="line">        glTexImage2D(GL_TEXTURE_2D, <span class="number">0</span>, GL_RGB, width, height, <span class="number">0</span>, GL_RGB, GL_UNSIGNED_BYTE, data);</span><br><span class="line">        glGenerateMipmap(GL_TEXTURE_2D);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Failed to load texture&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    stbi_image_free(data);</span><br><span class="line">    <span class="comment">// texture 2</span></span><br><span class="line">    <span class="comment">// ---------</span></span><br><span class="line">    glGenTextures(<span class="number">1</span>, &amp;texture2);</span><br><span class="line">    glBindTexture(GL_TEXTURE_2D, texture2);</span><br><span class="line">    <span class="comment">// set the texture wrapping parameters</span></span><br><span class="line">    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);<span class="comment">// set texture wrapping to GL_REPEAT (default wrapping method)</span></span><br><span class="line">    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);</span><br><span class="line">    <span class="comment">// set texture filtering parameters</span></span><br><span class="line">    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);</span><br><span class="line">    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);</span><br><span class="line">    <span class="comment">// load image, create texture and generate mipmaps</span></span><br><span class="line">    data = stbi_load(FileSystem::getPath(<span class="string">&quot;resources/textures/awesomeface.png&quot;</span>).c_str(), &amp;width, &amp;height, &amp;nrChannels, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (data)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// note that the awesomeface.png has transparency and thus an alpha channel, so make sure to tell OpenGL the data type is of GL_RGBA</span></span><br><span class="line">        glTexImage2D(GL_TEXTURE_2D, <span class="number">0</span>, GL_RGBA, width, height, <span class="number">0</span>, GL_RGBA, GL_UNSIGNED_BYTE, data);</span><br><span class="line">        glGenerateMipmap(GL_TEXTURE_2D);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Failed to load texture&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    stbi_image_free(data);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// tell opengl for each sampler to which texture unit it belongs to (only has to be done once)</span></span><br><span class="line">    <span class="comment">// -------------------------------------------------------------------------------------------</span></span><br><span class="line">    ourShader.use(); <span class="comment">// don&#x27;t forget to activate/use the shader before setting uniforms!</span></span><br><span class="line">    <span class="comment">// either set it manually like so:</span></span><br><span class="line">    glUniform1i(glGetUniformLocation(ourShader.ID, <span class="string">&quot;texture1&quot;</span>), <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// or set it via the texture class</span></span><br><span class="line">    ourShader.setInt(<span class="string">&quot;texture2&quot;</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//in main loop</span></span><br><span class="line"><span class="comment">//.......</span></span><br><span class="line"><span class="comment">// bind textures on corresponding texture units</span></span><br><span class="line">        glActiveTexture(GL_TEXTURE0);</span><br><span class="line">        glBindTexture(GL_TEXTURE_2D, texture1);</span><br><span class="line">        glActiveTexture(GL_TEXTURE1);</span><br><span class="line">        glBindTexture(GL_TEXTURE_2D, texture2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// render container</span></span><br><span class="line">        ourShader.use();</span><br><span class="line">        glBindVertexArray(VAO);</span><br><span class="line">        glDrawElements(GL_TRIANGLES, <span class="number">6</span>, GL_UNSIGNED_INT, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>​    学到这，我只想说，OpenGL你是不是太古老了，这些步骤在今日看起来已经有点繁琐了…….但是其实用起来还好吧233</p>]]></content>
      
      
      
        <tags>
            
            <tag> OpenGL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【OpenGL】期末汇总-关于VBO和Shader</title>
      <link href="/2022/01/02/OpenGL%E6%9C%9F%E6%9C%AB%E6%B1%87%E6%80%BB/"/>
      <url>/2022/01/02/OpenGL%E6%9C%9F%E6%9C%AB%E6%B1%87%E6%80%BB/</url>
      
        <content type="html"><![CDATA[<p>边学边复习~ 大家新年快乐</p><h2 id="1、VBO保存顶点数据"><a href="#1、VBO保存顶点数据" class="headerlink" title="1、VBO保存顶点数据"></a>1、VBO保存顶点数据</h2><ul><li><strong>顶点数组对象：Vertex Array Object，VAO</strong></li><li><strong>顶点缓冲对象：Vertex Buffer Object，VBO</strong></li><li><strong>索引缓冲对象：Element Buffer Object，EBO或Index Buffer Object，IBO</strong></li></ul><p>在程序中，我们会定义大量的顶点数据，如模型坐标等等。在OpenGL中，我们通过<strong>顶点缓冲对象</strong>(Vertex Buffer Objects, <strong>VBO</strong>)管理这个内存，它会在GPU内存（通常被称为显存）中储存大量顶点。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//可以使用glGenBuffers函数和一个缓冲ID生成一个VBO对象：</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> VBO;</span><br><span class="line"><span class="built_in">glGenBuffers</span>(<span class="number">1</span>, &amp;VBO);</span><br><span class="line"><span class="comment">//顶点缓冲对象的缓冲类型是GL_ARRAY_BUFFER,我们可以对VBO进行绑定</span></span><br><span class="line"><span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, VBO);  </span><br><span class="line"><span class="comment">//之后，就可以通过GL_ARRAY_BUFFER进行传值了</span></span><br><span class="line"><span class="comment">//glBufferData是一个专门用来把用户定义的数据复制到当前绑定缓冲的函数。</span></span><br><span class="line"><span class="built_in">glBufferData</span>(GL_ARRAY_BUFFER, <span class="built_in"><span class="keyword">sizeof</span></span>(vertices), vertices, GL_STATIC_DRAW);</span><br><span class="line"><span class="comment">//第二个参数指定传输数据的大小。第三个参数是我们希望发送的实际数据。第四个参数指定了我们希望显卡如何管理给定的数据</span></span><br></pre></td></tr></table></figure><p>现在我们已经把顶点数据储存在显卡的内存中，并用VBO这个顶点缓冲对象管理。接下来需要使用shader进行处理咯~</p><h2 id="2、Shader解释如何使用顶点数据和渲染流水线"><a href="#2、Shader解释如何使用顶点数据和渲染流水线" class="headerlink" title="2、Shader解释如何使用顶点数据和渲染流水线"></a>2、Shader解释如何使用顶点数据和渲染流水线</h2><h3 id="朴实无华版本"><a href="#朴实无华版本" class="headerlink" title="朴实无华版本"></a>朴实无华版本</h3><p>​    读取-绑定-顶点和片源着色器连接-使用-删除</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//首先进行shader内容的定义</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *vertexShaderSource =<span class="string">&quot;#version 330 core\n&quot;</span></span><br><span class="line">    <span class="string">&quot;layout (location = 0) in vec3 aPos;\n&quot;</span></span><br><span class="line">    <span class="string">&quot;layout (location = 1) in vec3 aColor;\n&quot;</span></span><br><span class="line">    <span class="string">&quot;out vec3 ourColor;\n&quot;</span></span><br><span class="line">    <span class="string">&quot;void main()\n&quot;</span></span><br><span class="line">    <span class="string">&quot;&#123;\n&quot;</span></span><br><span class="line">    <span class="string">&quot;   gl_Position = vec4(aPos, 1.0);\n&quot;</span></span><br><span class="line">    <span class="string">&quot;   ourColor = aColor;\n&quot;</span></span><br><span class="line">    <span class="string">&quot;&#125;\0&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *fragmentShaderSource = <span class="string">&quot;#version 330 core\n&quot;</span></span><br><span class="line">    <span class="string">&quot;out vec4 FragColor;\n&quot;</span></span><br><span class="line">    <span class="string">&quot;in vec3 ourColor;\n&quot;</span></span><br><span class="line">    <span class="string">&quot;uniform vec4 ourColor1; // 在OpenGL程序代码中设定这个变量&quot;</span></span><br><span class="line">    <span class="string">&quot;void main()\n&quot;</span></span><br><span class="line">    <span class="string">&quot;&#123;\n&quot;</span></span><br><span class="line">    <span class="string">&quot;   FragColor = vec4(ourColor, 1.0f);\n&quot;</span></span><br><span class="line">    <span class="string">&quot;&#125;\n\0&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//进行shader的build 省略错误检测部分</span></span><br><span class="line"> <span class="comment">// vertex shader</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> vertexShader = glCreateShader(GL_VERTEX_SHADER);</span><br><span class="line">    glShaderSource(vertexShader, <span class="number">1</span>, &amp;vertexShaderSource, <span class="literal">NULL</span>);</span><br><span class="line">    glCompileShader(vertexShader);</span><br><span class="line"> <span class="comment">// fragment shader</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> fragmentShader = glCreateShader(GL_FRAGMENT_SHADER);</span><br><span class="line">    glShaderSource(fragmentShader, <span class="number">1</span>, &amp;fragmentShaderSource, <span class="literal">NULL</span>);</span><br><span class="line">    glCompileShader(fragmentShader);</span><br><span class="line"> <span class="comment">// link shaders</span></span><br><span class="line"><span class="comment">//着色器程序对象(Shader Program Object)是多个着色器合并之后并最终链接完成的版本。如果要使用刚才编译的着色器我们必须把它们链接(Link)为一个着色器程序对象，然后在渲染对象的时候激活这个着色器程序。已激活着色器程序的着色器将在我们发送渲染调用的时候被使用。</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> shaderProgram = glCreateProgram();</span><br><span class="line">    glAttachShader(shaderProgram, vertexShader);</span><br><span class="line">    glAttachShader(shaderProgram, fragmentShader);</span><br><span class="line">    glLinkProgram(shaderProgram);</span><br><span class="line">    glDeleteShader(vertexShader);</span><br><span class="line">    glDeleteShader(fragmentShader);</span><br><span class="line"><span class="comment">//绑定完成后即可使用</span></span><br><span class="line"> glUseProgram(shaderProgram);</span><br><span class="line"><span class="comment">//......</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//若要传入数据至shader,这里传给Uniform，是全局的</span></span><br><span class="line">    <span class="keyword">int</span> vertexColorLocation = glGetUniformLocation(shaderProgram, <span class="string">&quot;ourColor1&quot;</span>);</span><br><span class="line">    glUniform4f(vertexColorLocation, <span class="number">0.0f</span>, greenValue, <span class="number">0.0f</span>, <span class="number">1.0f</span>);</span><br><span class="line">    <span class="comment">//也可通过VAO VBO的一系列操作传入数据</span></span><br><span class="line">    <span class="comment">// 位置属性</span></span><br><span class="line">    glVertexAttribPointer(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">6</span> * <span class="keyword">sizeof</span>(<span class="keyword">float</span>), (<span class="keyword">void</span>*)<span class="number">0</span>);</span><br><span class="line">    glEnableVertexAttribArray(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">//这里需要参考上下文进行，传入给layout (location = 0) in vec3 aPos;这个输入。</span></span><br><span class="line"></span><br><span class="line">glDeleteProgram(shaderProgram);</span><br></pre></td></tr></table></figure><h2 id><a href="#" class="headerlink" title></a></h2><h2 id="3、glVertexAttribPointer-来链接顶点属性"><a href="#3、glVertexAttribPointer-来链接顶点属性" class="headerlink" title="3、glVertexAttribPointer 来链接顶点属性"></a>3、glVertexAttribPointer 来链接顶点属性</h2><p>​    在传顶点数据至VBO（也就相对于把输入顶点数据发送给了GPU）完成和成功绑定俩个Shader（即指示了GPU如何在顶点和片段着色器中处理它）之后，我们还需要让OpenGL知道该如何解释内存中的顶点数据，以及它该如何将顶点数据链接到顶点着色器的属性上。</p><p>​    即链接顶点属性:可以使用glVertexAttribPointer函数告诉OpenGL该如何解析顶点数据（应用到逐个顶点属性上）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 设置顶点属性指针</span></span><br><span class="line">glVertexAttribPointer(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">3</span> * <span class="keyword">sizeof</span>(<span class="keyword">float</span>), (<span class="keyword">void</span>*)<span class="number">0</span>);</span><br><span class="line">glEnableVertexAttribArray(<span class="number">0</span>);</span><br><span class="line"><span class="comment">//在传入之后，我们就可以开画了</span></span><br><span class="line">glUseProgram(shaderProgram);</span><br><span class="line"><span class="comment">// ... 绘制物体</span></span><br><span class="line">someOpenGLFunctionThatDrawsOurTriangle();</span><br></pre></td></tr></table></figure><blockquote><p>glVertexAttribPointer函数的参数非常多，所以我会逐一介绍它们：</p><ul><li>第一个参数指定我们要配置的顶点属性。还记得我们在顶点着色器中使用<code>layout(location = 0)</code>定义了position顶点属性的位置值(Location)吗？它可以把顶点属性的位置值设置为<code>0</code>。因为我们希望把数据传递到这一个顶点属性中，所以这里我们传入<code>0</code>。</li><li>第二个参数指定顶点属性的大小。顶点属性是一个<code>vec3</code>，它由3个值组成，所以大小是3。</li><li>第三个参数指定数据的类型，这里是GL_FLOAT(GLSL中<code>vec*</code>都是由浮点数值组成的)。</li><li>第四个参数定义我们是否希望数据被标准化(Normalize)。如果我们设置为GL_TRUE，所有数据都会被映射到0（对于有符号型signed数据是-1）到1之间。我们把它设置为GL_FALSE。</li><li>第五个参数叫做步长(Stride)，它告诉我们在连续的顶点属性组之间的间隔。由于下个组位置数据在3个<code>float</code>之后，我们把步长设置为<code>3 * sizeof(float)</code>。</li><li>最后一个参数的类型是<code>void*</code>，所以需要我们进行这个奇怪的强制类型转换。它表示位置数据在缓冲中起始位置的偏移量(Offset)。由于位置数据在数组的开头，所以这里是0。我们会在后面详细解释这个参数。</li></ul><p>每个顶点属性从一个VBO管理的内存中获得它的数据，而具体是从哪个VBO（程序中可以有多个VBO）获取则是通过在调用glVertexAttribPointer时绑定到GL_ARRAY_BUFFER的VBO决定的。由于在调用glVertexAttribPointer之前绑定的是先前定义的VBO对象，顶点属性<code>0</code>现在会链接到它的顶点数据。</p></blockquote><p>​    是的，这个函数会默认使用之前的绑定到GL_ARRAY_BUFFER的VBO对象，也就是之前刚刚传入顶点数据的那个VBO（所以一切是看谁绑定到GL_ARRAY_BUFFER为准的咯）。然后将其内容传递至layout（position=0）的顶点属性里去。（仿佛人为翻译了一遍）</p><h2 id="4、VAO-相当于管理VBO-方便我们切换"><a href="#4、VAO-相当于管理VBO-方便我们切换" class="headerlink" title="4、VAO 相当于管理VBO 方便我们切换"></a>4、VAO 相当于管理VBO 方便我们切换</h2><p>​    顶点数组对象(Vertex Array Object, VAO)可以像顶点缓冲对象那样被绑定，任何随后的顶点属性调用都会储存在这个VAO中。</p><p>​    这样的好处就是，当配置顶点属性指针时，你只需要将那些调用执行一次，之后再绘制物体的时候只需要绑定相应的VAO就行了。这使在不同顶点数据和属性配置之间切换变得非常简单，只需要绑定不同的VAO就行了。</p><p>​    默认情况下，应该是一个VBO就对应一个VAO。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用VAO与使用VBO类似</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> VAO;</span><br><span class="line">glGenVertexArrays(<span class="number">1</span>, &amp;VAO);</span><br></pre></td></tr></table></figure><p>​    然后对VAO进行一个VBO的绑，绑好之后要用的时候，重新绑定VAO即可调用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 绑定VAO</span></span><br><span class="line">glBindVertexArray(VAO);</span><br><span class="line"><span class="comment">// 2. 把顶点数组复制到缓冲中供OpenGL使用</span></span><br><span class="line">glBindBuffer(GL_ARRAY_BUFFER, VBO);</span><br><span class="line">glBufferData(GL_ARRAY_BUFFER, <span class="keyword">sizeof</span>(vertices), vertices, GL_STATIC_DRAW);</span><br><span class="line"><span class="comment">// 3. 设置顶点属性指针</span></span><br><span class="line">glVertexAttribPointer(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">3</span> * <span class="keyword">sizeof</span>(<span class="keyword">float</span>), (<span class="keyword">void</span>*)<span class="number">0</span>);</span><br><span class="line">glEnableVertexAttribArray(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">[...]</span><br><span class="line"></span><br><span class="line"><span class="comment">// ..:: 绘制代码（渲染循环中） :: ..</span></span><br><span class="line"><span class="comment">// 4. 绘制物体</span></span><br><span class="line">glUseProgram(shaderProgram);</span><br><span class="line">glBindVertexArray(VAO);</span><br><span class="line">someOpenGLFunctionThatDrawsOurTriangle();</span><br></pre></td></tr></table></figure><p>完整的内容大概如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> VBO, VAO;</span><br><span class="line">glGenVertexArrays(<span class="number">1</span>, &amp;VAO);</span><br><span class="line">glGenBuffers(<span class="number">1</span>, &amp;VBO);</span><br><span class="line"><span class="comment">// 先绑定VAO，然后绑定设置VBO，再配置顶点属性。</span></span><br><span class="line">glBindVertexArray(VAO);</span><br><span class="line"></span><br><span class="line">glBindBuffer(GL_ARRAY_BUFFER, VBO);</span><br><span class="line">glBufferData(GL_ARRAY_BUFFER, <span class="keyword">sizeof</span>(vertices), vertices, GL_STATIC_DRAW);</span><br><span class="line"></span><br><span class="line">glVertexAttribPointer(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">3</span> * <span class="keyword">sizeof</span>(<span class="keyword">float</span>), (<span class="keyword">void</span>*)<span class="number">0</span>);</span><br><span class="line">glEnableVertexAttribArray(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//可有可无：在绑定顶点数据完成之后，确实可以解绑了，因为现在都存在这个VAO里面了</span></span><br><span class="line">glBindBuffer(GL_ARRAY_BUFFER, <span class="number">0</span>); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 之后您可以解除绑定 VAO，这样其他 VAO 调用就不会意外修改此 VAO，但这种情况很少发生。</span></span><br><span class="line"><span class="comment">//VAO 无论如何都需要调用 glBindVertexArray，因此我们通常不会在不直接需要时解除绑定 VAO（或 VBO）。</span></span><br><span class="line">glBindVertexArray(<span class="number">0</span>); </span><br></pre></td></tr></table></figure><p>​    上述是绑定VAO VBO的内容，之后即可进行使用了~</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (!glfwWindowShouldClose(window))<span class="comment">//绘制LOOP</span></span><br><span class="line">  &#123;</span><br><span class="line">      <span class="comment">//...输入之类杂七杂八</span></span><br><span class="line">  <span class="comment">//开画！</span></span><br><span class="line">      glUseProgram(shaderProgram);</span><br><span class="line">    <span class="comment">//这里的绑定shader对之后所有的绘制都有效，除非你解绑！</span></span><br><span class="line">    </span><br><span class="line">      glBindVertexArray(VAO); <span class="comment">// seeing as we only have a single VAO there&#x27;s no need to bind it every time, but we&#x27;ll do so to keep things a bit more organized</span></span><br><span class="line">      glDrawArrays(GL_TRIANGLES, <span class="number">0</span>, <span class="number">3</span>);</span><br><span class="line">      <span class="comment">// glBindVertexArray(0); // no need to unbind it every time </span></span><br><span class="line"> </span><br><span class="line">      <span class="comment">// glfw: swap buffers and poll IO events (keys pressed/released, mouse moved etc.)</span></span><br><span class="line">      <span class="comment">// -------------------------------------------------------------------------------</span></span><br><span class="line">      glfwSwapBuffers(window);</span><br><span class="line">      glfwPollEvents();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// optional: de-allocate all resources once they&#x27;ve outlived their purpose:</span></span><br><span class="line">  <span class="comment">// ------------------------------------------------------------------------</span></span><br><span class="line">  glDeleteVertexArrays(<span class="number">1</span>, &amp;VAO);</span><br><span class="line">  glDeleteBuffers(<span class="number">1</span>, &amp;VBO);</span><br><span class="line">  glDeleteProgram(shaderProgram);<span class="comment">//别忘了解绑 删除</span></span><br></pre></td></tr></table></figure><h2 id="5、EBO索引缓冲对象"><a href="#5、EBO索引缓冲对象" class="headerlink" title="5、EBO索引缓冲对象"></a>5、EBO索引缓冲对象</h2><p>​    嘿嘿嘿是不是感觉完成的差不多了。但其实在开头写的三个对象中，还有一个EBO没用到呢。不过也别怕，就差这最后一点点内容了！</p><p>​    首先我们得知道，在OpenGL中，绘制图形都是以三角形为基础的，比如绘制矩形会由俩个三角形合成。那在这个过程中，必然有大量的三角形顶点重合，如果我们都把重合这部分导入顶点坐标，会有大量的浪费。因此我们引入了EBO，使用索引大大减少顶点重复量。不多说看例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> vertices[] = &#123;</span><br><span class="line">    <span class="comment">// 第一个三角形</span></span><br><span class="line">    <span class="number">0.5f</span>, <span class="number">0.5f</span>, <span class="number">0.0f</span>,   <span class="comment">// 右上角</span></span><br><span class="line">    <span class="number">0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,  <span class="comment">// 右下角</span></span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">0.5f</span>, <span class="number">0.0f</span>,  <span class="comment">// 左上角</span></span><br><span class="line">    <span class="comment">// 第二个三角形</span></span><br><span class="line">    <span class="number">0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,  <span class="comment">// 右下角</span></span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>, <span class="comment">// 左下角</span></span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">0.5f</span>, <span class="number">0.0f</span>   <span class="comment">// 左上角</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以看到，这个矩形的左上角和右下角都重复了！</p><img src="/2022/01/02/OpenGL%E6%9C%9F%E6%9C%AB%E6%B1%87%E6%80%BB/image-20220102201529377.png" alt="image-20220102201529377" style="zoom:50%;"><p>所以，我们进行改进：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> vertices[] = &#123;</span><br><span class="line">    <span class="number">0.5f</span>, <span class="number">0.5f</span>, <span class="number">0.0f</span>,   <span class="comment">// 右上角</span></span><br><span class="line">    <span class="number">0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,  <span class="comment">// 右下角</span></span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>, <span class="comment">// 左下角</span></span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">0.5f</span>, <span class="number">0.0f</span>   <span class="comment">// 左上角</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> indices[] = &#123; <span class="comment">// 注意索引从0开始! </span></span><br><span class="line">    <span class="number">0</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="comment">// 第一个三角形</span></span><br><span class="line">    <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>  <span class="comment">// 第二个三角形</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>​    然后，我们就可以使用EBO进行操作了！</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建索引缓冲对象：</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> EBO;</span><br><span class="line">glGenBuffers(<span class="number">1</span>, &amp;EBO);</span><br><span class="line"><span class="comment">//如同VBO的传入顶点数据，EBO也是一样，只不过这次我们把缓冲的类型定义为GL_ELEMENT_ARRAY_BUFFER。</span></span><br><span class="line">glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO);</span><br><span class="line">glBufferData(GL_ELEMENT_ARRAY_BUFFER, <span class="keyword">sizeof</span>(indices), indices, GL_STATIC_DRAW);</span><br><span class="line"></span><br><span class="line"><span class="comment">//在使用（绘制）时，注意绑定EBO同时使用glDrawElements！其会使用当前绑定的索引缓冲对象中的索引进行绘制</span></span><br><span class="line">glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO);</span><br><span class="line">glDrawElements(GL_TRIANGLES, <span class="number">6</span>, GL_UNSIGNED_INT, <span class="number">0</span>);</span><br><span class="line"><span class="comment">//第一个参数指定了我们绘制的模式，这个和glDrawArrays的一样。</span></span><br><span class="line"><span class="comment">//第二个参数是我们打算绘制顶点的个数，这里填6，也就是说我们一共需要绘制6个顶点。</span></span><br><span class="line"><span class="comment">//第三个参数是索引的类型，这里是GL_UNSIGNED_INT。</span></span><br><span class="line"><span class="comment">//最后一个参数里我们可以指定EBO中的偏移量（或者传递一个索引数组，但是这是当你不在使用索引缓冲对象的时候），但是我们会在这里填写0。</span></span><br></pre></td></tr></table></figure><img src="/2022/01/02/OpenGL%E6%9C%9F%E6%9C%AB%E6%B1%87%E6%80%BB/vertex_array_objects_ebo.png" class title="img"><p>​    glDrawElements函数从当前绑定到GL_ELEMENT_ARRAY_BUFFER目标的EBO中获取索引。</p><p>​    这意味着我们必须在每次要用索引渲染一个物体时绑定相应的EBO，这还是有点麻烦。</p><p>​    不过顶点数组对象同样可以保存索引缓冲对象的绑定状态。VAO绑定时正在绑定的索引缓冲对象会被保存为VAO的元素缓冲对象。绑定VAO的同时也会自动绑定EBO。所以绑定好之后，我们还是可以只使用一个VAO！</p><p>​    三个VAO VBO EBO 合起来大概是这样子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">unsigned</span> <span class="keyword">int</span> VBO, VAO, EBO;</span><br><span class="line">    glGenVertexArrays(<span class="number">1</span>, &amp;VAO);</span><br><span class="line">    glGenBuffers(<span class="number">1</span>, &amp;VBO);</span><br><span class="line">    glGenBuffers(<span class="number">1</span>, &amp;EBO);</span><br><span class="line"></span><br><span class="line"><span class="comment">//疯狂绑定就可以，记住先VAO哦。绑好VBO和EBO之后传值别忘了</span></span><br><span class="line">    glBindVertexArray(VAO);</span><br><span class="line">    glBindBuffer(GL_ARRAY_BUFFER, VBO);</span><br><span class="line">    glBufferData(GL_ARRAY_BUFFER, <span class="keyword">sizeof</span>(vertices), vertices, GL_STATIC_DRAW);</span><br><span class="line">    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO);</span><br><span class="line">    glBufferData(GL_ELEMENT_ARRAY_BUFFER, <span class="keyword">sizeof</span>(indices), indices, GL_STATIC_DRAW);</span><br><span class="line"><span class="comment">//看样子会直接一起传进入/或者处理好了传进去</span></span><br><span class="line">    glVertexAttribPointer(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">3</span> * <span class="keyword">sizeof</span>(<span class="keyword">float</span>), (<span class="keyword">void</span>*)<span class="number">0</span>);</span><br><span class="line">    glEnableVertexAttribArray(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    glBindBuffer(GL_ARRAY_BUFFER, <span class="number">0</span>); </span><br><span class="line">    <span class="comment">//请记住：不要在 VAO 处于活动状态时解除绑定 EBO，因为绑定元素缓冲区对象存储在 VAO 中；EBO保持绑定！</span></span><br><span class="line"><span class="comment">//其实我只有全都不解绑不就行了，哈哈，当然不行，万一之后多起来了怎么办</span></span><br><span class="line">    <span class="comment">//glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0);</span></span><br><span class="line">    glBindVertexArray(<span class="number">0</span>); </span><br><span class="line"></span><br><span class="line"><span class="comment">//在LOOP中使用时，依旧绑定VAO即可，因为VBO EBO都已经在内了</span></span><br><span class="line">glBindVertexArray(VAO);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="6、一点关于Uniform的小补充"><a href="#6、一点关于Uniform的小补充" class="headerlink" title="6、一点关于Uniform的小补充"></a>6、一点关于Uniform的小补充</h2><p>​    在之前我们不是使用layout(position=x)那玩意传入值到shader里吗，在这里我们介绍另一个比较常用的Uniform。</p><p>​    Uniform是一种从CPU中的应用向GPU中的着色器发送数据的方式，但uniform和顶点属性有些不同。</p><p>​    首先，uniform是全局的(Global)。全局意味着uniform变量必须在<strong>每个着色器程序对象</strong>中都是独一无二的，而且它可以被着色器程序的任意着色器在任意阶段访问。</p><p>​    第二，无论你把uniform值设置成什么，uniform会一直保存它们的数据，直到它们被重置或更新。</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//比如在这个fragment着色器中，我们有uniform vec4的ourColor</span></span><br><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"><span class="keyword">out</span> <span class="type">vec4</span> FragColor;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">vec4</span> ourColor; <span class="comment">// 在OpenGL程序代码中设定这个变量</span></span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    FragColor = ourColor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    那，如何传入值到这个ourColor中去呢？</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//我们首先需要找到着色器中uniform属性的索引/位置值。当我们得到uniform的索引/位置值后，我们就可以更新它的值了。</span></span><br><span class="line"><span class="comment">//用glGetUniformLocation查询uniform ourColor的位置值</span></span><br><span class="line"><span class="comment">//提供着色器程序和uniform的名字</span></span><br><span class="line"><span class="type">int</span> vertexColorLocation = glGetUniformLocation(shaderProgram, &quot;ourColor&quot;);</span><br><span class="line"><span class="comment">//更新一个uniform之前你必须先使用程序（调用glUseProgram)，因为它是在当前激活的着色器程序中设置uniform的。</span></span><br><span class="line">glUseProgram(shaderProgram);</span><br><span class="line"><span class="comment">//这里因为greenValue是float，所以用glUniform4f，指需要4个f</span></span><br><span class="line">glUniform4f(vertexColorLocation, <span class="number">0.0</span>f, greenValue<span class="comment">/*要传入的值*/</span>, <span class="number">0.0</span>f, <span class="number">1.0</span>f);</span><br></pre></td></tr></table></figure><img src="/2022/01/02/OpenGL%E6%9C%9F%E6%9C%AB%E6%B1%87%E6%80%BB/image-20220102205557943.png" class title="image-20220102205557943"><p>​    可以看到，因为uniform可以在MainLoop中随时随地改变值，所以其对于设置一个在渲染迭代中会改变的属性是一个非常有用的工具，它也是一个在程序和着色器间数据交互的很好工具。</p><h2 id="7、改为从文件读取Shader"><a href="#7、改为从文件读取Shader" class="headerlink" title="7、改为从文件读取Shader"></a>7、改为从文件读取Shader</h2><p>​    之前那个朴实无华的shader是直接写在程序中，是硬编码在代码文件顶部的C风格字符串中。现在我们让它变得美观，即从外部读取进来！</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">ReadShader(<span class="keyword">const</span> <span class="keyword">char</span>* vertexPath, <span class="keyword">const</span> <span class="keyword">char</span>* fragmentPath)</span><br><span class="line">  &#123;</span><br><span class="line">      <span class="comment">// 1. retrieve the vertex/fragment source code from filePath</span></span><br><span class="line">      <span class="built_in">std</span>::<span class="built_in">string</span> vertexCode;</span><br><span class="line">      <span class="built_in">std</span>::<span class="built_in">string</span> fragmentCode;</span><br><span class="line">      <span class="built_in">std</span>::ifstream vShaderFile;</span><br><span class="line">      <span class="built_in">std</span>::ifstream fShaderFile;</span><br><span class="line">      <span class="comment">// ensure ifstream objects can throw exceptions:</span></span><br><span class="line">      vShaderFile.exceptions (<span class="built_in">std</span>::ifstream::failbit | <span class="built_in">std</span>::ifstream::badbit);</span><br><span class="line">      fShaderFile.exceptions (<span class="built_in">std</span>::ifstream::failbit | <span class="built_in">std</span>::ifstream::badbit);</span><br><span class="line">      <span class="keyword">try</span> </span><br><span class="line">      &#123;</span><br><span class="line">          <span class="comment">// open files</span></span><br><span class="line">          vShaderFile.open(vertexPath);</span><br><span class="line">          fShaderFile.open(fragmentPath);</span><br><span class="line">          <span class="built_in">std</span>::<span class="built_in">stringstream</span> vShaderStream, fShaderStream;</span><br><span class="line">          <span class="comment">// read file&#x27;s buffer contents into streams</span></span><br><span class="line">          vShaderStream &lt;&lt; vShaderFile.rdbuf();</span><br><span class="line">          fShaderStream &lt;&lt; fShaderFile.rdbuf();</span><br><span class="line">          <span class="comment">// close file handlers</span></span><br><span class="line">          vShaderFile.close();</span><br><span class="line">          fShaderFile.close();</span><br><span class="line">          <span class="comment">// convert stream into string</span></span><br><span class="line">          vertexCode   = vShaderStream.str();</span><br><span class="line">          fragmentCode = fShaderStream.str();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">catch</span> (<span class="built_in">std</span>::ifstream::failure&amp; e)</span><br><span class="line">      &#123;</span><br><span class="line">          <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;ERROR::SHADER::FILE_NOT_SUCCESFULLY_READ&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">      &#125;</span><br><span class="line"><span class="comment">//上部分大部分都是C的读文件操作...</span></span><br><span class="line"><span class="comment">//下部分就是如同在内部shader一样，绑定shader了</span></span><br><span class="line">    </span><br><span class="line">      <span class="keyword">const</span> <span class="keyword">char</span>* vShaderCode = vertexCode.c_str();</span><br><span class="line">      <span class="keyword">const</span> <span class="keyword">char</span> * fShaderCode = fragmentCode.c_str();</span><br><span class="line">      <span class="comment">// 2. compile shaders</span></span><br><span class="line">      <span class="keyword">unsigned</span> <span class="keyword">int</span> vertex, fragment;</span><br><span class="line">      <span class="comment">// vertex shader</span></span><br><span class="line">      vertex = glCreateShader(GL_VERTEX_SHADER);</span><br><span class="line">      glShaderSource(vertex, <span class="number">1</span>, &amp;vShaderCode, <span class="literal">NULL</span>);</span><br><span class="line">      glCompileShader(vertex);</span><br><span class="line">      checkCompileErrors(vertex, <span class="string">&quot;VERTEX&quot;</span>);</span><br><span class="line">      <span class="comment">// fragment Shader</span></span><br><span class="line">      fragment = glCreateShader(GL_FRAGMENT_SHADER);</span><br><span class="line">      glShaderSource(fragment, <span class="number">1</span>, &amp;fShaderCode, <span class="literal">NULL</span>);</span><br><span class="line">      glCompileShader(fragment);</span><br><span class="line">      checkCompileErrors(fragment, <span class="string">&quot;FRAGMENT&quot;</span>);</span><br><span class="line">      <span class="comment">// shader Program</span></span><br><span class="line">      ID = glCreateProgram();</span><br><span class="line">    <span class="comment">//是的，这个ID就是之后使用这个Shader的必需品了</span></span><br><span class="line">      glAttachShader(ID, vertex);</span><br><span class="line">      glAttachShader(ID, fragment);</span><br><span class="line">      glLinkProgram(ID);</span><br><span class="line">      checkCompileErrors(ID, <span class="string">&quot;PROGRAM&quot;</span>);</span><br><span class="line">      <span class="comment">// delete the shaders as they&#x27;re linked into our program now and no longer necessary</span></span><br><span class="line">      glDeleteShader(vertex);</span><br><span class="line">      glDeleteShader(fragment);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    感谢大佬做好的shader_s.h库，把之前所有的操作直接封装的好好的，直接使用极其方便。</p><blockquote><p>​    <a href="https://learnopengl.com/code_viewer_gh.php?code=includes/learnopengl/shader_s.h">https://learnopengl.com/code_viewer_gh.php?code=includes/learnopengl/shader_s.h</a></p></blockquote><h2 id="尾言："><a href="#尾言：" class="headerlink" title="尾言："></a>尾言：</h2><p>​    差不多了差不多了，这一章就学到这吧，新年快乐~</p><p>​    感谢LearnOpenGL-CN和期末周带给我的压力和动力555</p>]]></content>
      
      
      
        <tags>
            
            <tag> OpenGL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Unity】期末课设开题思路</title>
      <link href="/2021/11/29/Unity-%E6%9C%9F%E6%9C%AB%E8%AF%BE%E8%AE%BE%E5%BC%80%E9%A2%98/"/>
      <url>/2021/11/29/Unity-%E6%9C%9F%E6%9C%AB%E8%AF%BE%E8%AE%BE%E5%BC%80%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>选题</p><h3 id="1-FPS打猎"><a href="#1-FPS打猎" class="headerlink" title="1.FPS打猎"></a>1.FPS打猎</h3><ol><li>巨大的场景支持，可能用到<strong>houdini</strong>，学习成本需要考虑</li><li>武器开镜视角，握持模型</li><li>动物出现，以及动物的各个部位不同的受伤害</li><li>好处：几乎很多素材脚本都是现成的</li></ol><h3 id="2-橡胶强盗"><a href="#2-橡胶强盗" class="headerlink" title="2.橡胶强盗"></a>2.橡胶强盗</h3><ol><li><del>需要局域网联机</del> 或者刚开始只是同一个设备内进行游戏<ol><li>我需要起码俩个角色，which means 我需要角色的对象</li><li>不同的设备输入，那说明<ol><li>我的角色要相互独立，想设置几个就几个</li></ol></li></ol></li><li>3D场景搭建<ol><li>要可以跳</li></ol></li><li>摄像机跟随角色做到最好的状态<ol><li>用cinemachine可以做到</li></ol></li><li>角色的积分系统 或者 角色的死亡次数<ol><li>独立于角色的第一个</li></ol></li><li>角色的鼠标控制<ol><li>如：鼠标左键是捡起和击打</li><li>鼠标右键是丢下，或者长按可以蓄力抛出</li></ol></li><li>风格选用low-poly风格的如何，</li></ol><h2 id="确定好了主题：模仿橡胶强盗，做一个lowPoly的橡胶强盗"><a href="#确定好了主题：模仿橡胶强盗，做一个lowPoly的橡胶强盗" class="headerlink" title="确定好了主题：模仿橡胶强盗，做一个lowPoly的橡胶强盗"></a>确定好了主题：模仿橡胶强盗，做一个lowPoly的橡胶强盗</h2><ol><li>角色<ol><li>角色的移动，可以用之前的<strong>FPS控制脚本</strong></li><li>角色的捡起道具，可以用之前的那个<strong>拾取脚本</strong><ol><li>捡起道具之后，需要考虑物体出现在人的手上</li></ol></li><li>角色的丢出道具<ol><li>角色按右键可以将道具丢下，那么需要物品是吸附到player身上的</li><li>角色长按进行蓄力，并且出现蓄力条，等待，松下按键即可扔出</li></ol></li><li>角色被物体击中，会产生碰撞并被弹出去</li><li>物体血量会存在，被击中会掉血</li></ol></li><li>道具<ol><li>可投掷类：全部都可投掷</li><li>左键普通攻击类<ol><li>每个武器或许有不同的动画</li></ol></li><li>左键特殊攻击类<ol><li>射击</li></ol></li></ol></li><li>联网：可以采用pun教程</li></ol><h2 id="2023回顾：已完成，最终做了一个类似橡胶强盗的游戏，当然是低配版本。"><a href="#2023回顾：已完成，最终做了一个类似橡胶强盗的游戏，当然是低配版本。" class="headerlink" title="2023回顾：已完成，最终做了一个类似橡胶强盗的游戏，当然是低配版本。"></a>2023回顾：已完成，最终做了一个类似橡胶强盗的游戏，当然是低配版本。</h2>]]></content>
      
      
      
        <tags>
            
            <tag> Unity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【OpenGL】第九章-纹理贴图</title>
      <link href="/2021/11/21/OpenGL-%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E7%BA%B9%E7%90%86%E8%B4%B4%E5%9B%BE/"/>
      <url>/2021/11/21/OpenGL-%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E7%BA%B9%E7%90%86%E8%B4%B4%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>为使用纹理贴图，步骤如下：</p><ol><li><h2 id="创建纹理对象，指定纹理"><a href="#创建纹理对象，指定纹理" class="headerlink" title="创建纹理对象，指定纹理"></a><strong>创建纹理对象，指定纹理</strong></h2></li><li><h2 id="确定纹理如何应用到每个像素上"><a href="#确定纹理如何应用到每个像素上" class="headerlink" title="确定纹理如何应用到每个像素上"></a><strong>确定纹理如何应用到每个像素上</strong></h2><ol><li>简单使用纹理颜色作为最后的颜色</li><li>用纹理来调整片段的颜色</li><li>根据纹理值，用常量颜色与片段颜色进行组合</li></ol></li><li><h2 id="启用纹理贴图功能"><a href="#启用纹理贴图功能" class="headerlink" title="启用纹理贴图功能"></a><strong>启用纹理贴图功能</strong></h2><ol><li><p>GL_TEXTURE_1D, GL_TEXTURE_2D, GL_TEXTURE_3D, or  GL_TEXTURE_CUBE_MAP</p><p>同时应该只启用一种纹理    </p></li></ol></li><li><h2 id="绘制场景，提供几何坐标和纹理贴图坐标"><a href="#绘制场景，提供几何坐标和纹理贴图坐标" class="headerlink" title="绘制场景，提供几何坐标和纹理贴图坐标"></a><strong>绘制场景，提供几何坐标和纹理贴图坐标</strong></h2></li></ol><p>注意：纹理贴图仅在RGBA模式下可以使用</p><h2 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;GL/glut.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*Create checkerboard texture*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>checkImageWidth 64</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>checkImageHeight 64</span></span><br><span class="line"><span class="keyword">static</span> GLubyte checkImage[checkImageHeight][checkImageWidth][<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> GL_VERSION_1_1</span></span><br><span class="line"><span class="keyword">static</span> GLuint texName;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">makeCheckImage</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j, c;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; checkImageHeight; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; checkImageWidth; j++) &#123;</span><br><span class="line">            c = (((i &amp; <span class="number">0x8</span>) == <span class="number">0</span>) ^ ((j &amp; <span class="number">0x8</span>)) == <span class="number">0</span>) * <span class="number">255</span>;</span><br><span class="line">            checkImage[i][j][<span class="number">0</span>] = (GLubyte)c;</span><br><span class="line">            checkImage[i][j][<span class="number">1</span>] = (GLubyte)c;</span><br><span class="line">            checkImage[i][j][<span class="number">2</span>] = (GLubyte)c;</span><br><span class="line">            checkImage[i][j][<span class="number">3</span>] = (GLubyte)<span class="number">255</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    glClearColor(<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>);</span><br><span class="line">    glShadeModel(GL_FLAT);</span><br><span class="line">    glEnable(GL_DEPTH_TEST);</span><br><span class="line"></span><br><span class="line">    makeCheckImage();</span><br><span class="line">    glPixelStorei(GL_UNPACK_ALIGNMENT, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> GL_VERSION_1_1</span></span><br><span class="line">    glGenTextures(<span class="number">1</span>, &amp;texName);</span><br><span class="line">    glBindTexture(GL_TEXTURE_2D, texName);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);</span><br><span class="line">    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);</span><br><span class="line">    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);</span><br><span class="line">    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> GL_VERSION_1_1</span></span><br><span class="line">    glTexImage2D(GL_TEXTURE_2D, <span class="number">0</span>, GL_RGBA, checkImageWidth, checkImageHeight,</span><br><span class="line">        <span class="number">0</span>, GL_RGBA, GL_UNSIGNED_BYTE, checkImage);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    glTexImage2D(GL_TEXTURE_2D, <span class="number">0</span>, <span class="number">4</span>, checkImageWidth, checkImageHeight,</span><br><span class="line">        <span class="number">0</span>, GL_RGBA, GL_UNSIGNED_BYTE, checkImage);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);</span><br><span class="line">    glEnable(GL_TEXTURE_2D);</span><br><span class="line">    glTexEnvf(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_DECAL);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> GL_VERSION_1_1</span></span><br><span class="line">    glBindTexture(GL_TEXTURE_2D, texName);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    glBegin(GL_QUADS);</span><br><span class="line">    glTexCoord2f(<span class="number">0.0</span>, <span class="number">0.0</span>); glVertex3f(<span class="number">-2.0</span>, <span class="number">-1.0</span>, <span class="number">0.0</span>);</span><br><span class="line">    glTexCoord2f(<span class="number">0.0</span>, <span class="number">1.0</span>); glVertex3f(<span class="number">-2.0</span>, <span class="number">1.0</span>, <span class="number">0.0</span>);</span><br><span class="line">    glTexCoord2f(<span class="number">1.0</span>, <span class="number">1.0</span>); glVertex3f(<span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">0.0</span>);</span><br><span class="line">    glTexCoord2f(<span class="number">1.0</span>, <span class="number">0.0</span>); glVertex3f(<span class="number">0.0</span>, <span class="number">-1.0</span>, <span class="number">0.0</span>);</span><br><span class="line"></span><br><span class="line">    glTexCoord2f(<span class="number">0.0</span>, <span class="number">0.0</span>); glVertex3f(<span class="number">1.0</span>, <span class="number">-1.0</span>, <span class="number">0.0</span>);</span><br><span class="line">    glTexCoord2f(<span class="number">0.0</span>, <span class="number">1.0</span>); glVertex3f(<span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">0.0</span>);</span><br><span class="line">    glTexCoord2f(<span class="number">1.0</span>, <span class="number">1.0</span>); glVertex3f(<span class="number">2.41421</span>, <span class="number">1.0</span>, <span class="number">-1.41421</span>);</span><br><span class="line">    glTexCoord2f(<span class="number">1.0</span>, <span class="number">0.0</span>); glVertex3f(<span class="number">2.41421</span>, <span class="number">-1.0</span>, <span class="number">-1.41421</span>);</span><br><span class="line">    glEnd();</span><br><span class="line">    glFlush();</span><br><span class="line">    glDisable(GL_TEXTURE_2D);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reshape</span><span class="params">(<span class="keyword">int</span> w, <span class="keyword">int</span> h)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    glViewport(<span class="number">0</span>, <span class="number">0</span>, (GLsizei)w, (GLsizei)h);</span><br><span class="line">    glMatrixMode(GL_PROJECTION);</span><br><span class="line">    glLoadIdentity();</span><br><span class="line">    gluPerspective(<span class="number">60.0</span>, (GLfloat)w / (GLfloat)h, <span class="number">1.0</span>, <span class="number">30.0</span>);</span><br><span class="line">    glMatrixMode(GL_MODELVIEW);</span><br><span class="line">    glLoadIdentity();</span><br><span class="line">    glTranslatef(<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">-3.6</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">keyboard</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> key, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (key) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">27</span>:</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    glutInit(&amp;argc, argv);</span><br><span class="line">    glutInitDisplayMode(GLUT_SINGLE | GLUT_RGB | GLUT_DEPTH);</span><br><span class="line">    glutInitWindowSize(<span class="number">250</span>, <span class="number">250</span>);</span><br><span class="line">    glutInitWindowPosition(<span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line">    glutCreateWindow(argv[<span class="number">0</span>]);</span><br><span class="line">    init();</span><br><span class="line">    glutDisplayFunc(display);</span><br><span class="line">    glutReshapeFunc(reshape);</span><br><span class="line">    glutKeyboardFunc(keyboard);</span><br><span class="line">    glutMainLoop();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="详解"><a href="#详解" class="headerlink" title="详解"></a>详解</h1><h2 id="指定纹理"><a href="#指定纹理" class="headerlink" title="指定纹理"></a>指定纹理</h2><h3 id="glTexImage2D-函数用于指定二维纹理："><a href="#glTexImage2D-函数用于指定二维纹理：" class="headerlink" title="glTexImage2D() 函数用于指定二维纹理："></a>glTexImage2D() 函数用于指定二维纹理：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">glTexImage2D</span><span class="params">(GLenum target, GLint level, GLint internalFormat,</span></span></span><br><span class="line"><span class="params"><span class="function">GLsizei width, GLsizei height, GLint border,</span></span></span><br><span class="line"><span class="params"><span class="function">GLenum format, GLenum type, <span class="keyword">const</span> GLvoid *texels)</span></span>;</span><br></pre></td></tr></table></figure><p>target：定义了二维纹理</p><p>level：如果有多种分辨率的纹理，可以使用level，否则0</p><p>internalFormat：确定有哪些成分（RGBA，深度，亮度，强度）被选为图像的纹理单元。</p><p>width和height：表示纹理图像的宽高</p><p>border：边框的宽度</p><p>format和type：纹理图像的格式和数据类型</p><p>最后的texel：包含纹理图像数据，描绘它本身和边框</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">glTexImage2D(GL_TEXTURE_2D, <span class="number">0</span>, GL_RGBA, checkImageWidth, checkImageHeight,</span><br><span class="line">        <span class="number">0</span>, GL_RGBA, GL_UNSIGNED_BYTE, checkImage);<span class="comment">//具体例子</span></span><br></pre></td></tr></table></figure><h3 id="gluScaleImage-更改纹理的大小"><a href="#gluScaleImage-更改纹理的大小" class="headerlink" title="gluScaleImage() 更改纹理的大小"></a>gluScaleImage() 更改纹理的大小</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gluScaleImage</span><span class="params">(GLenum format, GLint widthin, GLint heightin,</span></span></span><br><span class="line"><span class="params"><span class="function">GLenum typein, <span class="keyword">const</span> <span class="keyword">void</span> *datain, GLint widthout,</span></span></span><br><span class="line"><span class="params"><span class="function">GLint heightout, GLenum typeout, <span class="keyword">void</span> *dataout)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="glCopyTexImage2D-从帧缓冲区取出矩形，作为纹理"><a href="#glCopyTexImage2D-从帧缓冲区取出矩形，作为纹理" class="headerlink" title="glCopyTexImage2D() 从帧缓冲区取出矩形，作为纹理"></a>glCopyTexImage2D() 从帧缓冲区取出矩形，作为纹理</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">glCopyTexImage2D</span><span class="params">(GLenum target, GLint level,</span></span></span><br><span class="line"><span class="params"><span class="function">GLint internalFormat, GLint x, GLint y,</span></span></span><br><span class="line"><span class="params"><span class="function">GLsizei width, GLsizei height, GLint border)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="1-纹理代理-Texture-Proxy-（没懂）"><a href="#1-纹理代理-Texture-Proxy-（没懂）" class="headerlink" title="1. 纹理代理 Texture Proxy （没懂）"></a>1. 纹理代理 Texture Proxy （没懂）</h3><p>用于判断当前OpenGL实现在<strong>某种特定的纹理大小</strong>下是否支持<strong>某种特定的纹理格式</strong>。    </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> glGetTexLevelParameter&#123;<span class="keyword">if</span>&#125;v(GLenum target, GLint level, GLenum pname, TYPE *params); </span><br><span class="line"><span class="comment">//下面是例子</span></span><br><span class="line">GLint width;</span><br><span class="line"> glTexImage2D(GL_PROXY_TEXTURE_2D, <span class="number">0</span>, GL_RGBA8, <span class="number">64</span>, <span class="number">64</span>, <span class="number">0</span>, GL_RGBA, GL_UNSIGNED_BYTE, <span class="literal">NULL</span>);</span><br><span class="line"> glGetTexLevelParameteriv(GL_PROXY_TEXTURE_2D, <span class="number">0</span>, GL_TEXTURE_WIDTH, &amp;width);</span><br></pre></td></tr></table></figure><h3 id="2-替换纹理的部分"><a href="#2-替换纹理的部分" class="headerlink" title="2.替换纹理的部分"></a>2.替换纹理的部分</h3><p>修改纹理开销小，故替换</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">glTexSubImage2D</span><span class="params">(GLenum target, GLint level, GLint xoffset,</span></span></span><br><span class="line"><span class="params"><span class="function">                     GLint yoffset, GLsizei width, GLsizei height,</span></span></span><br><span class="line"><span class="params"><span class="function">                     GLenum format, GLenum type,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">const</span> GLvoid *texels)</span></span>;</span><br></pre></td></tr></table></figure><p>另外，也可以从帧缓冲区复制像素矩形，替换纹理</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">glCopyTexSubImage2D</span><span class="params">(GLenum target, GLint level, GLint xoffset,</span></span></span><br><span class="line"><span class="params"><span class="function">GLint yoffset, GLint x, GLint y,</span></span></span><br><span class="line"><span class="params"><span class="function">                        GLsizei width, GLsizei height)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="3-一维纹理"><a href="#3-一维纹理" class="headerlink" title="3.一维纹理"></a>3.一维纹理</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">glTexImage1D</span><span class="params">(GLenum target, GLint level, GLint internalFormat,</span></span></span><br><span class="line"><span class="params"><span class="function">GLsizei width, GLint border, GLenum format,</span></span></span><br><span class="line"><span class="params"><span class="function">GLenum type, <span class="keyword">const</span> GLvoid *texels)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="4-三维纹理"><a href="#4-三维纹理" class="headerlink" title="4.三维纹理"></a>4.三维纹理</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">glTexImage3D</span><span class="params">(GLenum target, GLint level, GLint internalFormat,</span></span></span><br><span class="line"><span class="params"><span class="function">GLsizei width, GLsizei height, GLsizei depth,</span></span></span><br><span class="line"><span class="params"><span class="function">GLint border, GLenum format, GLenum type,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">const</span> GLvoid *texels)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="5-mipmap：多重细节层"><a href="#5-mipmap：多重细节层" class="headerlink" title="5.mipmap：多重细节层"></a>5.mipmap：多重细节层</h3><p>​    为避免缩放时的纹理图像突然变化，预先可以指定分辨率递减的纹理图像，即<strong>mipmap</strong>。OpenGL用mipmap时，可以自动根据被贴物体的大小，自动确定使用的纹理。</p><p>​    为使用<strong>mipmap，必须有全系列大小为2的次数级的图形纹理</strong>。例如32x8,16z4,8x2,4x1,2x1,1x1。较小的图像每个纹理单位是高一级的4的纹理单位的平均值。</p><p>​    可以依次调用glTexImage2D()生成每种分辨率的纹理图像。</p><p>​    为使mipmap生效，还要选择<strong>适当的过滤模式</strong>。</p><h4 id="实际应用中构造mipmap"><a href="#实际应用中构造mipmap" class="headerlink" title="实际应用中构造mipmap"></a>实际应用中构造mipmap</h4><p>​    <strong>它将为绑定到一个特定纹理目标的纹理图像创建mipmap堆栈。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">glGenerateMipmap</span><span class="params">(GLenum target)</span></span>;</span><br></pre></td></tr></table></figure><hr><h2 id="过滤"><a href="#过滤" class="headerlink" title="过滤"></a>过滤</h2><p>…跳过</p><hr><h2 id="纹理对象"><a href="#纹理对象" class="headerlink" title="纹理对象"></a>纹理对象</h2><p>有些OpenGL支持一种容量有限的高性能纹理工作集（<em>a limited working set of high performance textures</em>），可以把常用纹理加载到这个区域里。</p><ol><li>生成纹理名称</li><li>初次把纹理对象绑定到纹理数据上，包括图像数组和纹理属性</li><li>检查区域的空间是否足够</li><li>绑定和重新绑定纹理对象，使用</li></ol><h3 id="1-命名纹理对象"><a href="#1-命名纹理对象" class="headerlink" title="1.命名纹理对象"></a>1.命名纹理对象</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">glGenTextures</span><span class="params">(GLsizei n, GLuint *textureNames)</span></span>;</span><br></pre></td></tr></table></figure><p>判断纹理名称是否被使用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">GLboolean <span class="title">glIsTexture</span><span class="params">(GLuint textureName)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="2-创建和使用纹理"><a href="#2-创建和使用纹理" class="headerlink" title="2.创建和使用纹理"></a>2.创建和使用纹理</h3><p>可以用glBindTexture()创建和使用纹理。当纹理对象名称初次绑定时，会创建新的纹理对象，并把纹理图像和属性设为默认。然后用其他函数把数据存在这个纹理对象中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">glBindTexture</span><span class="params">(GLenum target, GLuint textureName)</span></span>;</span><br></pre></td></tr></table></figure><p>下面是一个小栗子</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;GL/glut.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> GL_VERSION_1_1</span></span><br><span class="line"><span class="comment">/*Create checkerboard texture*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>checkImageWidth 64</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>checkImageHeight 64</span></span><br><span class="line"><span class="keyword">static</span> GLubyte checkImage[checkImageHeight][checkImageWidth][<span class="number">4</span>];</span><br><span class="line"><span class="keyword">static</span> GLubyte otherImage[checkImageHeight][checkImageWidth][<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> GLuint texName[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">makeCheckImages</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j, c;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; checkImageHeight; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; checkImageWidth; j++) &#123;</span><br><span class="line">            c = ((((i &amp; <span class="number">0x8</span>) == <span class="number">0</span>) ^ ((j &amp; <span class="number">0x8</span>)) == <span class="number">0</span>)) * <span class="number">255</span>;</span><br><span class="line">            checkImage[i][j][<span class="number">0</span>] = (GLubyte)c;</span><br><span class="line">            checkImage[i][j][<span class="number">1</span>] = (GLubyte)c;</span><br><span class="line">            checkImage[i][j][<span class="number">2</span>] = (GLubyte)c;</span><br><span class="line">            checkImage[i][j][<span class="number">3</span>] = (GLubyte)<span class="number">255</span>;</span><br><span class="line">            c = ((((i &amp; <span class="number">0x10</span>) == <span class="number">0</span>) ^ ((j &amp; <span class="number">0x10</span>)) == <span class="number">0</span>)) * <span class="number">255</span>;</span><br><span class="line">            otherImage[i][j][<span class="number">0</span>] = (GLubyte)c;</span><br><span class="line">            otherImage[i][j][<span class="number">1</span>] = (GLubyte)<span class="number">0</span>;</span><br><span class="line">            otherImage[i][j][<span class="number">2</span>] = (GLubyte)<span class="number">0</span>;</span><br><span class="line">            otherImage[i][j][<span class="number">3</span>] = (GLubyte)<span class="number">255</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    glClearColor(<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>);</span><br><span class="line">    glShadeModel(GL_FLAT);</span><br><span class="line">    glEnable(GL_DEPTH_TEST);</span><br><span class="line"></span><br><span class="line">    makeCheckImages();</span><br><span class="line">    glPixelStorei(GL_UNPACK_ALIGNMENT, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    glGenTextures(<span class="number">2</span>, texName);</span><br><span class="line">    glBindTexture(GL_TEXTURE_2D, texName[<span class="number">0</span>]);</span><br><span class="line">    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP);</span><br><span class="line">    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP);</span><br><span class="line">    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER,</span><br><span class="line">        GL_NEAREST);</span><br><span class="line">    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER,</span><br><span class="line">        GL_NEAREST);</span><br><span class="line">    glTexImage2D(GL_TEXTURE_2D, <span class="number">0</span>, GL_RGBA, checkImageWidth,</span><br><span class="line">        checkImageHeight, <span class="number">0</span>, GL_RGBA, GL_UNSIGNED_BYTE,</span><br><span class="line">        checkImage);</span><br><span class="line"></span><br><span class="line">    glBindTexture(GL_TEXTURE_2D, texName[<span class="number">1</span>]);</span><br><span class="line">    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP);</span><br><span class="line">    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP);</span><br><span class="line">    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);</span><br><span class="line">    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);</span><br><span class="line">    glTexEnvf(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_DECAL);</span><br><span class="line">    glTexImage2D(GL_TEXTURE_2D, <span class="number">0</span>, GL_RGBA, checkImageWidth,</span><br><span class="line">        checkImageHeight, <span class="number">0</span>, GL_RGBA, GL_UNSIGNED_BYTE,</span><br><span class="line">        otherImage);</span><br><span class="line">    glEnable(GL_TEXTURE_2D);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);</span><br><span class="line">    glBindTexture(GL_TEXTURE_2D, texName[<span class="number">0</span>]);</span><br><span class="line">    glBegin(GL_QUADS);</span><br><span class="line">    glTexCoord2f(<span class="number">0.0</span>, <span class="number">0.0</span>); glVertex3f(<span class="number">-2.0</span>, <span class="number">-1.0</span>, <span class="number">0.0</span>);</span><br><span class="line">    glTexCoord2f(<span class="number">0.0</span>, <span class="number">1.0</span>); glVertex3f(<span class="number">-2.0</span>, <span class="number">1.0</span>, <span class="number">0.0</span>);</span><br><span class="line">    glTexCoord2f(<span class="number">1.0</span>, <span class="number">1.0</span>); glVertex3f(<span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">0.0</span>);</span><br><span class="line">    glTexCoord2f(<span class="number">1.0</span>, <span class="number">0.0</span>); glVertex3f(<span class="number">0.0</span>, <span class="number">-1.0</span>, <span class="number">0.0</span>);</span><br><span class="line">    glEnd();</span><br><span class="line">    glBindTexture(GL_TEXTURE_2D, texName[<span class="number">1</span>]);</span><br><span class="line">    glBegin(GL_QUADS);</span><br><span class="line">    glTexCoord2f(<span class="number">0.0</span>, <span class="number">0.0</span>); glVertex3f(<span class="number">1.0</span>, <span class="number">-1.0</span>, <span class="number">0.0</span>);</span><br><span class="line">    glTexCoord2f(<span class="number">0.0</span>, <span class="number">1.0</span>); glVertex3f(<span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">0.0</span>);</span><br><span class="line">    glTexCoord2f(<span class="number">1.0</span>, <span class="number">1.0</span>); glVertex3f(<span class="number">2.41421</span>, <span class="number">1.0</span>, <span class="number">-1.41421</span>);</span><br><span class="line">    glTexCoord2f(<span class="number">1.0</span>, <span class="number">0.0</span>); glVertex3f(<span class="number">2.41421</span>, <span class="number">-1.0</span>, <span class="number">-1.41421</span>);</span><br><span class="line">    glEnd();</span><br><span class="line">    glFlush();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reshape</span><span class="params">(<span class="keyword">int</span> w, <span class="keyword">int</span> h)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    glViewport(<span class="number">0</span>, <span class="number">0</span>, (GLsizei)w, (GLsizei)h);</span><br><span class="line">    glMatrixMode(GL_PROJECTION);</span><br><span class="line">    glLoadIdentity();</span><br><span class="line">    gluPerspective(<span class="number">60.0</span>, (GLfloat)w / (GLfloat)h, <span class="number">1.0</span>, <span class="number">30.0</span>);</span><br><span class="line">    glMatrixMode(GL_MODELVIEW);</span><br><span class="line">    glLoadIdentity();</span><br><span class="line">    glTranslatef(<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">-3.6</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">keyboard</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> key, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (key) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">27</span>:</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    glutInit(&amp;argc, argv);</span><br><span class="line">    glutInitDisplayMode(GLUT_SINGLE | GLUT_RGB | GLUT_DEPTH);</span><br><span class="line">    glutInitWindowSize(<span class="number">250</span>, <span class="number">250</span>);</span><br><span class="line">    glutInitWindowPosition(<span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line">    glutCreateWindow(argv[<span class="number">0</span>]);</span><br><span class="line">    init();</span><br><span class="line">    glutReshapeFunc(reshape);</span><br><span class="line">    glutDisplayFunc(display);</span><br><span class="line">    glutKeyboardFunc(keyboard);</span><br><span class="line">    glutMainLoop();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;This program demonstrates a feature which is not in OpenGL Version 1.0.\n&quot;</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;If your implementation of OpenGL Version 1.0 has the right extensions,\n&quot;</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;you may be able to modify this program to make it run.\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><h3 id="3-清除纹理对象"><a href="#3-清除纹理对象" class="headerlink" title="3.清除纹理对象"></a>3.清除纹理对象</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">glDeleteTextures</span><span class="params">(GLsizei n, <span class="keyword">const</span> GLuint *textureNames)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="4-常驻纹理工作集"><a href="#4-常驻纹理工作集" class="headerlink" title="4.常驻纹理工作集"></a>4.常驻纹理工作集</h3><hr><h2 id="纹理函数"><a href="#纹理函数" class="headerlink" title="纹理函数"></a>纹理函数</h2><p>可以通过以下函数提供适当参数来选择纹理函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> glTexEnv&#123;<span class="keyword">if</span>&#125;(GLenum target, GLenum pname, TYPE param);</span><br><span class="line"><span class="keyword">void</span> glTexEnv&#123;<span class="keyword">if</span>&#125;v(GLenum target, GLenum pname, <span class="keyword">const</span> TYPE *param);</span><br></pre></td></tr></table></figure><p>//待写2021年11月21日</p><h2 id="纹理坐标自动生成"><a href="#纹理坐标自动生成" class="headerlink" title="纹理坐标自动生成"></a>纹理坐标自动生成</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> glTexGen&#123;ifd&#125;(GLenum coord, GLenum pname, TYPE param);</span><br><span class="line"><span class="keyword">void</span> glTexGen&#123;ifd&#125;v(GLenum coord, GLenum pname, <span class="keyword">const</span> TYPE *param);</span><br></pre></td></tr></table></figure><p>是的，看不懂，有缘再看。</p><h3 id="球体纹理"><a href="#球体纹理" class="headerlink" title="球体纹理"></a>球体纹理</h3><p>环境纹理的目的是渲染具有完美反射能力的物体。如擦的亮亮的银器，终结者2中的液态机器人。</p>]]></content>
      
      
      
        <tags>
            
            <tag> OpenGL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Unity Shader】CG标准函数库常用函数</title>
      <link href="/2021/11/21/CG%E6%A0%87%E5%87%86%E5%87%BD%E6%95%B0%E5%BA%93%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/"/>
      <url>/2021/11/21/CG%E6%A0%87%E5%87%86%E5%87%BD%E6%95%B0%E5%BA%93%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p>CG标准函数库常用函数，适用于Unity的Shader之中。</p><span id="more"></span><h1 id="CG标准函数库常用函数"><a href="#CG标准函数库常用函数" class="headerlink" title="CG标准函数库常用函数"></a>CG标准函数库常用函数</h1><h2 id="（1）数学函数"><a href="#（1）数学函数" class="headerlink" title="（1）数学函数"></a>（1）数学函数</h2><table><thead><tr><th align="left">函数</th><th align="left">功能描述</th></tr></thead><tbody><tr><td align="left">abs(x)</td><td align="left">返回输入参数的绝对值</td></tr><tr><td align="left">acos(x)</td><td align="left">反余切函数，输入参数范围为[-1,1]， 返回[0,π]区间的角度值</td></tr><tr><td align="left">all(x)</td><td align="left">如果输入参数均不为0，则返回ture； 否则返回flase。&amp;&amp;运算</td></tr><tr><td align="left">any(x)</td><td align="left">输入参数只要有其中一个不为0，则返回true。</td></tr><tr><td align="left">asin(x)</td><td align="left">反正弦函数,输入参数取值区间为，返回角度值范围为,</td></tr><tr><td align="left">atan(x)</td><td align="left">反正切函数，返回角度值范围为</td></tr><tr><td align="left">atan2(y,x)</td><td align="left">计算y/x的反正切值。实际上和atan(x)函数功能完全一样，至少输入参数不同。atan(x) = atan2(x, float(1))。</td></tr><tr><td align="left">ceil(x)</td><td align="left">对输入参数向上取整。例如： ceil(float(1.3)) ，其返回值为2.0</td></tr><tr><td align="left">clamp(x,a,b)</td><td align="left">如果x值小于a，则返回a； 如果x值大于b，返回b； 否则，返回x。</td></tr><tr><td align="left">cos(x)</td><td align="left">返回弧度x的余弦值。返回值范围为</td></tr><tr><td align="left">cosh(x)</td><td align="left">双曲余弦（hyperbolic cosine）函数，计算x的双曲余弦值。</td></tr><tr><td align="left">cross(A,B)</td><td align="left">返回两个三元向量的叉积(cross product)。注意，输入参数必须是三元向量！</td></tr><tr><td align="left">degrees(x)</td><td align="left">输入参数为弧度值(radians)，函数将其转换为角度值(degrees)</td></tr><tr><td align="left">determinant(m)</td><td align="left">计算矩阵的行列式因子。</td></tr><tr><td align="left">dot(A,B)</td><td align="left">返回A和B的点积(dot product)。参数A和B可以是标量，也可以是向量（输入参数方面，点积和叉积函数有很大不同）。</td></tr><tr><td align="left">exp(x)</td><td align="left">计算的值，e=2.71828182845904523536</td></tr><tr><td align="left">exp2(x)</td><td align="left">计算的值</td></tr><tr><td align="left">floor(x)</td><td align="left">对输入参数向下取整。例如floor(float(1.3))返回的值为1.0；但是floor(float(-1.3))返回的值为-2.0。该函数与ceil(x)函数相对应。</td></tr><tr><td align="left">fmod(x,y)</td><td align="left">返回x/y的余数。如果y为0，结果不可预料。</td></tr><tr><td align="left">frac(x)</td><td align="left">返回标量或矢量的小数</td></tr><tr><td align="left">frexp(x, out i)</td><td align="left">将浮点数x分解为尾数和指数，即， 返回m，并将指数存入i中；如果x为0，则尾数和指数都返回0</td></tr><tr><td align="left">isfinite(x)</td><td align="left">判断标量或者向量中的每个数据是否是有限数，如果是返回true；否则返回false;</td></tr><tr><td align="left">isinf(x)</td><td align="left">判断标量或者向量中的每个数据是否是无限，如果是返回true；否则返回false;</td></tr><tr><td align="left">isnan(x)</td><td align="left">判断标量或者向量中的每个数据是否是非数据(not-a-number NaN)，如果是返回true；否则返回false;</td></tr><tr><td align="left">ldexp(x, n)</td><td align="left">计算的值</td></tr><tr><td align="left">lerp(a, b, f)</td><td align="left">计算或者的值。即在下限a和上限b之间进行插值，f表示权值。注意，如果a和b是向量，则权值f必须是标量或者等长的向量。</td></tr><tr><td align="left">lit(NdotL, NdotH, m)</td><td align="left">N表示法向量； L表示入射光向量； H表示半角向量； m表示高光系数。  函数计算环境光、散射光、镜面光的贡献，返回的4元向量。  X位表示环境光的贡献，总是1.0;  Y位代表散射光的贡献，如果 ，则为0；否则为  Z位代表镜面光的贡献，如果 或者，则位0；否则为; W位始终位1.0</td></tr><tr><td align="left">log(x)</td><td align="left">计算的值，x必须大于0</td></tr><tr><td align="left">log2(x)</td><td align="left">计算的值，x必须大于0</td></tr><tr><td align="left">log10(x)</td><td align="left">计算的值，x必须大于0</td></tr><tr><td align="left">max(a, b)</td><td align="left">比较两个标量或等长向量元素，返回最大值。</td></tr><tr><td align="left">min(a,b)</td><td align="left">比较两个标量或等长向量元素，返回最小值。</td></tr><tr><td align="left">modf(x, out ip)</td><td align="left">把x分解成整数和分数两部分，每部分都和x有着相同的符号，整数部分被保存在ip中，分数部分由函数返回</td></tr><tr><td align="left">mul(M, N)</td><td align="left">矩阵M和矩阵N的积，计算方法如下</td></tr><tr><td align="left">mul(M, v)</td><td align="left">矩阵M和列向量v的积，公式如下</td></tr><tr><td align="left">mul(v, M)</td><td align="left">行向量v和矩阵M的积，公式如下</td></tr><tr><td align="left">noise(x)</td><td align="left">根据它的参数类型，这个函数可以是一元、二元或三元噪音函数。返回的值在0和1之间，并且通常与给定的输入值一样</td></tr><tr><td align="left">pow(x, y)</td><td align="left"></td></tr><tr><td align="left">radians(x)</td><td align="left">函数将角度值转换为弧度值</td></tr><tr><td align="left">round(x)</td><td align="left">返回四舍五入值。</td></tr><tr><td align="left">rsqrt(x)</td><td align="left">x的平方根的倒数，x必须大于0</td></tr><tr><td align="left">saturate(x)</td><td align="left">把x限制到[0,1]之间</td></tr><tr><td align="left">sign(x)</td><td align="left">如果则返回1；否则返回0</td></tr><tr><td align="left">sin(x)</td><td align="left">输入参数为弧度，计算正弦值，返回值范围 为[-1,1]</td></tr><tr><td align="left">sincos(float x, out s, out c)</td><td align="left">该函数是同时计算x的sin值和cos值，其中s=sin(x)，c=cos(x)。该函数用于“同时需要计算sin值和cos值的情况”，比分别运算要快很多!</td></tr><tr><td align="left">sinh(x)</td><td align="left">计算x的双曲正弦</td></tr><tr><td align="left">smoothstep(min, max, x)</td><td align="left">值x位于min、max区间中。如果x=min，返回0；如果x=max，返回1；如果x在两者之间，按照下列公式返回数据：</td></tr><tr><td align="left">step(a, x)</td><td align="left">如果，返回0；否则，返回1</td></tr><tr><td align="left">sqrt(x)</td><td align="left">求x的平方根，，x必须大于0</td></tr><tr><td align="left">tan(x)</td><td align="left">计算x正切值</td></tr><tr><td align="left">tanh(x)</td><td align="left">计算x的双曲线切线</td></tr><tr><td align="left">transpose(M)</td><td align="left">矩阵M的转置矩阵 如果M是一个AxB矩阵，M的转置是一个BxA矩阵，它的第一列是M的第一行，第二列是M的第二行，第三列是M的第三行，等等</td></tr></tbody></table><h2 id="（2）几何函数"><a href="#（2）几何函数" class="headerlink" title="（2）几何函数"></a>（2）几何函数</h2><table><thead><tr><th align="left">函数</th><th align="left">功能描述</th></tr></thead><tbody><tr><td align="left">distance(pt1, pt2)</td><td align="left">两点之间的欧几里德距离（Euclidean distance）</td></tr><tr><td align="left">faceforward(N,I,Ng)</td><td align="left">如果，返回N；否则返回-N。</td></tr><tr><td align="left">length(v)</td><td align="left">返回一个向量的模，即sqrt(dot(v,v))</td></tr><tr><td align="left">normalize(v)</td><td align="left">返回v向量的单位向量</td></tr><tr><td align="left">reflect(I, N)</td><td align="left">根据入射光纤方向I和表面法向量N计算反射向量，仅对三元向量有效</td></tr><tr><td align="left">refract(I,N,eta)</td><td align="left">根据入射光线方向I，表面法向量N和折射相对系数eta,计算折射向量。如果对给定的eta,I和N之间的角度太大，返回(0,0,0)。 只对三元向量有效</td></tr></tbody></table><h2 id="（3）纹理映射函数"><a href="#（3）纹理映射函数" class="headerlink" title="（3）纹理映射函数"></a>（3）纹理映射函数</h2><table><thead><tr><th align="left">函数</th><th align="left">功能描述</th></tr></thead><tbody><tr><td align="left">tex1D(sampler1D tex, float s)</td><td align="left">一维纹理查询</td></tr><tr><td align="left">tex1D(sampler1D tex, float s, float dsdx, float dsdy)</td><td align="left">使用导数值（derivatives）查询一维纹理</td></tr><tr><td align="left">Tex1D(sampler1D tex, float2 sz)</td><td align="left">一维纹理查询，并进行深度值比较</td></tr><tr><td align="left">Tex1D(sampler1D tex, float2 sz, float dsdx,float dsdy)</td><td align="left">使用导数值（derivatives）查询一维纹理， 并进行深度值比较</td></tr><tr><td align="left">Tex1Dproj(sampler1D tex, float2 sq)</td><td align="left">一维投影纹理查询</td></tr><tr><td align="left">Tex1Dproj(sampler1D tex, float3 szq)</td><td align="left">一维投影纹理查询，并比较深度值</td></tr><tr><td align="left">Tex2D(sampler2D tex, float2 s)</td><td align="left">二维纹理查询</td></tr><tr><td align="left">Tex2D(sampler2D tex, float2 s, float2 dsdx, float2 dsdy)</td><td align="left">使用导数值（derivatives）查询二维纹理</td></tr><tr><td align="left">Tex2D(sampler2D tex, float3 sz)</td><td align="left">二维纹理查询，并进行深度值比较</td></tr><tr><td align="left">Tex2D(sampler2D tex, float3 sz, float2 dsdx,float2 dsdy)</td><td align="left">使用导数值（derivatives）查询二维纹理，并进行深度值比较</td></tr><tr><td align="left">Tex2Dproj(sampler2D tex, float3 sq)</td><td align="left">二维投影纹理查询</td></tr><tr><td align="left">Tex2Dproj(sampler2D tex, float4 szq)</td><td align="left">二维投影纹理查询，并进行深度值比较</td></tr><tr><td align="left">texRECT(samplerRECT tex, float2 s)</td><td align="left">二维非投影矩形纹理查询（OpenGL独有）</td></tr><tr><td align="left">texRECT (samplerRECT tex, float3 sz, float2 dsdx,float2 dsdy)</td><td align="left">二维非投影使用导数的矩形纹理查询（OpenGL独有）</td></tr><tr><td align="left">texRECT (samplerRECT tex, float3 sz)</td><td align="left">二维非投影深度比较矩形纹理查询（OpenGL独有）</td></tr><tr><td align="left">texRECT (samplerRECT tex, float3 sz, float2 dsdx,float2 dsdy)</td><td align="left">二维非投影深度比较并使用导数的矩形纹理查询（OpenGL独有）</td></tr><tr><td align="left">texRECT proj(samplerRECT tex, float3 sq)</td><td align="left">二维投影矩形纹理查询（OpenGL独有）</td></tr><tr><td align="left">texRECT proj(samplerRECT tex, float3 szq)</td><td align="left">二维投影矩形纹理深度比较查询（OpenGL独有）</td></tr><tr><td align="left">Tex3D(sampler3D tex, float s)</td><td align="left">三维纹理查询</td></tr><tr><td align="left">Tex3D(sampler3D tex, float3 s, float3 dsdx, float3 dsdy)</td><td align="left">结合导数值（derivatives）查询三维纹理</td></tr><tr><td align="left">Tex3Dproj(sampler3D tex, float4 szq)</td><td align="left">查询三维投影纹理，并进行深度值比较</td></tr><tr><td align="left">texCUBE(samplerCUBE tex, float3 s)</td><td align="left">查询立方体纹理</td></tr><tr><td align="left">texCUBE (samplerCUBE tex, float3 s, float3 dsdx, float3 dsdy)</td><td align="left">结合导数值（derivatives）查询立方体纹理</td></tr><tr><td align="left">texCUBEproj (samplerCUBE tex, float4 sq)</td><td align="left">查询投影立方体纹理</td></tr></tbody></table><p>在这个表中，每个函数第二个参数的名字指明了在执行纹理查询的时候，它的值是如果被使用的:</p><ul><li>s表示这是一个一元、二元或三元纹理坐标。</li><li>z表示这是一个用来进行阴影贴图查找的深度比较值。</li><li>q表示这是一个透视值，在进行纹理查找之前，它被用来除以纹理坐标（s）。</li></ul><p>当你使用的纹理函数允许你指定一个深度比较值的时候，与之相关联的纹理单元必须被设置成深度比较纹理。否则，深度比较实际上不会被执行。 </p><h2 id="（4）偏导函数"><a href="#（4）偏导函数" class="headerlink" title="（4）偏导函数"></a>（4）偏导函数</h2><table><thead><tr><th align="left">函数</th><th align="left">功能描述</th></tr></thead><tbody><tr><td align="left">ddx(a)</td><td align="left">近似a关于屏幕空间x轴的偏导数</td></tr><tr><td align="left">ddy(a)</td><td align="left">近似a关于屏幕空间y轴的偏导数</td></tr></tbody></table><h2 id="（5）调试函数"><a href="#（5）调试函数" class="headerlink" title="（5）调试函数"></a>（5）调试函数</h2><table><thead><tr><th align="left">函数</th><th align="left">功能描述</th></tr></thead><tbody><tr><td align="left">void debug(float4 x)</td><td align="left">如果在编译时设置了DEBUG，片段着 色程序中调用该函数可以将值x作为COLOR语义的最终输出；否则该函数什么也不做。</td></tr></tbody></table><p>转载自 <a href="https://blog.csdn.net/jingmengshenaaa/article/details/52809879">https://blog.csdn.net/jingmengshenaaa/article/details/52809879</a></p><p><a href="https://www.cnblogs.com/nanwei/p/7287940.html">https://www.cnblogs.com/nanwei/p/7287940.html</a></p><p>仅供参考</p>]]></content>
      
      
      
        <tags>
            
            <tag> Unity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Unity 渲染】图形渲染流水线</title>
      <link href="/2021/11/20/%E5%9B%BE%E5%BD%A2%E6%B8%B2%E6%9F%93%E6%B5%81%E6%B0%B4%E7%BA%BF/"/>
      <url>/2021/11/20/%E5%9B%BE%E5%BD%A2%E6%B8%B2%E6%9F%93%E6%B5%81%E6%B0%B4%E7%BA%BF/</url>
      
        <content type="html"><![CDATA[<p>图形渲染流水线，顶点在不同空间的变换，GPU渲染流水线，Shader概念</p><span id="more"></span><p>今天看shader的时候，搜了一个问题，被答主建议重新巩固渲染流水线的知识，想来也是…</p><hr><h2 id="渲染流水线"><a href="#渲染流水线" class="headerlink" title="渲染流水线"></a>渲染流水线</h2><p>​    模型从3D的数据（顶点坐标，法线坐标，UV纹理坐标），到最后在屏幕上的2D图像，中间需要很多过程。这大段过程在GPU上，就像流水线一样，疯狂不断地进行，故称渲染流水线。</p><hr><h2 id="3D图形渲染完整流水线"><a href="#3D图形渲染完整流水线" class="headerlink" title="3D图形渲染完整流水线"></a>3D图形渲染完整流水线</h2><p>下面列举一个通用的流水线，当然具体引擎会有不同，但大体如此。</p><p><strong>1.建立场景</strong>：对场景进行预先设置，如摄像机视角，灯光雾化设置</p><p><strong>2.可见性检测</strong>：基于摄像机对所有物体检测可见性，可以减少资源损耗。</p><p><strong>3.设置渲染状态</strong>：对具体物体有不同的渲染设置。</p><p><strong>4.几何体生成与提交</strong>：向渲染api提交几何体数据，一般内容为三角形的顶点数据。如顶点坐标，法线坐标，UV纹理坐标。</p><p><strong>5.变换与光照</strong>：将顶点坐标从模型空间变换到摄像机空间，并进行顶点光照计算（是否不一定）</p><p><strong>6.背面剔除与裁剪</strong>：变换到摄像机空间后，背对着摄像机的三角形被剔除。再转换到裁切空间，将视锥体外面的部分裁切掉。</p><p><strong>7.投影到屏幕空间</strong>：裁切后的三角形通过投影从三维变到平面，输出到屏幕空间中。</p><p><strong>8.光栅化</strong>：屏幕空间中的几何体通过光栅化转变为2D的像素信息。</p><p><strong>9.像素着色</strong>：计算颜色并输出。</p><img src="/2021/11/20/%E5%9B%BE%E5%BD%A2%E6%B8%B2%E6%9F%93%E6%B5%81%E6%B0%B4%E7%BA%BF/v2-2be9951a258f1b4cf3ada3cc01ef5d3e_720w.jpg" class title="img"><hr><h2 id="空间变换"><a href="#空间变换" class="headerlink" title="空间变换"></a>空间变换</h2><h3 id="1-模型空间Model-Space-物体空间-本地空间"><a href="#1-模型空间Model-Space-物体空间-本地空间" class="headerlink" title="1. 模型空间Model Space/ 物体空间 / 本地空间"></a>1. 模型空间Model Space/ 物体空间 / 本地空间</h3><p>​    顶点数据一开始就是按照这个空间进行描述的。坐标轴以模型的Pivot枢轴确定</p><h3 id="2-世界空间-World-Space"><a href="#2-世界空间-World-Space" class="headerlink" title="2. 世界空间 World Space"></a>2. 世界空间 World Space</h3><p>​    描述物体之间的相对位置。</p><p>​    从模型空间转变到世界空间需要使用<strong>模型变换矩阵</strong>，称为<strong>模型变换</strong>。</p><p>​    当计算光照时，一般要将顶点转变到这个空间，与灯光一起进行计算。</p><h3 id="3-摄像机空间-Camera-Space-观察空间View-Space"><a href="#3-摄像机空间-Camera-Space-观察空间View-Space" class="headerlink" title="3. 摄像机空间 Camera Space / 观察空间View Space"></a>3. 摄像机空间 Camera Space / 观察空间View Space</h3><p>​    引擎进行渲染的时候就是以摄像机作为视角，也就是这个空间。</p><p>​    从世界空间物体转换到摄像机空间称为<strong>视变换</strong>，需要视变换矩阵。</p><h3 id="4-裁切空间-Clip-Space"><a href="#4-裁切空间-Clip-Space" class="headerlink" title="4. 裁切空间 Clip Space"></a>4. 裁切空间 Clip Space</h3><p>​    顶点转换到摄像机空间后，需要进行视锥体的裁切，就是转换到这个空间进行。</p><p>​    不管是透视投影（Perspective Projection）还是正交投影（Orthographic Projection），视锥体都是六个面组成。</p><p>​    从摄像机空间转换到这个空间的过程叫做<strong>投影变换</strong>，需要使用<strong>裁切矩阵/投影矩阵</strong>。</p><p>​    在裁切空间做了以下事情：</p><p>​        1.<strong>计算顶点坐标的w分量</strong>，用于接下来的透视除法。</p><p>​        2.对视锥体进行不均等缩放，使其变成正方体。</p><img src="/2021/11/20/%E5%9B%BE%E5%BD%A2%E6%B8%B2%E6%9F%93%E6%B5%81%E6%B0%B4%E7%BA%BF/v2-909069f69f8d8a55bd694836dc293376_r.jpg" class><h3 id="5-屏幕空间"><a href="#5-屏幕空间" class="headerlink" title="5. 屏幕空间"></a>5. 屏幕空间</h3><p>此刻顶点坐标还是3D数据，需要在这个空间进行投影将其转化为2D数据。</p><ol><li>首先将顶点的xyz除以w分量，得到标准化的设备坐标（Normalized Device Coordinate，NDC）</li><li>然后将NDC在屏幕像素上进行映射，得到屏幕空间下的像素坐标了。</li></ol><p>z分量依旧需要保留，以便进行深度测试。</p><img src="/2021/11/20/%E5%9B%BE%E5%BD%A2%E6%B8%B2%E6%9F%93%E6%B5%81%E6%B0%B4%E7%BA%BF/v2-95d4db3dc46db03b7c740a611cf623e8_720w.jpg" class title="img"><hr><h2 id="现代GPU渲染流水线"><a href="#现代GPU渲染流水线" class="headerlink" title="现代GPU渲染流水线"></a>现代GPU渲染流水线</h2><img src="/2021/11/20/%E5%9B%BE%E5%BD%A2%E6%B8%B2%E6%9F%93%E6%B5%81%E6%B0%B4%E7%BA%BF/image-20211120214614674.png" class title="image-20211120214614674"><ol><li>第一个站点是顶点着色器。在此，<strong>顶点坐标从模型空间变换到裁切空间</strong>。此外还可以进行其他操作（毕竟Shader里面可操作的就是顶点着色器和片源着色器嘛）</li><li>装配图元阶段把顶点着色器输出的顶点数据装配成指定的几何图元（点线面等等）</li><li><strong>光栅化是将几何图元转化成片段的过程</strong><ol><li>确定屏幕坐标在哪些整形栅格区域被基本图元占用</li><li>分配颜色值和深度值到各个区域</li></ol></li><li>得到的片段，经过视锥体裁切后就被传递到<strong>片段着色器</strong>。在此<strong>计算每一个像素的颜色</strong>（逐像素？）。</li><li>最后进入<strong>测试和混合阶段</strong>。在此<strong>检测像素的深度值</strong>，从而判断像素前面是否被阻挡。（也就是说深度检测居然是最后进行的？）</li><li><strong>帧缓存</strong>是最后一个站点，等待输出到屏幕。</li></ol><h2 id="Thanks"><a href="#Thanks" class="headerlink" title="Thanks:"></a>Thanks:</h2><p>感谢《ShaderLab 新手宝典》及其编者<em>Faith</em>-<em>Tong</em>。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Unity </tag>
            
            <tag> OpenGL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【OpenGL】 光照</title>
      <link href="/2021/11/19/OpenGL-%E7%AC%AC%E4%BA%94%E7%AB%A0-%E5%85%89%E7%85%A7/"/>
      <url>/2021/11/19/OpenGL-%E7%AC%AC%E4%BA%94%E7%AB%A0-%E5%85%89%E7%85%A7/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><h2 id="1-消隐"><a href="#1-消隐" class="headerlink" title="1. 消隐"></a>1. 消隐</h2><p>隐藏表面消除，最简单方法就是使用z-buffer深度缓存区。</p><h2 id="2-OpenGL的光"><a href="#2-OpenGL的光" class="headerlink" title="2. OpenGL的光"></a>2. OpenGL的光</h2><p>分成环境光，散射光，镜面光和发射光。</p><h3 id="环境光-Ambient-Light"><a href="#环境光-Ambient-Light" class="headerlink" title="环境光 Ambient Light"></a>环境光 Ambient Light</h3><p>​    在环境中充分散射，几乎来自于所有方向。</p><h3 id="散射光-Diffuse-Light"><a href="#散射光-Diffuse-Light" class="headerlink" title="散射光 Diffuse Light"></a>散射光 Diffuse Light</h3><h3 id="镜面光-Specular-Light"><a href="#镜面光-Specular-Light" class="headerlink" title="镜面光 Specular Light"></a>镜面光 Specular Light</h3><h3 id="发射光-Emissive-Light"><a href="#发射光-Emissive-Light" class="headerlink" title="发射光 Emissive Light"></a>发射光 Emissive Light</h3><h2 id="3-材料颜色"><a href="#3-材料颜色" class="headerlink" title="3. 材料颜色"></a>3. 材料颜色</h2><p>OpenGL根据材料反射的光来模拟它的颜色。</p><h2 id="简单的例子"><a href="#简单的例子" class="headerlink" title="简单的例子"></a>简单的例子</h2><p>在场景中增加光照，一般有以下步骤：</p><ol><li>定义每个物体顶点的法线向量</li><li>创建和选择一个或多个光源</li><li>创建和选择光照模型</li><li>定义场景中物体的材料属性</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;GL/glut.h&gt;</span><span class="comment">//使用RGBA颜色模型</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">void</span>)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   GLfloat mat_specular[] = &#123; <span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span> &#125;;</span><br><span class="line">   GLfloat mat_shininess[] = &#123; <span class="number">50.0</span> &#125;;</span><br><span class="line">   GLfloat light_position[] = &#123; <span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">0.0</span> &#125;;</span><br><span class="line">       GLfloat lmodel_ambient[] = &#123; <span class="number">0.1</span>,<span class="number">0.1</span>,<span class="number">0.1</span>,<span class="number">1.0</span> &#125;;</span><br><span class="line"></span><br><span class="line">   glClearColor (<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>);</span><br><span class="line">   glShadeModel (GL_SMOOTH);</span><br><span class="line"></span><br><span class="line">   glMaterialfv(GL_FRONT, GL_SPECULAR, mat_specular);</span><br><span class="line">   glMaterialfv(GL_FRONT, GL_SHININESS, mat_shininess);</span><br><span class="line">   glLightfv(GL_LIGHT0, GL_POSITION, light_position);<span class="comment">//指定光源位置</span></span><br><span class="line">    glLightModelfv(GL_LIGHT_MODEL_AMBIENT, lmodel_ambient);</span><br><span class="line"></span><br><span class="line">   glEnable(GL_LIGHTING);</span><br><span class="line">   glEnable(GL_LIGHT0);<span class="comment">//启用光源0</span></span><br><span class="line">   glEnable(GL_DEPTH_TEST);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   glClear (GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);</span><br><span class="line">   glutSolidSphere (<span class="number">1.0</span>, <span class="number">8000</span>, <span class="number">500</span>);<span class="comment">//定义法线向量</span></span><br><span class="line">   glFlush ();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reshape</span> <span class="params">(<span class="keyword">int</span> w, <span class="keyword">int</span> h)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   glViewport (<span class="number">0</span>, <span class="number">0</span>, (GLsizei) w, (GLsizei) h);</span><br><span class="line">   glMatrixMode (GL_PROJECTION);</span><br><span class="line">   glLoadIdentity();</span><br><span class="line">   <span class="keyword">if</span> (w &lt;= h)</span><br><span class="line">      glOrtho (<span class="number">-1.5</span>, <span class="number">1.5</span>, <span class="number">-1.5</span>*(GLfloat)h/(GLfloat)w,</span><br><span class="line">         <span class="number">1.5</span>*(GLfloat)h/(GLfloat)w, <span class="number">-10.0</span>, <span class="number">10.0</span>);</span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">      glOrtho (<span class="number">-1.5</span>*(GLfloat)w/(GLfloat)h,</span><br><span class="line">         <span class="number">1.5</span>*(GLfloat)w/(GLfloat)h, <span class="number">-1.5</span>, <span class="number">1.5</span>, <span class="number">-10.0</span>, <span class="number">10.0</span>);</span><br><span class="line">   glMatrixMode(GL_MODELVIEW);</span><br><span class="line">   glLoadIdentity();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">keyboard</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> key, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">switch</span> (key) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">27</span>:</span><br><span class="line">         <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">         <span class="keyword">break</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   glutInit(&amp;argc, argv);</span><br><span class="line">   glutInitDisplayMode (GLUT_SINGLE | GLUT_RGB | GLUT_DEPTH);</span><br><span class="line">   glutInitWindowSize (<span class="number">500</span>, <span class="number">500</span>); </span><br><span class="line">   glutInitWindowPosition (<span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line">   glutCreateWindow (argv[<span class="number">0</span>]);</span><br><span class="line">   init ();</span><br><span class="line">   glutDisplayFunc(display); </span><br><span class="line">   glutReshapeFunc(reshape);</span><br><span class="line">   glutKeyboardFunc(keyboard);</span><br><span class="line">   glutMainLoop();</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="为顶点定义法线向量"><a href="#为顶点定义法线向量" class="headerlink" title="为顶点定义法线向量"></a>为顶点定义法线向量</h3><p>​    在此例子中，用 glutSolidSphere (1.0, 8000, 500); 来定义球体的法线。（好像不止于此）</p><h3 id="创建、定位和启用光源"><a href="#创建、定位和启用光源" class="headerlink" title="创建、定位和启用光源"></a>创建、定位和启用光源</h3><p>​    glLightfv(GL_LIGHT0, GL_POSITION, light_position);    //指定光源位置</p><h3 id="选择光照模型"><a href="#选择光照模型" class="headerlink" title="选择光照模型"></a>选择光照模型</h3><p>​    用glLightModel（）描述，但是并没有找到欸，似乎加不加都可以。   glLightModelfv(GL_LIGHT_MODEL_AMBIENT, lmodel_ambient);</p><h3 id="为场景中的物体定义材料属性"><a href="#为场景中的物体定义材料属性" class="headerlink" title="为场景中的物体定义材料属性"></a>为场景中的物体定义材料属性</h3><p>​    可以指定材料的环境、散射、镜面颜色和光泽度。本例子中用</p><p>​     glMaterialfv(GL_FRONT, GL_SPECULAR, mat_specular);<br>      glMaterialfv(GL_FRONT, GL_SHININESS, mat_shininess);定义了镜面颜色和光泽度。</p><h1 id="详细解释："><a href="#详细解释：" class="headerlink" title="详细解释："></a>详细解释：</h1><h2 id="创建光源"><a href="#创建光源" class="headerlink" title="创建光源"></a>创建光源</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> glLight&#123;<span class="keyword">if</span>&#125;(GLenum light, GLenum pname, TYPE param);</span><br><span class="line"><span class="keyword">void</span> glLight&#123;<span class="keyword">if</span>&#125;v(GLenum light, GLenum pname, <span class="keyword">const</span> TYPE *param);</span><br></pre></td></tr></table></figure><table><thead><tr><th>Parameter Name</th><th>Default Values</th><th>Meaning</th></tr></thead><tbody><tr><td>GL_AMBIENT</td><td>(0.0, 0.0, 0.0, 1.0)</td><td>光的环境强度</td></tr><tr><td>GL_DIFFUSE</td><td>(1.0, 1.0, 1.0, 1.0) or (0.0, 0.0, 0.0, 1.0)</td><td>光的散射强度</td></tr><tr><td>GL_SPECULAR</td><td>(1.0, 1.0, 1.0, 1.0) or (0.0, 0.0, 0.0, 1.0)</td><td>镜面强度</td></tr><tr><td>GL_POSITION</td><td>(0.0, 0.0, 1.0, 0.0)</td><td>光源位置的坐标</td></tr><tr><td>GL_SPOT_DIRECTION</td><td>(0.0, 0.0, -1.0)</td><td></td></tr><tr><td>GL_SPOT_EXPONENT</td><td>0.0</td><td></td></tr><tr><td>GL_SPOT_CUTOFF</td><td>180.0</td><td></td></tr><tr><td>GL_CONSTANT_ATTENUATION</td><td>1.0</td><td></td></tr><tr><td>GL_LINEAR_ATTENUATION</td><td>0.0</td><td></td></tr><tr><td>GL_QUADRATIC_ATTENUATION</td><td>0.0</td><td></td></tr></tbody></table><p><strong>定义光源的颜色和位置</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GLfloat light_ambient[] = &#123; <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span> &#125;;</span><br><span class="line">GLfloat light_diffuse[] = &#123; <span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span> &#125;;</span><br><span class="line">GLfloat light_specular[] = &#123; <span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span> &#125;;</span><br><span class="line">GLfloat light_position[] = &#123; <span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">0.0</span> &#125;;</span><br><span class="line">glLightfv(GL_LIGHT0, GL_AMBIENT, light_ambient);</span><br><span class="line">glLightfv(GL_LIGHT0, GL_DIFFUSE, light_diffuse);</span><br><span class="line">glLightfv(GL_LIGHT0, GL_SPECULAR, light_specular);</span><br><span class="line">glLightfv(GL_LIGHT0, GL_POSITION, light_position);</span><br></pre></td></tr></table></figure><h3 id="1-颜色"><a href="#1-颜色" class="headerlink" title="1.  颜色"></a>1.  颜色</h3><p>​    OpenGL的颜色与<strong>GL_AMBIENT、GL_DIFFUSE、GL_SPECULAR</strong>有关。</p><p>​    <strong>默认的环境光是白色</strong>，但是我们可以把它改成red！<img src="/2021/11/19/OpenGL-%E7%AC%AC%E4%BA%94%E7%AB%A0-%E5%85%89%E7%85%A7/image-20211121145345676.png" alt="image-20211121145345676" style="zoom: 67%;"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">GLfloat myRed[] = &#123; <span class="number">1.0</span>,<span class="number">0.0</span>,<span class="number">0.0</span>,<span class="number">1.0</span> &#125;;</span><br><span class="line">glLightfv(GL_LIGHT0, GL_AMBIENT, myRed);</span><br><span class="line"></span><br><span class="line">glLightfv(GL_LIGHT0, GL_DIFFUSE, myRed);</span><br><span class="line">glLightfv(GL_LIGHT0, GL_SPECULAR, myRed);</span><br></pre></td></tr></table></figure><p>​    GL_DIFFUSE则最接近我们理解的颜色，它默认白色，我们也可以改！<img src="/2021/11/19/OpenGL-%E7%AC%AC%E4%BA%94%E7%AB%A0-%E5%85%89%E7%85%A7/image-20211121145453185.png" alt="image-20211121145453185" style="zoom: 67%;"></p><p>GL_SPECULAR则影响物体上镜面亮点的颜色，一般想创建逼真效果，其与GL_DIFFUSE相同即可。<img src="/2021/11/19/OpenGL-%E7%AC%AC%E4%BA%94%E7%AB%A0-%E5%85%89%E7%85%A7/image-20211121145650263.png" alt="image-20211121145650263" style="zoom:67%;"></p><h3 id="2-位置与衰减"><a href="#2-位置与衰减" class="headerlink" title="2. 位置与衰减"></a>2. 位置与衰减</h3><p>​    <strong>方向性光源</strong>：当光源位置无限远，默认光线平行，例如太阳。</p><p>​    <strong>位置性光源</strong>：它的位置决定了光线的效果，例如台灯。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GLfloat light_position[] = &#123; <span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">0.0</span> &#125;;</span><br><span class="line">glLightfv(GL_LIGHT0, GL_POSITION, light_position);</span><br></pre></td></tr></table></figure><p>​    如果给定的向量第四个<strong>值为0，则表示其为方向性光源，即平行光</strong>。<strong>若非0，则默认是位置性光源，即太阳</strong>（也可以限制为聚光灯）。</p><p>​    当然，对于位置性光源，还可以进行一个<strong>光强度随位置增加的衰减：对其乘以衰减因子</strong>。</p><img src="/2021/11/19/OpenGL-%E7%AC%AC%E4%BA%94%E7%AB%A0-%E5%85%89%E7%85%A7/image-20211121150610126.png" class title="image-20211121150610126"><h3 id="3-聚光灯"><a href="#3-聚光灯" class="headerlink" title="3.聚光灯"></a>3.聚光灯</h3><p>若将位置性光源限制为聚光灯，需要GL_SPOT_CUTOFF参数，光锥的最大角度是这个值的俩倍。<img src="/2021/11/19/OpenGL-%E7%AC%AC%E4%BA%94%E7%AB%A0-%E5%85%89%E7%85%A7/image-20211121150804323.png" alt="image-20211121150804323" style="zoom:50%;"></p><p>可以用如下代码限制光锥切角： 还需要指定聚光灯方向和光锥的轴：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">glLightf(GL_LIGHT0, GL_SPOT_CUTOFF, <span class="number">45.0</span>);</span><br><span class="line"></span><br><span class="line">GLfloat spot_direction[] = &#123; <span class="number">-1.0</span>, <span class="number">-1.0</span>, <span class="number">0.0</span> &#125;;</span><br><span class="line">glLightfv(GL_LIGHT0, GL_SPOT_DIRECTION, spot_direction);</span><br></pre></td></tr></table></figure><h3 id="4-多光源"><a href="#4-多光源" class="headerlink" title="4.多光源"></a>4.多光源</h3><p>最多可以中场景指定8个光源（一般）。之前只有一个光源，默认表示它的常量就是GL_LIGHT0，当然后面都顺延，加上去就可以用了。</p><h3 id="5-控制光源的位置和方向"><a href="#5-控制光源的位置和方向" class="headerlink" title="5.控制光源的位置和方向"></a>5.控制光源的位置和方向</h3><h4 id="1-光源保持静止"><a href="#1-光源保持静止" class="headerlink" title="1.光源保持静止"></a>1.光源保持静止</h4><p>​        为实现这个效果，需要在使用视图和模型变换之后，设置光源的位置。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">glViewport(<span class="number">0</span>, <span class="number">0</span>, (GLsizei) w, (GLsizei) h);</span><br><span class="line">glMatrixMode(GL_PROJECTION);</span><br><span class="line">glLoadIdentity();</span><br><span class="line"><span class="keyword">if</span> (w &lt;= h) </span><br><span class="line"> glOrtho(<span class="number">-1.5</span>, <span class="number">1.5</span>, <span class="number">-1.5</span>*h/w, <span class="number">1.5</span>*h/w, <span class="number">-10.0</span>, <span class="number">10.0</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"> glOrtho(<span class="number">-1.5</span>*w/h, <span class="number">1.5</span>*w/h, <span class="number">-1.5</span>, <span class="number">1.5</span>, <span class="number">-10.0</span>, <span class="number">10.0</span>);</span><br><span class="line"></span><br><span class="line">glMatrixMode(GL_MODELVIEW);</span><br><span class="line">glLoadIdentity();</span><br><span class="line"><span class="comment">/* later in init() */</span></span><br><span class="line">GLfloat light_position[] = &#123; <span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span> &#125;;</span><br><span class="line">glLightfv(GL_LIGHT0, GL_POSITION, position);</span><br></pre></td></tr></table></figure><h4 id="2-独立移动光源"><a href="#2-独立移动光源" class="headerlink" title="2.独立移动光源"></a>2.独立移动光源</h4><p>这里是一个例子，用到spin这个全局变量，由输入设备控制。关键点在display函数中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;GL/glut.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> spin = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">void</span>)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   glClearColor (<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>);</span><br><span class="line">   glShadeModel (GL_SMOOTH);</span><br><span class="line">   glEnable(GL_LIGHTING);</span><br><span class="line">   glEnable(GL_LIGHT0);</span><br><span class="line">   glEnable(GL_DEPTH_TEST);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   GLfloat position[] = &#123; <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">1.5</span>, <span class="number">1.0</span> &#125;;</span><br><span class="line"></span><br><span class="line">   glClear (GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);</span><br><span class="line">   glPushMatrix ();</span><br><span class="line">   gluLookAt (<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">5.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">0.0</span>);</span><br><span class="line"></span><br><span class="line">   glPushMatrix ();</span><br><span class="line">       glRotated ((GLdouble) spin, <span class="number">1.0</span>, (GLdouble)spin, <span class="number">0.0</span>);</span><br><span class="line">       glLightfv (GL_LIGHT0, GL_POSITION, position);</span><br><span class="line"></span><br><span class="line">       glTranslated (<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">1.5</span>);</span><br><span class="line">       glDisable (GL_LIGHTING);</span><br><span class="line">       glColor3f (<span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>);</span><br><span class="line">       glutWireCube (<span class="number">0.1</span>);<span class="comment">//lifangti</span></span><br><span class="line">       glEnable (GL_LIGHTING);</span><br><span class="line">       glPopMatrix ();</span><br><span class="line"></span><br><span class="line">       glutSolidTorus (<span class="number">0.275</span>, <span class="number">0.85</span>, <span class="number">20</span>, <span class="number">50</span>);<span class="comment">//L轮胎？？？？？？？？</span></span><br><span class="line">   glPopMatrix ();</span><br><span class="line">   glFlush ();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reshape</span> <span class="params">(<span class="keyword">int</span> w, <span class="keyword">int</span> h)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   glViewport (<span class="number">0</span>, <span class="number">0</span>, (GLsizei) w, (GLsizei) h);</span><br><span class="line">   glMatrixMode (GL_PROJECTION);</span><br><span class="line">   glLoadIdentity();</span><br><span class="line">   gluPerspective(<span class="number">40.0</span>, (GLfloat) w/(GLfloat) h, <span class="number">1.0</span>, <span class="number">20.0</span>);</span><br><span class="line">   glMatrixMode(GL_MODELVIEW);</span><br><span class="line">   glLoadIdentity();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mouse</span><span class="params">(<span class="keyword">int</span> button, <span class="keyword">int</span> state, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">switch</span> (button) &#123;</span><br><span class="line">      <span class="keyword">case</span> GLUT_LEFT_BUTTON:</span><br><span class="line">         <span class="keyword">if</span> (state == GLUT_DOWN) &#123;</span><br><span class="line">            spin = (spin + <span class="number">30</span>) % <span class="number">360</span>;</span><br><span class="line">            glutPostRedisplay();</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">         <span class="keyword">break</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">keyboard</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> key, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">switch</span> (key) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">27</span>:</span><br><span class="line">         <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">         <span class="keyword">break</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   glutInit(&amp;argc, argv);</span><br><span class="line">   glutInitDisplayMode (GLUT_SINGLE | GLUT_RGB | GLUT_DEPTH);</span><br><span class="line">   glutInitWindowSize (<span class="number">500</span>, <span class="number">500</span>); </span><br><span class="line">   glutInitWindowPosition (<span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line">   glutCreateWindow (argv[<span class="number">0</span>]);</span><br><span class="line">   init ();</span><br><span class="line">   glutDisplayFunc(display); </span><br><span class="line">   glutReshapeFunc(reshape);</span><br><span class="line">   glutMouseFunc(mouse);</span><br><span class="line">   glutKeyboardFunc(keyboard);</span><br><span class="line">   glutMainLoop();</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-随观察者移动（miner’s-hat）"><a href="#3-随观察者移动（miner’s-hat）" class="headerlink" title="3.随观察者移动（miner’s hat）"></a>3.随观察者移动（miner’s hat）</h4><h2 id="选择光照模型-1"><a href="#选择光照模型-1" class="headerlink" title="选择光照模型"></a>选择光照模型</h2><p>OpenGL的光照模型分为以下概念：</p><ol><li>全局环境光强度</li><li>观察点的位置位于场景还是无限远</li><li>物体的正面背面是否执行不同的光照计算</li><li>镜面颜色是否应该从环境和散射模型中分离，再纹理之后再应用。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> glLightModel&#123;<span class="keyword">if</span>&#125;(GLenum pname, TYPE param);</span><br><span class="line"><span class="keyword">void</span> glLightModel&#123;<span class="keyword">if</span>&#125;v(GLenum pname, <span class="keyword">const</span> TYPE *param);</span><br></pre></td></tr></table></figure><table><thead><tr><th>Parameter Name</th><th>Default Value</th><th>Meaning</th></tr></thead><tbody><tr><td>GL_LIGHT_MODEL_AMBIENT</td><td>(0.2, 0.2, 0.2, 1.0)</td><td>整个场景环境光的RGBA强度</td></tr><tr><td>GL_LIGHT_MODEL_LOCAL_VIEWER</td><td>0.0 or GL_FALSE</td><td>镜面反射角度的计算</td></tr><tr><td>GL_LIGHT_MODEL_TWO_SIDE</td><td>0.0 or GL_FALSE</td><td>指定单面还是双面光照</td></tr><tr><td>GL_LIGHT_MODEL_COLOR_CONTROL</td><td>GL_SINGLE_COLOR</td><td>镜面颜色的计算是否分离</td></tr></tbody></table><h3 id="1-全局环境光"><a href="#1-全局环境光" class="headerlink" title="1. 全局环境光"></a>1. 全局环境光</h3><p>默认值是少量白光的环境光，以便于看清物体。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GLfloat lmodel_ambient[] = &#123; <span class="number">0.2</span>, <span class="number">0.2</span>, <span class="number">0.2</span>, <span class="number">1.0</span> &#125;;</span><br><span class="line">glLightModelfv(GL_LIGHT_MODEL_AMBIENT, lmodel_ambient);</span><br></pre></td></tr></table></figure><h3 id="2-观察点的位置位于场景还是无限远"><a href="#2-观察点的位置位于场景还是无限远" class="headerlink" title="2.观察点的位置位于场景还是无限远"></a>2.观察点的位置位于场景还是无限远</h3><p>观测点的位置影响镜面反射产生的亮点。观测点位于无穷远，则场景这所有顶点的方向固定。局部观测点可以更逼真但是开销大。</p><p>可以用下列代码开启，true为局部，false为无穷远。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">glLightModeli(GL_LIGHT_MODEL_LOCAL_VIEWER, GL_TRUE);</span><br></pre></td></tr></table></figure><h3 id="3-双面光照"><a href="#3-双面光照" class="headerlink" title="3.双面光照"></a>3.双面光照</h3><p>默认单面，双面指的是加上了背面，例如圆的内部。开启会反转表面法线的方向，加剧开销。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">glLightModeli(GL_LIGHT_MODEL_TWO_SIDE, GL_TRUE);</span><br></pre></td></tr></table></figure><h3 id="4-镜面辅助颜色"><a href="#4-镜面辅助颜色" class="headerlink" title="4.镜面辅助颜色"></a>4.镜面辅助颜色</h3><p>把镜面计算推迟到纹理贴图之后：</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">glLightModeli<span class="comment">(GL_LIGHT_MODEL_COLOR_CONTROL, GL_SEPARATE_SPECULAR_COLOR)</span>;</span><br></pre></td></tr></table></figure><p>恢复默认为：</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">glLightModeli<span class="comment">(GL_LIGHT_MODEL_COLOR_CONTROL, GL_SINGLE_COLOR)</span>;</span><br></pre></td></tr></table></figure><h3 id="5-启用光照"><a href="#5-启用光照" class="headerlink" title="5.启用光照"></a>5.启用光照</h3><p>当然可以自行开关光照，以及具体光源的开关：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">glEnable(GL_LIGHTING);</span><br><span class="line">glEnable(GL_LIGHT0);</span><br></pre></td></tr></table></figure><h2 id="定义材料属性"><a href="#定义材料属性" class="headerlink" title="定义材料属性"></a>定义材料属性</h2><p>如何设置场景中物体的材料属性：环境，散射和镜面颜色，光泽度，所发射光的颜色：用这个函数就可以拉：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> glMaterial&#123;<span class="keyword">if</span>&#125;(GLenum face, GLenum pname, TYPE param);</span><br><span class="line"><span class="keyword">void</span> glMaterial&#123;<span class="keyword">if</span>&#125;v(GLenum face, GLenum pname, <span class="keyword">const</span> TYPE *param);</span><br></pre></td></tr></table></figure><table><thead><tr><th>Parameter Name Default Value Meaning</th><th></th><th></th></tr></thead><tbody><tr><td>GL_AMBIENT</td><td>(0.2, 0.2, 0.2, 1.0)</td><td>ambient color of material 环境颜色</td></tr><tr><td>GL_DIFFUSE</td><td>(0.8, 0.8, 0.8, 1.0)</td><td>diffuse color of material 散射颜色</td></tr><tr><td>GL_AMBIENT_AND_DIFFUSE</td><td></td><td>ambient and diffuse color of material</td></tr><tr><td>GL_SPECULAR</td><td>(0.0, 0.0, 0.0, 1.0)</td><td>specular color of material 镜面颜色</td></tr><tr><td>GL_SHININESS</td><td>0.0</td><td>specular exponent 镜面指数</td></tr><tr><td>GL_EMISSION</td><td>(0.0, 0.0, 0.0, 1.0)</td><td>emissive color of material</td></tr><tr><td>GL_COLOR_INDEXES</td><td>(0, 1, 1)</td><td>ambient, diffuse, and  specular color indices 索引</td></tr></tbody></table><h3 id="1-散射和环境反射"><a href="#1-散射和环境反射" class="headerlink" title="1.散射和环境反射"></a>1.散射和环境反射</h3><p>一般物体的散射和环境反射相同，故可以起定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GLfloat mat_amb_diff[] = &#123; <span class="number">0.1</span>, <span class="number">0.5</span>, <span class="number">0.8</span>, <span class="number">1.0</span> &#125;;</span><br><span class="line">glMaterialfv(GL_FRONT_AND_BACK, GL_AMBIENT_AND_DIFFUSE, mat_amb_diff);</span><br></pre></td></tr></table></figure><h3 id="2-镜面反射"><a href="#2-镜面反射" class="headerlink" title="2.镜面反射"></a>2.镜面反射</h3><p>可以用GL_SPECULAR设定材料的效果，用GL_SHININESS控制亮点的大小和亮度。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GLfloat mat_specular[] = &#123; <span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span> &#125;;</span><br><span class="line">GLfloat low_shininess[] = &#123; <span class="number">5.0</span> &#125;;</span><br><span class="line">glMaterialfv(GL_FRONT, GL_SPECULAR, mat_specular);</span><br><span class="line">glMaterialfv(GL_FRONT, GL_SHININESS, low_shininess);</span><br></pre></td></tr></table></figure><h3 id="3-发射光颜色"><a href="#3-发射光颜色" class="headerlink" title="3.发射光颜色"></a>3.发射光颜色</h3><p>一般用在自发光物体</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GLfloat mat_emission[] = &#123;<span class="number">0.3</span>, <span class="number">0.2</span>, <span class="number">0.2</span>, <span class="number">0.0</span>&#125;;</span><br><span class="line">glMaterialfv(GL_FRONT, GL_EMISSION, mat_emission);</span><br></pre></td></tr></table></figure><h1 id="后言"><a href="#后言" class="headerlink" title="后言"></a>后言</h1><p>边看边想边copy，又看掉了一节，继续加油……</p><p>[TOC]</p>]]></content>
      
      
      
        <tags>
            
            <tag> OpenGL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【OpenGL】 视图</title>
      <link href="/2021/11/19/OpenGL-%E9%9A%8F%E7%AC%94%E8%AE%B02/"/>
      <url>/2021/11/19/OpenGL-%E9%9A%8F%E7%AC%94%E8%AE%B02/</url>
      
        <content type="html"><![CDATA[<p>​    终于终于第三章了呢，一共有十五章呢……</p><span id="more"></span><h2 id="3-1-2通用的变换函数"><a href="#3-1-2通用的变换函数" class="headerlink" title="3.1.2通用的变换函数"></a>3.1.2通用的变换函数</h2><h3 id="void-glMatrixMode-GL-MODELVIEW-GL-PROJECTION-GL-TEXTURE"><a href="#void-glMatrixMode-GL-MODELVIEW-GL-PROJECTION-GL-TEXTURE" class="headerlink" title="void glMatrixMode(GL_MODELVIEW / GL_PROJECTION /  GL_TEXTURE);"></a><strong>void glMatrixMode(GL_MODELVIEW / GL_PROJECTION /  GL_TEXTURE);</strong></h3><p>在调用变换矩阵之前，需要确定自己想修改的是<strong>模型视图矩阵</strong>还是<strong>投影矩阵</strong>，此时需要用glMatrixMode()进行选择。</p><h3 id="void-glLoadIdentity"><a href="#void-glLoadIdentity" class="headerlink" title="void glLoadIdentity()"></a>void glLoadIdentity()</h3><p>把当前矩阵清除为单位矩阵，供未来的变换函数使用。总是在投影或者视图变换之前调用。</p><h3 id="void-glLoadMatrix-fd-const-TYPE-m"><a href="#void-glLoadMatrix-fd-const-TYPE-m" class="headerlink" title="void glLoadMatrix{fd}(const TYPE *m);"></a>void glLoadMatrix{fd}(const TYPE *m);</h3><p>将当前矩阵的 16 个值设置为 m 指定的值。</p><h3 id="void-glMultMatrix-fd-const-TYPE-m"><a href="#void-glMultMatrix-fd-const-TYPE-m" class="headerlink" title="void glMultMatrix{fd}(const TYPE *m);"></a>void glMultMatrix{fd}(const TYPE *m);</h3><p>将 m 指向的 16 个值指定的矩阵与当前矩阵相乘，并将结果存储为当前矩阵。</p><h2 id="变换"><a href="#变换" class="headerlink" title="变换"></a>变换</h2><h3 id="void-glTranslate-fd-TYPE-x-TYPE-y-TYPE-z"><a href="#void-glTranslate-fd-TYPE-x-TYPE-y-TYPE-z" class="headerlink" title="void glTranslate{fd}(TYPE x, TYPE y, TYPE z);"></a>void glTranslate{fd}(TYPE x, TYPE y, TYPE z);</h3><p>将当前矩阵乘以一个矩阵，该矩阵通过给定的 x、y 和 z 值移动（平移）对象（或以相同的量移动本地坐标系）</p><h3 id="void-glRotate-fd-TYPE-angle-TYPE-x-TYPE-y-TYPE-z"><a href="#void-glRotate-fd-TYPE-angle-TYPE-x-TYPE-y-TYPE-z" class="headerlink" title="void glRotate{fd}(TYPE angle, TYPE x, TYPE y, TYPE z);"></a>void glRotate{fd}(TYPE angle, TYPE x, TYPE y, TYPE z);</h3><p>将当前矩阵乘以一个矩阵，该矩阵在逆时针方向上围绕从原点到点 (x, y, z) 的射线旋转对象（或局部坐标系）。 角度参数以度为单位指定旋转角度。</p><h3 id="void-glScale-fd-TYPE-x-TYPE-y-TYPE-z"><a href="#void-glScale-fd-TYPE-x-TYPE-y-TYPE-z" class="headerlink" title="void glScale{fd}(TYPE x, TYPE y, TYPE z);"></a>void glScale{fd}(TYPE x, TYPE y, TYPE z);</h3><p>将当前矩阵乘以沿轴拉伸、收缩或反射对象的矩阵。 对象中每个点的每个 x、y 和 z 坐标都乘以相应的参数 x、y 或 z。 使用局部坐标系方法时，局部坐标轴被 x、y 和 z 因子拉伸、收缩或反射，并且关联的对象也随之变换。</p><h2 id="3-3投影变换"><a href="#3-3投影变换" class="headerlink" title="3.3投影变换"></a>3.3投影变换</h2><p><strong>glMatrixMode(GL_PROJECTION);</strong></p><p><strong>glLoadIdentity();</strong>    别忘了这俩个~</p><p>投影变换的目的是定义一个视域，它有两种使用方式。 视域决定了对象如何投影到屏幕上（即，通过使用透视或正交投影），并定义从最终图像中剪裁出哪些对象或对象的一部分。 可以将我们一直在谈论的视点视为存在于视域的一端。（视域，或者叫视景体）</p><h3 id="透视投影"><a href="#透视投影" class="headerlink" title="透视投影"></a>透视投影</h3><p>视景体是一个平截头型（梯形）。</p><h3 id="正投影"><a href="#正投影" class="headerlink" title="正投影"></a>正投影</h3><p>视景体是一个长方体。</p><h2 id="3-6操作矩阵堆栈"><a href="#3-6操作矩阵堆栈" class="headerlink" title="3.6操作矩阵堆栈"></a>3.6操作矩阵堆栈</h2><p>当我们对模型视图矩阵或者投影矩阵进行矩阵操作时，每一个矩阵实际上是各自矩阵堆栈最顶部的那个元素。</p><p>也就是说，之前的glLoadMatrix(),glLoadIndentity(),glMultTransposeMatrix()都是对堆栈顶部的那个矩阵进行的操作。可以用执行堆栈操作的函数<strong>glPushMatrix</strong>()和<strong>glPopMatrix</strong>()来控制顶部的矩阵。</p><p><strong>glPushMatrix()</strong>:复制当前矩阵，并将复制的那份加入堆栈的顶部。</p><p><strong>glPopMatrix()</strong>:把栈顶的丢掉。</p><p>当前的矩阵就是位于堆栈顶部的矩阵。</p><p>[TOC]</p>]]></content>
      
      
      
        <tags>
            
            <tag> OpenGL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Unity_shader】表面着色器</title>
      <link href="/2021/11/18/Unity-shader3/"/>
      <url>/2021/11/18/Unity-shader3/</url>
      
        <content type="html"><![CDATA[<p>概括讲述了在Unity Shader的特别存在，也就是高度抽象的表面着色器。</p><span id="more"></span><h1 id="表面着色器Surface-Shader"><a href="#表面着色器Surface-Shader" class="headerlink" title="表面着色器Surface Shader"></a>表面着色器Surface Shader</h1><p>​    实际上就是对顶点-片段着色器的一种抽象，并包含了很多光照模型。使其更加简便。</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">Shader &quot;Custom/NewSurfaceShader&quot;<span class="comment">//unity默认的表面着色器</span></span><br><span class="line">&#123;</span><br><span class="line">    Properties</span><br><span class="line">    &#123;</span><br><span class="line">        _Color (&quot;Color&quot;, Color) = (<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">        _MainTex (&quot;Albedo (RGB)&quot;, <span class="number">2</span>D) = &quot;white&quot; &#123;&#125;</span><br><span class="line">        _Glossiness (&quot;Smoothness&quot;, Range(<span class="number">0</span>,<span class="number">1</span>)) = <span class="number">0.5</span></span><br><span class="line">        _Metallic (&quot;Metallic&quot;, Range(<span class="number">0</span>,<span class="number">1</span>)) = <span class="number">0.0</span></span><br><span class="line">    &#125;</span><br><span class="line">    SubShader</span><br><span class="line">    &#123;</span><br><span class="line">        Tags &#123; &quot;RenderType&quot;=&quot;Opaque&quot; &#125;</span><br><span class="line">        LOD <span class="number">200</span></span><br><span class="line"></span><br><span class="line">        CGPROGRAM</span><br><span class="line">        <span class="comment">// Physically based Standard lighting model, and enable shadows on all light types</span></span><br><span class="line">        <span class="meta">#pragma surface surf Standard fullforwardshadows</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Use shader model 3.0 target, to get nicer looking lighting</span></span><br><span class="line">        <span class="meta">#pragma target 3.0</span></span><br><span class="line"></span><br><span class="line">        <span class="type">sampler2D</span> _MainTex;</span><br><span class="line"></span><br><span class="line">        struct Input</span><br><span class="line">        &#123;</span><br><span class="line">            float2 uv_MainTex;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        half _Glossiness;</span><br><span class="line">        half _Metallic;</span><br><span class="line">        fixed4 _Color;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Add instancing support for this shader. You need to check &#x27;Enable Instancing&#x27; on materials that use the shader.</span></span><br><span class="line">        <span class="comment">// See https://docs.unity3d.com/Manual/GPUInstancing.html for more information about instancing.</span></span><br><span class="line">        <span class="comment">// #pragma instancing_options assumeuniformscaling</span></span><br><span class="line">        UNITY_INSTANCING_BUFFER_START(Props)</span><br><span class="line">            <span class="comment">// put more per-instance properties here</span></span><br><span class="line">        UNITY_INSTANCING_BUFFER_END(Props)</span><br><span class="line"></span><br><span class="line">        <span class="type">void</span> surf (Input IN, <span class="keyword">inout</span> SurfaceOutputStandard o)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// Albedo comes from a texture tinted by color</span></span><br><span class="line">            fixed4 c = tex2D (_MainTex, IN.uv_MainTex) * _Color;</span><br><span class="line">            o.Albedo = c.rgb;</span><br><span class="line">            <span class="comment">// Metallic and smoothness come from slider variables</span></span><br><span class="line">            o.Metallic = _Metallic;</span><br><span class="line">            o.Smoothness = _Glossiness;</span><br><span class="line">            o.Alpha = c.a;</span><br><span class="line">        &#125;</span><br><span class="line">        ENDCG</span><br><span class="line">    &#125;</span><br><span class="line">    FallBack &quot;Diffuse&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="表面着色器编译指令"><a href="#表面着色器编译指令" class="headerlink" title="表面着色器编译指令"></a>表面着色器编译指令</h2><p>​    # pragma surface surfaceFunction lightModel [optionalparams]</p><p>​    lightModel - 要使用的光照模型。内置光照模型是基于物理的 Standard 和 StandardSpecular，以及简单的非基于物理的 Lambert（漫射）和 BlinnPhong（镜面反射）。</p><h2 id="表面函数surf"><a href="#表面函数surf" class="headerlink" title="表面函数surf()"></a>表面函数surf()</h2><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> surf (Input IN, <span class="keyword">inout</span> SurfaceOutputStandard o)</span><br><span class="line">        &#123;</span><br><span class="line">        ......</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>​    inout表示即是输入函数又是输出函数。</p><p>​    Input是输入的结构体，而后面的SurfaceOutputStandard是输出结构体。</p><h2 id="表面函数输出结构体"><a href="#表面函数输出结构体" class="headerlink" title="表面函数输出结构体"></a>表面函数输出结构体</h2><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">struct SurfaceOutput &#123;    </span><br><span class="line">    half3 Albedo;      <span class="comment">// 该像素的反射率，反应了像素的基色   </span></span><br><span class="line">    half3 Normal;     <span class="comment">// 该像素的法线方向  </span></span><br><span class="line">    half3 Emission;   <span class="comment">// 该像素的自发光颜色，使得即便没有光照也可以物体本身也可以发出光  </span></span><br><span class="line">    half Specular;     <span class="comment">// 该像素的高光指数    </span></span><br><span class="line">    half Gloss;         <span class="comment">// 该像素的高光光滑度，值越大高光反射越清晰，反之越模糊    </span></span><br><span class="line">    half Alpha;         <span class="comment">// 该像素的不透明度   </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>​    在unity5以后，加入了基于物理属性的光照模型，有俩个：</p><p>​        Standard，适合金属工作流</p><p>​        StandardSpecular，适合高光工作流</p><p>​    其均在UnityPBSLighting.cginc中被包含</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">struct SurfaceOutputStandard</span><br><span class="line">｛</span><br><span class="line">    fixed3 Albedo;      <span class="comment">// base (diffuse or specular) color</span></span><br><span class="line">    fixed3 Normal;      <span class="comment">// tangent space normal, if written</span></span><br><span class="line">    half3 Emission;</span><br><span class="line">    half Metallic;      <span class="comment">// 0=non-metal, 1=metal</span></span><br><span class="line">    half Smoothness;    <span class="comment">// 0=rough, 1=smooth</span></span><br><span class="line">    half Occlusion;     <span class="comment">// occlusion (default 1)</span></span><br><span class="line">    fixed Alpha;        <span class="comment">// alpha for transparencies</span></span><br><span class="line">｝;</span><br><span class="line">struct SurfaceOutputStandardSpecular</span><br><span class="line">｛</span><br><span class="line">    fixed3 Albedo;      <span class="comment">// diffuse color</span></span><br><span class="line">    fixed3 Specular;    <span class="comment">// specular color</span></span><br><span class="line">    fixed3 Normal;      <span class="comment">// tangent space normal, if written</span></span><br><span class="line">    half3 Emission;</span><br><span class="line">    half Smoothness;    <span class="comment">// 0=rough, 1=smooth</span></span><br><span class="line">    half Occlusion;     <span class="comment">// occlusion (default 1)</span></span><br><span class="line">    fixed Alpha;        <span class="comment">// alpha for transparencies</span></span><br><span class="line">｝;</span><br></pre></td></tr></table></figure><h2 id="法线贴图"><a href="#法线贴图" class="headerlink" title="法线贴图"></a>法线贴图</h2><p>​    法线贴图可以逐像素修改物体表面法线的方向，使得产生凹凸不平的假象。以此可以实现低模的基础上实现高模的细节了。</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Properties</span><br><span class="line">  &#123;</span><br><span class="line">     ......</span><br><span class="line">      _Normal (&quot;Normal Map&quot;, <span class="number">2</span>D) = &quot;bump&quot; &#123;&#125;</span><br><span class="line">      _Bumpiness (&quot;Bumpiness&quot;, Range(<span class="number">0</span>, <span class="number">1</span>)) = <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">struct Input</span><br><span class="line">  &#123;</span><br><span class="line">      float2 uv_MainTex;</span><br><span class="line">      float2 uv_Normal;</span><br><span class="line">  &#125;;</span><br><span class="line"><span class="type">void</span> surf (Input IN, <span class="keyword">inout</span> SurfaceOutputStandard o)</span><br><span class="line">  &#123;</span><br><span class="line">  ......</span><br><span class="line">       <span class="comment">// 采样法线贴图并解包</span></span><br><span class="line">      fixed3 n = UnpackNormal(tex2D(_Normal, IN.uv_Normal));</span><br><span class="line">      n *= float3(_Bumpiness, _Bumpiness, <span class="number">1</span>);</span><br><span class="line">      o.Normal = n;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><img src="/2021/11/18/Unity-shader3/v2-3828a0cafa4d2f5f6372d1d3e9d17a12_r.jpg" class title="img"><h2 id="表面着色器其他函数"><a href="#表面着色器其他函数" class="headerlink" title="表面着色器其他函数"></a>表面着色器其他函数</h2><img src="/2021/11/18/Unity-shader3/v2-2d5e6d1de528ac425502547beb41b24a_r.jpg" class title="表面着色器的计算流程"><p>​    虽说表面着色器是对于顶点着色器的高度封装，但是还是有很多可以定义的函数的。</p><h3 id="比如，可以通过对顶点修改函数的修改，实现顶点修改的效果，例如模型朝法线方向膨胀。"><a href="#比如，可以通过对顶点修改函数的修改，实现顶点修改的效果，例如模型朝法线方向膨胀。" class="headerlink" title="比如，可以通过对顶点修改函数的修改，实现顶点修改的效果，例如模型朝法线方向膨胀。"></a>比如，可以通过对顶点修改函数的修改，实现顶点修改的效果，例如模型朝法线方向膨胀。</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">Shader &quot;Unlit/9_Expansion&quot;</span><br><span class="line">&#123;</span><br><span class="line">    Properties</span><br><span class="line">    &#123;</span><br><span class="line">        _MainTex (&quot;MainTex&quot;, 2D) = &quot;white&quot; &#123;&#125;</span><br><span class="line">        _Expansion (&quot;Expansion&quot;, Range(0, 0.1)) = 0</span><br><span class="line">    &#125;</span><br><span class="line">    SubShader</span><br><span class="line">    &#123;</span><br><span class="line">        CGPROGRAM</span><br><span class="line"></span><br><span class="line">        // 添加自定义顶点修函数vert</span><br><span class="line">        #pragma surface surf Lambert vertex:vert</span><br><span class="line"></span><br><span class="line">        struct Input</span><br><span class="line">        &#123;</span><br><span class="line">            float2 uv_MainTex;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        sampler2D _MainTex;</span><br><span class="line">        fixed _Expansion;</span><br><span class="line"></span><br><span class="line">        // 顶点修改函数，输入/输出appdata_full结构体</span><br><span class="line">        void vert (inout appdata_full v)</span><br><span class="line">        &#123;</span><br><span class="line">            v.vertex.xyz += v.normal * _Expansion;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        void surf (Input IN, inout SurfaceOutput o)</span><br><span class="line">        &#123;</span><br><span class="line">            o.Albedo = tex2D(_MainTex, IN.uv_MainTex).rgb;</span><br><span class="line">        &#125;</span><br><span class="line">        ENDCG</span><br><span class="line">    &#125;</span><br><span class="line">    FallBack &quot;Diffuse&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="自定义光照函数"><a href="#自定义光照函数" class="headerlink" title="自定义光照函数"></a>自定义光照函数</h3><p>​    如果不乐意使用内置的俩种光照模型（实现漫反射的Lambert和实现镜面反射的BlinnPhong），就可以自定义光照模型。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">Shader &quot;Custom/10_SelfLightingModel&quot;</span><br><span class="line">&#123;</span><br><span class="line">    Properties</span><br><span class="line">    &#123;</span><br><span class="line">        _MainTex (&quot;MainTex&quot;, 2D) = &quot;white&quot; &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    SubShader</span><br><span class="line">    &#123;</span><br><span class="line">        CGPROGRAM</span><br><span class="line"></span><br><span class="line">        // 声明自定义光照模型为CustomLambert</span><br><span class="line">        #pragma surface surf CustomLambert</span><br><span class="line"></span><br><span class="line">        struct Input</span><br><span class="line">        &#123;</span><br><span class="line">            float2 uv_MainTex;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        sampler2D _MainTex;</span><br><span class="line"></span><br><span class="line">        void surf (Input IN, inout SurfaceOutput o)</span><br><span class="line">        &#123;</span><br><span class="line">            o.Albedo = tex2D(_MainTex, IN.uv_MainTex).rgb;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 自定义光照函数</span><br><span class="line">        half4 LightingCustomLambert (SurfaceOutput s, half3 lightDir, half atten)</span><br><span class="line">        &#123;</span><br><span class="line">            fixed NdotL = saturate(dot(s.Normal, lightDir));</span><br><span class="line"></span><br><span class="line">            half4 c;</span><br><span class="line">            c.rgb = s.Albedo * _LightColor0 * NdotL * atten;</span><br><span class="line">            c.a = s.Alpha;</span><br><span class="line">            return c;</span><br><span class="line">        &#125;</span><br><span class="line">        ENDCG</span><br><span class="line">    &#125;</span><br><span class="line">    FallBack &quot;Diffuse&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="此外还有最终颜色修改函数"><a href="#此外还有最终颜色修改函数" class="headerlink" title="此外还有最终颜色修改函数"></a>此外还有最终颜色修改函数</h3><h2 id="曲面细分函数"><a href="#曲面细分函数" class="headerlink" title="曲面细分函数"></a>曲面细分函数</h2><h3 id="固定数量的曲面细分"><a href="#固定数量的曲面细分" class="headerlink" title="固定数量的曲面细分"></a>固定数量的曲面细分</h3><h3 id="基于边长的曲面细分"><a href="#基于边长的曲面细分" class="headerlink" title="基于边长的曲面细分"></a>基于边长的曲面细分</h3><h3 id="视锥剔除的曲面细分"><a href="#视锥剔除的曲面细分" class="headerlink" title="视锥剔除的曲面细分"></a>视锥剔除的曲面细分</h3><h3 id="基于距离的曲面细分"><a href="#基于距离的曲面细分" class="headerlink" title="基于距离的曲面细分"></a>基于距离的曲面细分</h3><h3 id="Phong曲面细分"><a href="#Phong曲面细分" class="headerlink" title="Phong曲面细分"></a>Phong曲面细分</h3><hr><p>Thanks:</p><p><a href="https://blog.csdn.net/zhr_hadoop/article/details/51177972">https://blog.csdn.net/zhr_hadoop/article/details/51177972</a></p><p>[TOC]</p>]]></content>
      
      
      
        <tags>
            
            <tag> Unity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Unity_shader】各类光照模型</title>
      <link href="/2021/11/17/Unity-shader2/"/>
      <url>/2021/11/17/Unity-shader2/</url>
      
        <content type="html"><![CDATA[<p>概括讲述了小部分的光照模型，如Lambert和phong模型，并在shader中实现。</p><span id="more"></span><h1 id="shader中的光照模型"><a href="#shader中的光照模型" class="headerlink" title="shader中的光照模型"></a>shader中的光照模型</h1><p>学到这一章，又为之前图形学的浑水摸鱼而感到羞耻我(＠_＠;)</p><h2 id="Lambert光照模型"><a href="#Lambert光照模型" class="headerlink" title="Lambert光照模型"></a>Lambert光照模型</h2><p>​    光射到粗糙的物体，产生漫反射（diffuse），满足Lambert定理：反射光线的强度与表面法线和光影方向之间的夹角成正比。即光线垂直物体表面时，漫反射强度最大。</p><p>其计算公式为：<br>$$<br>C_diffuse =(C_light<em>M_diffuse)saturate(n·l)<br>$$<br>​                        C物体的漫反射颜色=（C入射光线的颜色</em>M物体材质的漫反射颜色）将点积取[0，1]之间（物体的表面法线 -点积- 物体指向灯光的方向）</p><h3 id="那如何在shader里获得灯光呢"><a href="#那如何在shader里获得灯光呢" class="headerlink" title="那如何在shader里获得灯光呢"></a>那如何在shader里获得灯光呢</h3><p>​    Edit&gt;Project Setting&gt;Graphics 中发现已经被设置是前向渲染了</p><p>​    这下子可以使用的灯光属性变量有：_LightColor0     fixed4     灯光的颜色乘上亮度</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">Shader &quot;Hidden/<span class="number">1</span>_Lambert&quot;</span><br><span class="line">&#123;</span><br><span class="line">    Properties</span><br><span class="line">    &#123;</span><br><span class="line">        _MainColor(&quot;Main Color&quot;,Color)=(<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    SubShader</span><br><span class="line">    &#123;</span><br><span class="line">        Pass</span><br><span class="line">        &#123;</span><br><span class="line">            CGPROGRAM</span><br><span class="line">            <span class="meta">#pragma vertex vert</span></span><br><span class="line">            <span class="meta">#pragma fragment frag</span></span><br><span class="line">            <span class="meta">#include &quot;UnityCG.cginc&quot;</span></span><br><span class="line">            <span class="meta">#include &quot;UnityLightingCommon.cginc&quot;</span></span><br><span class="line"></span><br><span class="line">            struct v2f</span><br><span class="line">            &#123;</span><br><span class="line">                float4 pos : SV_POSITION;</span><br><span class="line">                fixed4 dif : COLOR0;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            fixed4 _MainColor;</span><br><span class="line"></span><br><span class="line">            v2f vert (appdata_base v)</span><br><span class="line">            &#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                o.pos =UnityObjectToClipPos(v.vertex);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//法线向量</span></span><br><span class="line">                float3 n=UnityObjectToWorldNormal(v.normal);</span><br><span class="line">                n=<span class="built_in">normalize</span>(n);</span><br><span class="line">                <span class="comment">//灯光方向向量</span></span><br><span class="line">                fixed3 l=<span class="built_in">normalize</span>(_WorldSpaceLightPos0.xyz);</span><br><span class="line">                <span class="comment">//按照公式计算漫反射s</span></span><br><span class="line">                fixed ndotl =<span class="built_in">dot</span>(n,l);<span class="comment">//点积</span></span><br><span class="line">                o.dif =_LightColor0*_MainColor*saturate(ndotl);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            fixed4 frag (v2f i) : SV_Target</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> i.dif;</span><br><span class="line">            &#125;</span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  //法线向量<br>                float3 n=UnityObjectToWorldNormal(v.normal);<br>                n=normalize(n);</p><p>​    计算光照时要确保在同一空间，而法线向量在模型空间，灯光方向向量在世界空间，因此要转化，并且进行标准化。<img src="/2021/11/17/Unity-shader2/image-20211117201538527.png" class title="image-20211117201334581"></p><hr><h2 id="Half-Lambert光照模型"><a href="#Half-Lambert光照模型" class="headerlink" title="Half-Lambert光照模型"></a>Half-Lambert光照模型</h2><p>​    前者Lambert光照能看到，物体的背面明显过黑，只能再加灯，但不利于性能的优化。故有half出现。</p><p>其计算公式为：<br>$$<br>C_diffuse =(C_light<em>M_diffuse)[0.5</em>(n·l)+0.5]<br>$$<br>​    如此可以看到是先乘0.5将区间缩小至[-0.5,0.5]，然后再加上去，使得物体光照强度从最亮逐渐过渡到最暗。</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//仅改动vertex_shader部分</span></span><br><span class="line">            v2f vert (appdata_base v)</span><br><span class="line">            &#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                o.pos =UnityObjectToClipPos(v.vertex);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//法线向量</span></span><br><span class="line">                float3 n=UnityObjectToWorldNormal(v.normal);</span><br><span class="line">                n=<span class="built_in">normalize</span>(n);</span><br><span class="line">                <span class="comment">//灯光方向向量</span></span><br><span class="line">                fixed3 l=<span class="built_in">normalize</span>(_WorldSpaceLightPos0.xyz);</span><br><span class="line">                <span class="comment">//按照公式计算漫反射s</span></span><br><span class="line">                fixed ndotl =<span class="built_in">dot</span>(n,l);</span><br><span class="line">                o.dif =_LightColor0*_MainColor*(<span class="number">0.5</span>*ndotl+<span class="number">0.5</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure><img src="/2021/11/17/Unity-shader2/image-20211117201523639.png" class title="image-20211117201523639"><hr><h2 id="Phong光照模型"><a href="#Phong光照模型" class="headerlink" title="Phong光照模型"></a>Phong光照模型</h2><p>​    Lambert能模拟粗糙表面的光照，但是还有很多光滑物体，因此引入镜面反射的光照模型-Phong（印象中好像片元分的够细，俩者效果其实相差无几）</p><p>（Phong，越南出生的美国科学家）</p><p>其计算公式为：<br>$$<br>SurfaceColor=C_Ambient+C_Diffuse+C_Specular<br>$$<br>即                                环境光+漫反射+镜面反射</p><p>其中镜面反射的公式为：<br>$$<br>C_Specular=(C_light·M_specular)saturate(v·r)^Mshininess<br>$$<br>即                                镜面反射光=（灯光亮度·物体材质镜面反射亮度）将范围截到[0,1] (视角方向·光线的发射方向)^物体材质的光泽度</p><h3 id="那如何在shader里获得环境光呢"><a href="#那如何在shader里获得环境光呢" class="headerlink" title="那如何在shader里获得环境光呢"></a>那如何在shader里获得环境光呢</h3><p>​    Window-Rendering-LightingSetting中environmentLight选择Gradient</p><p>​    即可使用：unity_AmbientSky 环境类型的sky color</p><p>​        unity_AmbientEquator</p><p>​        unity_AmbientGround</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">Shader &quot;Hidden/<span class="number">3</span>_Phong&quot;</span><br><span class="line">&#123;</span><br><span class="line">    Properties</span><br><span class="line">    &#123;</span><br><span class="line">        _MainColor(&quot;Main Color&quot;,Color)=(<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">        _SpecularColor(&quot;Specular Color&quot;,Color)=(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>)    <span class="comment">//控制高光颜色</span></span><br><span class="line">        _Shininess(&quot;Shininess&quot;,Range(<span class="number">1</span>,<span class="number">100</span>))=<span class="number">1</span>      <span class="comment">//控制光泽度</span></span><br><span class="line">    &#125;</span><br><span class="line">    SubShader</span><br><span class="line">    &#123;</span><br><span class="line">        Pass</span><br><span class="line">        &#123;</span><br><span class="line">            CGPROGRAM</span><br><span class="line">            <span class="meta">#pragma vertex vert</span></span><br><span class="line">            <span class="meta">#pragma fragment frag</span></span><br><span class="line">            <span class="meta">#include &quot;UnityCG.cginc&quot;</span></span><br><span class="line">            <span class="meta">#include &quot;Lighting.cginc&quot;</span></span><br><span class="line"></span><br><span class="line">            struct v2f</span><br><span class="line">            &#123;</span><br><span class="line">                float4 pos : SV_POSITION;</span><br><span class="line">                fixed4 color : COLOR0;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            fixed4 _MainColor;</span><br><span class="line">            fixed4 _SpecularColor;</span><br><span class="line">            half _Shininess;</span><br><span class="line"></span><br><span class="line">            v2f vert (appdata_base v)</span><br><span class="line">            &#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                o.pos =UnityObjectToClipPos(v.vertex);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//计算公式中各个变量</span></span><br><span class="line">                <span class="comment">//法线向量</span></span><br><span class="line">                float3 n=UnityObjectToWorldNormal(v.normal);</span><br><span class="line">                n=<span class="built_in">normalize</span>(n);</span><br><span class="line">                <span class="comment">//灯光方向向量</span></span><br><span class="line">                fixed3 l=<span class="built_in">normalize</span>(_WorldSpaceLightPos0.xyz);</span><br><span class="line">                fixed3 view=<span class="built_in">normalize</span>(WorldSpaceViewDir(v.vertex));</span><br><span class="line"></span><br><span class="line">                <span class="comment">//按照公式计算漫反射s</span></span><br><span class="line">                fixed ndotl =<span class="built_in">dot</span>(n,l);</span><br><span class="line">                fixed4 dif =_LightColor0*_MainColor*saturate(ndotl);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//镜面反射部分</span></span><br><span class="line">                float3 ref=<span class="built_in">reflect</span>(-l,n);</span><br><span class="line">                ref=<span class="built_in">normalize</span>(ref);</span><br><span class="line">                fixed rdotv=saturate(<span class="built_in">dot</span>(ref,view));</span><br><span class="line">                fixed4 spec=_LightColor0*_SpecularColor*<span class="built_in">pow</span>(rdotv,_Shininess);</span><br><span class="line"></span><br><span class="line">                o.color=unity_AmbientSky+dif+spec;</span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            fixed4 frag (v2f i) : SV_Target</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> i.color;</span><br><span class="line">            &#125;</span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><img src="/2021/11/17/Unity-shader2/image-20211117204323435.png" class title="image-20211117204323435"><h2 id="逐像素光照-per-pixel"><a href="#逐像素光照-per-pixel" class="headerlink" title="逐像素光照 per-pixel"></a>逐像素光照 per-pixel</h2><p>​    据说phong被应用之后，高光部分会边缘不够圆滑。这是因为光照模型的计算一直是逐顶点光照。</p><p>​    逐顶点光照，就是在顶点着色器中计算光照颜色。GPU在对顶点进行光照计算后，得到颜色，然后通过顶点在多边形上所占的范围对像素颜色进行线性插值。细分较低（多边形数量少）的模型，就会棱角分明，高光也不理想。</p><p>​    那么逐像素光照per-pixel就是在像素着色器（也就是片段着色器）进行着色的。计算不再基于顶点，而是像素，计算量增大。</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">    SubShader</span><br><span class="line">    &#123;</span><br><span class="line">        Pass</span><br><span class="line">        &#123;</span><br><span class="line">            CGPROGRAM</span><br><span class="line">            ......</span><br><span class="line"></span><br><span class="line">            struct v2f</span><br><span class="line">            &#123;</span><br><span class="line">                float4 pos : SV_POSITION;</span><br><span class="line">                float3 normal:TEXCOORD0;</span><br><span class="line">                float4 vertex:TEXCOORD1;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            fixed4 _MainColor;</span><br><span class="line">            fixed4 _SpecularColor;</span><br><span class="line">            half _Shininess;</span><br><span class="line"></span><br><span class="line">            v2f vert (appdata_base v)</span><br><span class="line">            &#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                o.pos =UnityObjectToClipPos(v.vertex);  </span><br><span class="line">                o.normal =v.normal;</span><br><span class="line">                o.vertex =v.vertex;</span><br><span class="line">                <span class="keyword">return</span> o;   </span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            fixed4 frag (v2f i) : SV_Target</span><br><span class="line">            &#123;</span><br><span class="line">                float3 n=UnityObjectToWorldNormal(i.normal);</span><br><span class="line">                n=<span class="built_in">normalize</span>(n);</span><br><span class="line">                fixed3 l=<span class="built_in">normalize</span>(_WorldSpaceLightPos0.xyz);</span><br><span class="line">                fixed3 view=<span class="built_in">normalize</span>(WorldSpaceViewDir(v.vertex));</span><br><span class="line"></span><br><span class="line">                <span class="comment">//按照公式计算漫反射s</span></span><br><span class="line">                fixed ndotl =<span class="built_in">dot</span>(n,l);</span><br><span class="line">                fixed4 dif =_LightColor0*_MainColor*saturate(ndotl);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//镜面反射部分</span></span><br><span class="line">                float3 ref=<span class="built_in">reflect</span>(-l,n);</span><br><span class="line">                ref=<span class="built_in">normalize</span>(ref);</span><br><span class="line">                fixed rdotv=saturate(<span class="built_in">dot</span>(ref,view));</span><br><span class="line">                fixed4 spec=_LightColor0*_SpecularColor*<span class="built_in">pow</span>(rdotv,_Shininess);</span><br><span class="line">                <span class="comment">//return    </span></span><br><span class="line">                <span class="keyword">return</span> unity_AmbientSky+dif+spec;</span><br><span class="line">            &#125;</span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="comment">//其实就是移过去了</span></span><br></pre></td></tr></table></figure><img src="/2021/11/17/Unity-shader2/image-20211118181116607.png" class title="per-vertex"><img src="/2021/11/17/Unity-shader2/image-20211118181228268.png" class title="per-pixel"><p>​    你能看出区别吗？（我不能）</p><hr><h2 id="Blinn-Phong光照模型"><a href="#Blinn-Phong光照模型" class="headerlink" title="Blinn-Phong光照模型"></a>Blinn-Phong光照模型</h2><p>​    与phong相比，将计算镜面反射光线的r（即入射光线的反射光线）替换成了入射光线和摄像机视角v的角平分线方向h。<br>$$<br>h=normalize(l,v)<br>$$</p><p>$$<br>C_Specular=(C_light·M_specular)saturate(v·h)^Mshininess<br>$$</p><p>​    其优点在于，在摄像机和光源都离物体无限远的时候，h只取决于俩者方向，可被视为常量，减少计算量。而phong则要根据表面曲率逐个计算反射向量r，效率低。</p><p>​    但在查阅资料后发现，phong还有一个很大的问题:<img src="/2021/11/17/Unity-shader2/92f4f5f9b284a56a0ee6e7f7235fb985.png" class title="两种模型的效果图2，此处可以发现Phong模型的一个问题"></p><p>​    “第二张效果图中，我们可以发现Phong模型在一些情况下会导致显示效果不平滑。当反射光与视线的夹角大于90度时，由于在实际渲染时余弦值总是被限制在[0,1]，在这些地方上高光项没有任何贡献。当物体的反光度非常小时，高光半径就会非常大，在反射角与视线夹角为90度的区域附近就会出现很明显的断层现象。而由于半角向量与法线夹角总不大于90度，使用Blinn-Phong模型时断层现象不会发生。”<img src="/2021/11/17/Unity-shader2/6a29e48cee2d8eee77eeddb6b49f22aa-16372315719662.png" class title="效果图2的断层问题的产生原因示意图"></p><hr><h2 id="灯光阴影"><a href="#灯光阴影" class="headerlink" title="灯光阴影"></a>灯光阴影</h2><h3 id="渲染路径"><a href="#渲染路径" class="headerlink" title="渲染路径"></a>渲染路径</h3><h4 id="延迟着色渲染"><a href="#延迟着色渲染" class="headerlink" title="延迟着色渲染"></a>延迟着色渲染</h4><p>​    较强，需要设备支持，所有灯光可以逐像素渲染</p><h4 id="前向渲染"><a href="#前向渲染" class="headerlink" title="前向渲染"></a>前向渲染</h4><p>​    传统的渲染方式，支持所有unity图形，兼容性好。</p><p>​    默认4个逐像素灯光（渲染模式为Important，如果不够4个，比较亮的灯光会逐像素渲染），4个逐顶点灯光，其他的都是SH渲染（Spherical Harmonics 球谐 球面调和）。SH渲染很快，只消耗较少cpu，几乎无gpu。</p><h3 id="Pass里面的标签"><a href="#Pass里面的标签" class="headerlink" title="Pass里面的标签"></a>Pass里面的标签</h3><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Pass&#123;</span><br><span class="line">Tags&#123;</span><br><span class="line">&quot;LightMode&quot; = &quot;ForwardBase&quot; </span><br><span class="line">        &quot;PassFlags&quot; = &quot;xxxx&quot;</span><br><span class="line"><span class="comment">//定义该Pass在Unity的流水线中的角色 (只有定义它才能获取到一些Unity内置的光照变量如_LightColor0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="内置的-multi-compile-多重编译指令"><a href="#内置的-multi-compile-多重编译指令" class="headerlink" title="内置的 multi_compile 多重编译指令"></a>内置的 multi_compile 多重编译指令</h3><p>​    #pragma multi_compile_fwdbase是unity内置的用于前向渲染的关键字快捷方式，它包含了前向渲染光照计算需要的大多数关键字，因此会被shader带来很多的变体。</p><h3 id="实现阴影-投影-效果"><a href="#实现阴影-投影-效果" class="headerlink" title="实现阴影(投影)效果"></a>实现阴影(投影)效果</h3><p>​    案例使用Lambert光照模型，不计算镜面反射。按照前向渲染的光照标准进行，分为俩个pass。</p><p>​    基础pass用于渲染平行光和逐顶点或者SH灯光，并为平行光产生阴影投影。</p><p>​    额外pass用于逐像素，也为逐像素灯光产生阴影投影。</p><img src="/2021/11/17/Unity-shader2/image-20211118193048793.png" class title="image-20211118193048793"><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br></pre></td><td class="code"><pre><span class="line">Shader &quot;Hidden/<span class="number">5</span>_LambertWithShadow&quot;</span><br><span class="line">&#123;</span><br><span class="line">    Properties</span><br><span class="line">    &#123;</span><br><span class="line">        _MainColor (&quot;Main Color&quot;, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    SubShader</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// -------- 基础Pass 为主要平行光产生投影 --------</span></span><br><span class="line">        Pass</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 添加Pass标签</span></span><br><span class="line">            Tags&#123;&quot;LightMode&quot; = &quot;ForwardBase&quot;&#125;</span><br><span class="line"></span><br><span class="line">            CGPROGRAM</span><br><span class="line">            <span class="meta">#pragma vertex vert</span></span><br><span class="line">            <span class="meta">#pragma fragment frag</span></span><br><span class="line">            <span class="meta">#pragma multi_compile_fwdbase</span></span><br><span class="line">            <span class="meta">#include &quot;UnityCG.cginc&quot;</span></span><br><span class="line">            <span class="meta">#include &quot;Lighting.cginc&quot;</span></span><br><span class="line">            <span class="meta">#include &quot;AutoLight.cginc&quot;</span></span><br><span class="line"></span><br><span class="line">            struct v2f</span><br><span class="line">            &#123;</span><br><span class="line">                float4 pos : SV_POSITION;</span><br><span class="line">                float3 normal : TEXCOORD0;</span><br><span class="line">                float4 vertex : TEXCOORD1;</span><br><span class="line">                SHADOW_COORDS(<span class="number">2</span>) <span class="comment">// 使用预定义宏保存阴影坐标</span></span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            fixed4 _MainColor;</span><br><span class="line"></span><br><span class="line">            v2f vert (appdata_base v)</span><br><span class="line">            &#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">                o.normal = v.normal;</span><br><span class="line">                o.vertex = v.vertex;</span><br><span class="line">                TRANSFER_SHADOW(o) <span class="comment">// 使用预定义宏变换阴影坐标</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            fixed4 frag (v2f i) : SV_Target</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 准备变量</span></span><br><span class="line">                float3 n = UnityObjectToWorldNormal(i.normal);</span><br><span class="line">                n = <span class="built_in">normalize</span>(n);</span><br><span class="line">                float3 l = WorldSpaceLightDir(i.vertex);</span><br><span class="line">                l = <span class="built_in">normalize</span>(l);</span><br><span class="line">                float4 worldPos = mul(unity_ObjectToWorld, i.vertex);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Lambert光照</span></span><br><span class="line">                fixed ndotl = saturate(<span class="built_in">dot</span>(n, l));</span><br><span class="line">                fixed4 color = _LightColor0 * _MainColor * ndotl;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 加上4个点光源的光照</span></span><br><span class="line">                color.rgb += Shade4PointLights(</span><br><span class="line">                unity_4LightPosX0, unity_4LightPosY0, unity_4LightPosZ0,</span><br><span class="line">                unity_LightColor[<span class="number">0</span>].rgb, unity_LightColor[<span class="number">1</span>].rgb,</span><br><span class="line">                unity_LightColor[<span class="number">2</span>].rgb, unity_LightColor[<span class="number">3</span>].rgb,</span><br><span class="line">                unity_4LightAtten0, worldPos.rgb, n) * _MainColor;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 加上环境光照</span></span><br><span class="line">                color += unity_AmbientSky;<span class="comment">//区别仅仅在这？</span></span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 使用预定义宏计算阴影系数</span></span><br><span class="line">                UNITY_LIGHT_ATTENUATION(shadowmask, i, worldPos.rgb)</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 阴影合成</span></span><br><span class="line">                color.rgb *= shadowmask;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> color;</span><br><span class="line">            &#125;</span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// -------- 额外的Pass 为其他逐像素的灯光产生投影 --------</span></span><br><span class="line">        Pass</span><br><span class="line">        &#123;</span><br><span class="line">            Tags&#123;&quot;LightMode&quot; = &quot;ForwardAdd&quot;&#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 使用相加混合，使绘制的图像与上一个Pass完全混合</span></span><br><span class="line">            Blend One One</span><br><span class="line"></span><br><span class="line">            CGPROGRAM</span><br><span class="line">            <span class="meta">#pragma vertex vert</span></span><br><span class="line">            <span class="meta">#pragma fragment frag</span></span><br><span class="line">            <span class="meta">#pragma multi_compile_fwdadd_fullshadows</span></span><br><span class="line">            <span class="meta">#include &quot;UnityCG.cginc&quot;</span></span><br><span class="line">            <span class="meta">#include &quot;Lighting.cginc&quot;</span></span><br><span class="line">            <span class="meta">#include &quot;AutoLight.cginc&quot;</span></span><br><span class="line"></span><br><span class="line">            struct v2f</span><br><span class="line">            &#123;</span><br><span class="line">                float4 pos : SV_POSITION;</span><br><span class="line">                float3 normal : TEXCOORD0;</span><br><span class="line">                float4 vertex : TEXCOORD1;</span><br><span class="line">                SHADOW_COORDS(<span class="number">2</span>) <span class="comment">// 使用预定义宏保存阴影坐标</span></span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            fixed4 _MainColor;</span><br><span class="line"></span><br><span class="line">            v2f vert (appdata_base v)</span><br><span class="line">            &#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">                o.normal = v.normal;</span><br><span class="line">                o.vertex = v.vertex;</span><br><span class="line">                TRANSFER_SHADOW(o) <span class="comment">// 使用预定义宏变换阴影坐标</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            fixed4 frag (v2f i) : SV_Target</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 准备变量</span></span><br><span class="line">                float3 n = UnityObjectToWorldNormal(i.normal);</span><br><span class="line">                n = <span class="built_in">normalize</span>(n);</span><br><span class="line">                float3 l = WorldSpaceLightDir(i.vertex);</span><br><span class="line">                l = <span class="built_in">normalize</span>(l);</span><br><span class="line">                float4 worldPos = mul(unity_ObjectToWorld, i.vertex);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Lambert光照</span></span><br><span class="line">                fixed ndotl = saturate(<span class="built_in">dot</span>(n, l));</span><br><span class="line">                fixed4 color = _LightColor0 * _MainColor * ndotl;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 加上4个点光源的光照</span></span><br><span class="line">                color.rgb += Shade4PointLights(</span><br><span class="line">                unity_4LightPosX0, unity_4LightPosY0, unity_4LightPosZ0,</span><br><span class="line">                unity_LightColor[<span class="number">0</span>].rgb, unity_LightColor[<span class="number">1</span>].rgb,</span><br><span class="line">                unity_LightColor[<span class="number">2</span>].rgb, unity_LightColor[<span class="number">3</span>].rgb,</span><br><span class="line">                unity_4LightAtten0, worldPos.rgb, n) * _MainColor;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 使用预定义宏计算阴影系数</span></span><br><span class="line">                UNITY_LIGHT_ATTENUATION(shadowmask, i, worldPos.rgb)</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 阴影合成</span></span><br><span class="line">                color.rgb *= shadowmask;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> color;</span><br><span class="line">            &#125;</span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    FallBack &quot;Diffuse&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有一说一，没有很看懂…………</p><h1 id="带纹理的shader！（转载部分）"><a href="#带纹理的shader！（转载部分）" class="headerlink" title="带纹理的shader！（转载部分）"></a>带纹理的shader！（转载部分）</h1><h2 id="1-使用Blinn-Phong光照模型的单张纹理Shader："><a href="#1-使用Blinn-Phong光照模型的单张纹理Shader：" class="headerlink" title="1.使用Blinn-Phong光照模型的单张纹理Shader："></a>1.使用Blinn-Phong光照模型的单张纹理Shader：</h2><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">Shader &quot;Custom/SingleTexture&quot; &#123;</span><br><span class="line">Properties &#123;</span><br><span class="line">_Color (&quot;Color&quot;, Color) = (<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">_MainTex (&quot;Albedo&quot;, <span class="number">2</span>D) = &quot;white&quot; &#123;&#125;</span><br><span class="line">_Gloss (&quot;Gloss&quot;, Range(<span class="number">8.0</span>,<span class="number">256</span>)) = <span class="number">20</span></span><br><span class="line">_Specular (&quot;Specular&quot;, Color) = (<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line">SubShader &#123;</span><br><span class="line">Pass&#123;</span><br><span class="line">Tags&#123;&quot;RenderType&quot;=&quot;ForwardBase&quot;&#125;</span><br><span class="line">CGPROGRAM</span><br><span class="line"><span class="meta">#pragma vertex vert</span></span><br><span class="line"><span class="meta">#pragma fragment frag</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#include &quot;Lighting.cginc&quot;</span></span><br><span class="line"> </span><br><span class="line">fixed4 _Color;</span><br><span class="line"><span class="type">sampler2D</span> _MainTex;</span><br><span class="line">float4 _MainTex_ST;</span><br><span class="line"><span class="type">float</span> _Gloss;</span><br><span class="line">fixed4 _Specular;</span><br><span class="line"> </span><br><span class="line">struct a2v&#123;</span><br><span class="line">float4 vertex:POSITION;</span><br><span class="line">float3 normal:NORMAL;</span><br><span class="line">float4 texcoord:TEXCOORD0;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">struct v2f&#123;</span><br><span class="line">float4 pos:SV_POSITION;</span><br><span class="line">float3 worldNormal:TEXCOORD0;</span><br><span class="line">float3 worldPos:TEXCOORD1;</span><br><span class="line">float2 uv:TEXCOORD2;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">v2f vert(a2v v)&#123;</span><br><span class="line">v2f o;</span><br><span class="line">o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">o.worldNormal = <span class="built_in">normalize</span>(mul(v.normal, (float3x3)unity_WorldToObject));</span><br><span class="line">float4 worldPos = mul(unity_ObjectToWorld, v.vertex);</span><br><span class="line">o.worldPos = worldPos.xyz;</span><br><span class="line">o.uv = v.texcoord.xy * _MainTex_ST.xy + _MainTex_ST.zw;</span><br><span class="line"><span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">fixed4 frag(v2f i):SV_TARGET&#123;</span><br><span class="line">float3 worldNormal = i.worldNormal;</span><br><span class="line">float3 worldPos = i.worldPos;</span><br><span class="line">float3 worldLight = <span class="built_in">normalize</span>(UnityWorldSpaceLightDir(worldPos));</span><br><span class="line"> </span><br><span class="line">float3 albedo = tex2D(_MainTex,i.uv).rgb * _Color.rgb;</span><br><span class="line"> </span><br><span class="line">fixed3 diffuse = _LightColor0.rgb * albedo * saturate(<span class="built_in">dot</span>(worldNormal, worldLight));</span><br><span class="line"> </span><br><span class="line">float3 viewDir = <span class="built_in">normalize</span>(UnityWorldSpaceViewDir(worldPos));</span><br><span class="line">float3 h = <span class="built_in">normalize</span>(viewDir + worldLight);</span><br><span class="line"> </span><br><span class="line">fixed3 specular = _LightColor0.rgb * _Specular.rgb * <span class="built_in">pow</span>(saturate(<span class="built_in">dot</span>(h,worldNormal)),_Gloss);</span><br><span class="line"> </span><br><span class="line">fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT * albedo;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> fixed4(ambient + diffuse + specular, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">ENDCG</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">FallBack &quot;Diffuse&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    在属性声明中，我们添加了一个_MainTexture变量，它是2D类型的，在Inspecutor面板中，它可以选择一张贴图。</p><p>​    在a2v中我们声明了texcoord，通过它与_MainTexture中的值来计算v2f中的uv纹理坐标值，通过这个uv坐标值获取纹理信息。</p><p>​    我们不仅声明了sampler2D类型的_MainTexture，还声明了一个float4类型的_MainTexture_ST，ST是scale缩放与translation平移的缩写，可以通过它获得纹理的缩放和平移值，其中_MainTexture_ST.xy存储的是缩放值，_MainTexture_ST.zw存储的是偏移值。</p><p>​    在vert函数中，我们计算uv纹理坐标值并通过v2f传递给frag函数，在frag函数中，通过tex2D(_MainTexture, uv)获得纹理信息。计算得albedo=Color * texInfo，然后计算diffuse的等式中的材质属性用albedo来计算，环境光计算也要用ambient=UNITY_AMBIENT * albedo，高光计算不使用albedo。</p><p>​    这样我们就完成了最简单的纹理Shader</p><h2 id="2-应用法线纹理的Shader："><a href="#2-应用法线纹理的Shader：" class="headerlink" title="2.应用法线纹理的Shader："></a>2.应用法线纹理的Shader：</h2><p>​    法线纹理用于存储表面法线信息，一般一张法线纹理对应着一张普通纹理。我们也可以这样理解，法线纹理中保存的法线 就是用于替换原来  光照模型计算过程中  使用的worldNormal（及其他空间的normal）。由于法线方向分量范围为[-1，1]，而像素分量范围为[0，1]，所以我们要做一个映射来在纹理中存储法线分量：</p><p>​    pixel = （normal+1）/ 2</p><p>​    normal = pixel X 2 - 1</p><p>​    法线纹理中存储的法线方向，是保存在切线空间中的。这里来解释一下切线空间：切线空间中x轴为该点的切线方向，z轴为该点的法线方向，y轴为x，z轴叉乘得到的方向轴。如果法线纹理中的法线与该点原来的法线一致，则为(0，0，1)，在纹理中表现为蓝色，如果不一致则会表现为其他颜色，这样就在法线纹理中表示出了法线的特征。</p><p>​    所以我们的计算可以分为两种：</p><p>​    （1）在切线空间计算，需要到切线空间的变换矩阵</p><p>​    （2）在世界空间计算，需要切线空间到世界空间的变换矩阵</p><p>切线空间计算的Shader如下：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">Shader &quot;Custom/NormalMap_1&quot; &#123;</span><br><span class="line">Properties &#123;</span><br><span class="line">_Color(&quot;Color&quot;,Color) = (<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">_Specular(&quot;Specular&quot;,Color) = (<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">_Gloss(&quot;Gloss&quot;,Range(<span class="number">8.0</span>,<span class="number">256</span>))=<span class="number">20</span></span><br><span class="line">_MainTex(&quot;Texture&quot;,<span class="number">2</span>D)=&quot;white&quot;&#123;&#125;</span><br><span class="line">_NormalMap(&quot;NormalMap&quot;,<span class="number">2</span>D)=&quot;white&quot;&#123;&#125;</span><br><span class="line">_NormalScale(&quot;NormalScale&quot;,Float) = <span class="number">1.0</span></span><br><span class="line">&#125;</span><br><span class="line">SubShader &#123;</span><br><span class="line">Pass&#123;</span><br><span class="line">Tags&#123;&quot;RenderType&quot;=&quot;ForwardBase&quot;&#125;</span><br><span class="line">CGPROGRAM</span><br><span class="line"><span class="meta">#pragma vertex vert</span></span><br><span class="line"><span class="meta">#pragma fragment frag</span></span><br><span class="line"><span class="meta">#include &quot;Lighting.cginc&quot;</span></span><br><span class="line"> </span><br><span class="line">fixed4 _Color;</span><br><span class="line">fixed4 _Specular;</span><br><span class="line"><span class="type">float</span> _Gloss;</span><br><span class="line"><span class="type">sampler2D</span> _MainTex;</span><br><span class="line">float4 _MainTex_ST;</span><br><span class="line"><span class="type">sampler2D</span> _NormalMap;</span><br><span class="line">float4 _NormalMap_ST;</span><br><span class="line"><span class="type">float</span> _NormalScale;</span><br><span class="line"> </span><br><span class="line">struct a2v&#123;</span><br><span class="line">float4 vertex:POSITION;</span><br><span class="line">float3 normal:NORMAL;</span><br><span class="line">float4 tangent:TANGENT;</span><br><span class="line">float4 texcoord:TEXCOORD0;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">struct v2f&#123;</span><br><span class="line">float4 pos:SV_POSITION;</span><br><span class="line">float4 uv:TEXCOORD0;</span><br><span class="line">float3 lightDir:TEXCOORD1;</span><br><span class="line">float3 viewDir:TEXCOORD2;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">v2f vert(a2v v)&#123;</span><br><span class="line">v2f o;</span><br><span class="line">o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">o.uv.xy = _MainTex_ST.xy * v.texcoord.xy + _MainTex_ST.zw;</span><br><span class="line">o.uv.zw = _NormalMap_ST.xy * v.texcoord.xy + _NormalMap_ST.zw;</span><br><span class="line"> </span><br><span class="line">float3 binormal = <span class="built_in">cross</span>(<span class="built_in">normalize</span>(v.normal), <span class="built_in">normalize</span>(v.tangent.xyz)) * v.tangent.w;</span><br><span class="line">float3x3 rotation = float3x3(<span class="built_in">normalize</span>(v.tangent.xyz), <span class="built_in">normalize</span>(binormal), <span class="built_in">normalize</span>(v.normal));</span><br><span class="line">o.lightDir = <span class="built_in">normalize</span>(mul(rotation, ObjSpaceLightDir(v.vertex)).xyz);</span><br><span class="line">o.viewDir = <span class="built_in">normalize</span>(mul(rotation, ObjSpaceViewDir(v.vertex)).xyz);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">fixed4 frag(v2f i):SV_TARGET&#123;</span><br><span class="line">fixed3 tangentLightDir = i.lightDir;</span><br><span class="line">fixed3 tangentViewDir = i.viewDir;</span><br><span class="line"> </span><br><span class="line">fixed4 packedNormal = tex2D(_NormalMap, i.uv.zw);</span><br><span class="line">fixed3 tangentNormal;</span><br><span class="line">tangentNormal.xy = (packedNormal.xy * <span class="number">2</span> - <span class="number">1</span>) * _NormalScale;</span><br><span class="line">tangentNormal.z = <span class="built_in">sqrt</span>(<span class="number">1.0</span>-saturate(<span class="built_in">dot</span>(tangentNormal.xy,tangentNormal.xy)));</span><br><span class="line"> </span><br><span class="line">fixed3 albedo = tex2D(_MainTex, i.uv.xy).rgb * _Color.rgb;</span><br><span class="line"> </span><br><span class="line">fixed3 diffuse = _LightColor0.rgb * albedo * saturate(<span class="built_in">dot</span>(tangentLightDir, tangentNormal));</span><br><span class="line"> </span><br><span class="line">fixed3 h = <span class="built_in">normalize</span>(tangentLightDir + tangentViewDir);</span><br><span class="line">fixed3 specular = _LightColor0.rgb * _Specular.rgb * <span class="built_in">pow</span>(saturate(<span class="built_in">dot</span>(h, tangentNormal)),_Gloss);</span><br><span class="line"> </span><br><span class="line">fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz * albedo;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> fixed4(diffuse+specular+ambient, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">ENDCG</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">FallBack &quot;Diffuse&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    在vert函数中的rotation就是变换到切线空间的矩阵，它是切线空间x轴，y轴，z轴按顺序排列得到的矩阵。frag中的packedNormal是法线纹理中的像素信息(在[0，1]中)，tangentNormal是变换后的法线信息(在变换到[-1，1]中后乘以Scale)</p><p>在世界空间中的计算：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">Shader &quot;Custom/NormalMap_2&quot; &#123;</span><br><span class="line">Properties &#123;</span><br><span class="line">_Color (&quot;Color&quot;, Color) = (<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">_Specular(&quot;Specular&quot;,Color) = (<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">_Gloss(&quot;Gloss&quot;,Range(<span class="number">8.0</span>,<span class="number">256</span>))=<span class="number">20</span></span><br><span class="line">_MainTex (&quot;MainTex&quot;, <span class="number">2</span>D) = &quot;white&quot; &#123;&#125;</span><br><span class="line">_NormalMap(&quot;NormalMap&quot;,<span class="number">2</span>D)= &quot;white&quot;&#123;&#125;</span><br><span class="line">_NormalScale(&quot;NormalScale&quot;,Float) = <span class="number">1.0</span></span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line">SubShader &#123;</span><br><span class="line">Pass&#123;</span><br><span class="line">Tags&#123;&quot;LightMode&quot;=&quot;ForwardBase&quot;&#125;</span><br><span class="line">CGPROGRAM</span><br><span class="line"><span class="meta">#pragma vertex vert</span></span><br><span class="line"><span class="meta">#pragma fragment frag</span></span><br><span class="line"><span class="meta">#include &quot;Lighting.cginc&quot;</span></span><br><span class="line"> </span><br><span class="line">fixed4 _Color;</span><br><span class="line">fixed4 _Specular;</span><br><span class="line"><span class="type">float</span> _Gloss;</span><br><span class="line"><span class="type">sampler2D</span> _MainTex;</span><br><span class="line">float4 _MainTex_ST;</span><br><span class="line"><span class="type">sampler2D</span> _NormalMap;</span><br><span class="line">float4 _NormalMap_ST;</span><br><span class="line"><span class="type">float</span> _NormalScale;</span><br><span class="line"> </span><br><span class="line">struct a2v&#123;</span><br><span class="line">float4 vertex:POSITION;</span><br><span class="line">float3 normal:NORMAL;</span><br><span class="line">float2 texcoord:TEXCOORD0;</span><br><span class="line">float4 tangent:TANGENT;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">struct v2f&#123;</span><br><span class="line">float4 pos:SV_POSITION;</span><br><span class="line">float3 worldPos:TEXCOORD0;</span><br><span class="line">float3 T2W_0:TEXCOORD2;</span><br><span class="line">float3 T2W_1:TEXCOORD3;</span><br><span class="line">float3 T2W_2:TEXCOORD4;</span><br><span class="line">float4 uv:TEXCOORD1;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">v2f vert(a2v v)&#123;</span><br><span class="line">v2f o;</span><br><span class="line">fixed3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;</span><br><span class="line">fixed3 worldNormal = <span class="built_in">normalize</span>(mul(v.normal, (float3x3)unity_WorldToObject));</span><br><span class="line">fixed3 worldTangent = <span class="built_in">normalize</span>(mul(unity_ObjectToWorld, v.tangent).xyz);</span><br><span class="line">fixed3 binormal = <span class="built_in">normalize</span>(<span class="built_in">cross</span>(worldNormal, worldTangent) * v.tangent.w);</span><br><span class="line"> </span><br><span class="line">o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">o.worldPos = worldPos;</span><br><span class="line">o.T2W_0 = float3(worldTangent.x, binormal.x, worldNormal.x);</span><br><span class="line">o.T2W_1 = float3(worldTangent.y, binormal.y, worldNormal.y);</span><br><span class="line">o.T2W_2 = float3(worldTangent.z, binormal.z, worldNormal.z);</span><br><span class="line">o.uv.xy = _MainTex_ST.xy * v.texcoord.xy + _MainTex_ST.zw;</span><br><span class="line">o.uv.zw = _NormalMap_ST.xy * v.texcoord.xy + _NormalMap_ST.zw;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">fixed4 frag(v2f i):SV_TARGET&#123;</span><br><span class="line">float3 worldLightDir = <span class="built_in">normalize</span>(UnityWorldSpaceLightDir(i.worldPos));</span><br><span class="line">float3 worldViewDir = <span class="built_in">normalize</span>(UnityWorldSpaceViewDir(i.worldPos));</span><br><span class="line"> </span><br><span class="line">float3 packedNormal = tex2D(_NormalMap, i.uv.zw).xyz;</span><br><span class="line">float3 bump;</span><br><span class="line">bump.xy = (packedNormal.xy * <span class="number">2</span> - <span class="number">1</span>) * _NormalScale;</span><br><span class="line">bump.z = <span class="built_in">sqrt</span>(<span class="number">1.0</span> - saturate(<span class="built_in">dot</span>(bump.xy, bump.xy)));</span><br><span class="line"> </span><br><span class="line">bump = <span class="built_in">normalize</span>(half3(<span class="built_in">dot</span>(i.T2W_0, bump), <span class="built_in">dot</span>(i.T2W_1,bump), <span class="built_in">dot</span>(i.T2W_2,bump)));</span><br><span class="line"> </span><br><span class="line">fixed3 albedo = tex2D(_MainTex, i.uv.xy).rgb * _Color.rgb;</span><br><span class="line"> </span><br><span class="line">fixed3 diffuse = _LightColor0.rgb * albedo * saturate(<span class="built_in">dot</span>(worldLightDir, bump));</span><br><span class="line">fixed3 ambient = albedo * UNITY_LIGHTMODEL_AMBIENT.rgb;</span><br><span class="line"> </span><br><span class="line">fixed3 h = <span class="built_in">normalize</span>(worldLightDir + worldViewDir);</span><br><span class="line">fixed3 specular = _LightColor0.rgb * _Specular.rgb * <span class="built_in">pow</span>(saturate(<span class="built_in">dot</span>(h,bump)),_Gloss);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> fixed4(diffuse + ambient + specular, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">ENDCG</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">FallBack &quot;Diffuse&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>[TOC]</p><p>Thanks：</p><p><a href="https://www.pianshen.com/article/18651304807/">https://www.pianshen.com/article/18651304807/</a></p><p>【GDC2008】Stupid Spherical Harmonics (SH) Tricks:<a href="https://www.jianshu.com/p/a379b4c6d346">https://www.jianshu.com/p/a379b4c6d346</a></p><p>聊一下球谐函数（Spherical Harmonics）计算光照:<a href="https://zhuanlan.zhihu.com/p/34059900">https://zhuanlan.zhihu.com/p/34059900</a></p><p><a href="https://www.cnblogs.com/sifenkesi/p/9942272.html">https://www.cnblogs.com/sifenkesi/p/9942272.html</a></p><p>特别感谢：<a href="https://blog.csdn.net/qq_37394426/article/details/86659283?spm=1001.2014.3001.5502">https://blog.csdn.net/qq_37394426/article/details/86659283?spm=1001.2014.3001.5502</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Unity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Unity_shader】格式简介</title>
      <link href="/2021/11/16/Unity-shader/"/>
      <url>/2021/11/16/Unity-shader/</url>
      
        <content type="html"><![CDATA[<p>概括讲述了Unity shader的基本代码格式，建议看完渲染流水线再来看。</p><span id="more"></span><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><h2 id="空间投影变换"><a href="#空间投影变换" class="headerlink" title="空间投影变换"></a>空间投影变换</h2><p>…请跳转到《图形渲染流水线》一节，在那里给出了清晰的解释。</p><h2 id="现代gpu渲染流水线"><a href="#现代gpu渲染流水线" class="headerlink" title="现代gpu渲染流水线"></a>现代gpu渲染流水线</h2><img src="/2021/11/16/Unity-shader/image-20211121131304409.png" class title="image-20211121131304409"><hr><h2 id="Shader概念"><a href="#Shader概念" class="headerlink" title="Shader概念"></a>Shader概念</h2><p>​    shader是渲染流水线的一部分，由顶点着色器和片段着色器构成（着色器(Shader)是运行在GPU上的小程序。这些小程序为图形渲染管线的某个特定部分而运行。从基本意义上来说，着色器只是一种把输入转化为输出的程序。着色器也是一种非常独立的程序，因为它们之间不能相互通信；它们之间唯一的沟通只有通过输入和输出。）</p><p>​    unity用cg编写，OpenGL用glsl，direct3d用hlsl。<strong>unity基于hlsl产生的cg</strong>。</p><h2 id="shaderlab语法基础"><a href="#shaderlab语法基础" class="headerlink" title="shaderlab语法基础"></a>shaderlab语法基础</h2><p>​    shader结构为：<strong>properties subshader fallback</strong></p><p>​    如果是顶点片段着色器，里面还会包含pass{}</p><hr><h3 id="properties"><a href="#properties" class="headerlink" title="properties"></a><strong>properties</strong></h3><p>​    开放出来的变量，可以在控制面板中调节</p><p>​    properties主要分为三大类：<strong>数值 颜色与向量 纹理贴图</strong>，也就是代码中type的部分。</p><p>​    每条属性的语法如下：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">_Name(&quot;Display Name&quot;,type) = defaultValue[&#123;options&#125;]</span><br><span class="line"><span class="comment">//属性名字（“显示的名字”，属性的类型）=将shader指定给材质时初始化的默认值</span></span><br></pre></td></tr></table></figure><h4 id="1-数值类properties"><a href="#1-数值类properties" class="headerlink" title="1. 数值类properties"></a>1. 数值类properties</h4><p>​    基本都是float，有以下俩种</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">name</span>(<span class="string">&quot;display name&quot;</span>, <span class="built_in">Float</span>)=<span class="keyword">number</span></span><br><span class="line"><span class="keyword">name</span>(<span class="string">&quot;display name&quot;</span>, <span class="built_in">Range</span>(<span class="built_in">min</span>,<span class="built_in">max</span>))=<span class="keyword">number</span></span><br></pre></td></tr></table></figure><h4 id="2-颜色和向量类properties"><a href="#2-颜色和向量类properties" class="headerlink" title="2. 颜色和向量类properties"></a>2. 颜色和向量类properties</h4><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">name(&quot;display name&quot;, Color)=(number,number,number,number)<span class="comment">//RGBA</span></span><br><span class="line">name(&quot;display name&quot;, Vector)=(number1,number2,number3,number4)</span><br></pre></td></tr></table></figure><h4 id="3-纹理贴图类"><a href="#3-纹理贴图类" class="headerlink" title="3. 纹理贴图类"></a>3. 纹理贴图类</h4><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">name(&quot;display name&quot;, <span class="number">2</span>D)=&quot;defaulttexture&quot;&#123;&#125;</span><br><span class="line">name(&quot;display name&quot;, Cube)=&quot;defaulttexture&quot;&#123;&#125;</span><br><span class="line">name(&quot;display name&quot;, <span class="number">3</span>D)=&quot;defaulttexture&quot;&#123;&#125;</span><br></pre></td></tr></table></figure><p>​    2D最常使用，例如<strong>漫反射贴图，法线贴图</strong>。其defaulttexture可以用各种颜色 black red</p><p>​    <strong>Cube</strong>全称CubeMapTexture立方体纹理，由六张有联系的2D贴图拼成的立方体，主要用于<strong>反射</strong>，例如Skybox和ReflectionProb</p><img src="/2021/11/16/Unity-shader/image-20211121123058929.png" class title="image-20211121123058929"><h4 id="不要忘记，如果要在subshader的pass中使用，需要在CGPROGRAM段之内进行声明："><a href="#不要忘记，如果要在subshader的pass中使用，需要在CGPROGRAM段之内进行声明：" class="headerlink" title="不要忘记，如果要在subshader的pass中使用，需要在CGPROGRAM段之内进行声明："></a>不要忘记，如果要在subshader的pass中使用，需要在CGPROGRAM段之内进行声明：</h4><img src="/2021/11/16/Unity-shader/image-20211121123120716.png" class title="image-20211121123120716"><img src="/2021/11/16/Unity-shader/image-20211121123219881.png" class title="image-20211121123219881"><p>​    <strong>开放属性与CG属性的对应关系：</strong> </p><ol><li>​    <strong>Float 和 Range 前面加入 float half fixed</strong></li><li>​    <strong>纹理贴图类2D cube 3D 要加入 sampler2D / samplerCube / sampler3D</strong></li><li>​    <strong>Color 和 vector    要用half4，或者float4，fixed4，其中颜色最好使用fixed4(节约性能)</strong></li></ol><hr><h3 id="SubShader"><a href="#SubShader" class="headerlink" title="SubShader"></a>SubShader</h3><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">SubShader</span><br><span class="line">    &#123;</span><br><span class="line">    Tags &#123; &quot;RenderType&quot;=&quot;Opaque&quot; &#125;</span><br><span class="line">        <span class="comment">//渲染状况</span></span><br><span class="line">        cull back</span><br><span class="line">    LOD <span class="number">200</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//1:LOD Level of Detail, 根据LOD来设置使用不同版本的Shader;</span></span><br><span class="line"><span class="comment">//2:着色器中给SubShader一个LOD值，程序来设置这个shader的LOD值，只有第一个小于等于LOD值subShader才会被执行;</span></span><br><span class="line"><span class="comment">//3: 每个shader最多只会有一个SubShader被使用;</span></span><br><span class="line">    </span><br><span class="line">        Pass</span><br><span class="line">        &#123;</span><br><span class="line">            CGPROGRAM</span><br><span class="line">            ...</span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">FallBack &quot;Diffuse&quot;</span><br></pre></td></tr></table></figure><h4 id="tags"><a href="#tags" class="headerlink" title="tags"></a><strong>tags</strong></h4><h5 id="1-渲染队列"><a href="#1-渲染队列" class="headerlink" title="1. 渲染队列"></a>1. 渲染队列</h5><p>​    可以用Tags{“Quene”=”Geometry+1”}来指定队列，unity有五种指定的队列。当然也可以在材质面板中选择<img src="/2021/11/16/Unity-shader/image-20211117143648273.png" class title="image-20211117143648273"></p><h5 id="2-渲染类型"><a href="#2-渲染类型" class="headerlink" title="2. 渲染类型"></a>2. 渲染类型</h5><p>​    RenderType可以进行划分，便于替换深度纹理</p><p>​    比如 Tags { “RenderType”=”Opaque” } 普通shader。再比如Transparent为半透明等等等等</p><h5 id="3-禁用批处理"><a href="#3-禁用批处理" class="headerlink" title="3. 禁用批处理"></a>3. 禁用批处理</h5><p>​    DisableBatching，使用批处理时，几何体可能被变换到世界空间，模型空间被丢弃，这会导致用模型空间顶点坐标的shader出问题。</p><h5 id="等等等等"><a href="#等等等等" class="headerlink" title="等等等等"></a>等等等等</h5><p>​    请看<a href="https://docs.unity3d.com/cn/current/Manual/SL-SubShaderTags.html">https://docs.unity3d.com/cn/current/Manual/SL-SubShaderTags.html</a> 但我觉得很难看懂</p><h4 id="Pass的渲染状况"><a href="#Pass的渲染状况" class="headerlink" title="Pass的渲染状况"></a>Pass的渲染状况</h4><p>​    例如Cull Back 设置多边形背面剔除等等</p><hr><h4 id="Fallback"><a href="#Fallback" class="headerlink" title="Fallback"></a><strong>Fallback</strong></h4><p>​    在所有subShader之后定义，如果所有subshader都无法运行，就运行fallback定义的shader，常见unity内置的diffuse</p><h1 id="顶点-片段着色器基础"><a href="#顶点-片段着色器基础" class="headerlink" title="顶点-片段着色器基础"></a>顶点-片段着色器基础</h1><p>​    unity里shader有俩种用途：1.给材质用于渲染 2.给脚本用于图像处理</p><h2 id="CG语法"><a href="#CG语法" class="headerlink" title="CG语法"></a>CG语法</h2><p>​    unity的shader中，shaderlab只是组织代码结构，真正渲染部分是cg语言编写的。cg程序片段通过指令嵌入在pass中，夹在 CGPROGRAM和 ENDCG之中。</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Pass</span><br><span class="line">       &#123;</span><br><span class="line">           CGPROGRAM</span><br><span class="line">           <span class="meta">#pragma vertex vert//编译指令</span></span><br><span class="line">           <span class="meta">#pragma fragment frag</span></span><br><span class="line">           <span class="comment">//CG_code</span></span><br><span class="line">           ENDCG</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><h3 id="编译指令"><a href="#编译指令" class="headerlink" title="编译指令"></a>编译指令</h3><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#pragma vertex vert//定义顶点着色器名字</span></span><br><span class="line"><span class="meta">#pragma fragment frag//定义片段着色器名字</span></span><br><span class="line"><span class="meta">#pragma target name //定义shader编译的目标级别，默认2.5</span></span><br></pre></td></tr></table></figure><p>​    当然其他还有很多，上网看看吧，用到就知道了</p><h3 id="着色器函数"><a href="#着色器函数" class="headerlink" title="着色器函数"></a>着色器函数</h3><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">struct appdata</span><br><span class="line">        &#123;</span><br><span class="line">            float4 vertex : POSITION; <span class="comment">// vertex position</span></span><br><span class="line">            float2 uv : TEXCOORD0; <span class="comment">// texture coordinate</span></span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// vertex shader outputs (&quot;vertex to fragment&quot;)</span></span><br><span class="line">        struct v2f</span><br><span class="line">        &#123;</span><br><span class="line">            float2 uv : TEXCOORD0; <span class="comment">// texture coordinate</span></span><br><span class="line">            float4 vertex : SV_POSITION; <span class="comment">// clip space position</span></span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// vertex shader</span></span><br><span class="line">        v2f vert (appdata v)</span><br><span class="line">        &#123;</span><br><span class="line">            v2f o;</span><br><span class="line">            o.vertex = UnityObjectToClipPos(v.vertex);</span><br><span class="line">            <span class="comment">//******看解释</span></span><br><span class="line">            o.uv = v.uv;</span><br><span class="line">            <span class="keyword">return</span> o;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">sampler2D</span> _MainTex;</span><br><span class="line"></span><br><span class="line">        fixed4 frag (v2f i) : SV_Target</span><br><span class="line">        &#123;</span><br><span class="line">            fixed4 col = tex2D(_MainTex, i.uv);</span><br><span class="line">            <span class="keyword">return</span> col;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>​    在vert()中，有UnityObjectToClipPos()，这是unity内置空间变换函数，把模型空间坐标转换成裁剪空间坐标，然后输出。</p><h3 id="语义"><a href="#语义" class="headerlink" title="语义"></a><strong>语义</strong></h3><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">### 为什么参数后面有这样一个冒号呢，后面跟着全大写的关键词</span></span><br><span class="line"></span><br><span class="line">fixed4 frag (v2f i) : SV_Target&#123;&#125;</span><br><span class="line"></span><br><span class="line">v2f vert (float4 vertex : POSITION, float3 normal : NORMAL)&#123;&#125;</span><br></pre></td></tr></table></figure><p>用cg编写时，需要参数填充语义来表达要传递的数据信息。</p><h4 id="1-顶点着色器的输入语义"><a href="#1-顶点着色器的输入语义" class="headerlink" title="1. 顶点着色器的输入语义"></a>1. 顶点着色器的输入语义</h4><ol><li><p>​    <strong>POSITION</strong>： 顶点的<strong>坐标信息</strong>     float3/float4</p></li><li><p>​    <strong>NORMAL</strong>：    顶点的<strong>法线信息</strong>    float3</p></li><li><p>​    <strong>TEXCOORD0,TEXCOORD1,TEXCOORD2,TEXCOORD3</strong>：模型的第几套<strong>uv坐标</strong> 通常float2、3、4</p></li><li><p>​    <strong>TANGENT</strong>：    顶点的<strong>切向量</strong>    通常float4</p></li><li><p>​    <strong>COLOR</strong>：    顶点的<strong>颜色坐标</strong>    通常float4</p></li></ol><h4 id="2-顶点着色器的输出-和-片段着色器的输入语义"><a href="#2-顶点着色器的输出-和-片段着色器的输入语义" class="headerlink" title="2. 顶点着色器的输出 和 片段着色器的输入语义"></a>2. 顶点着色器的输出 和 片段着色器的输入语义</h4><p>​    顶点着色器的主要任务就是输出顶点坐标在裁切空间的坐标，这样gpu才知道顶点在屏幕上的栅格化位置和深度值。</p><ol><li><p>​    <strong>SV_POSITION</strong>：    顶点在<strong>裁切空间的坐标</strong>，float4类型。</p></li><li><p>​    <strong>COLOR0,COLOR1</strong>：    低精度数据，例如顶点颜色等</p></li><li><p>​    <strong>TEXCOORD0-7</strong>：    <strong>高精度数据，例如纹理坐标，向量</strong>等</p></li></ol><h4 id="3-片段着色器输出语义"><a href="#3-片段着色器输出语义" class="headerlink" title="3. 片段着色器输出语义"></a>3. 片段着色器输出语义</h4><p>​    只会输出一个fixed4类型的颜色信息，输出的值会存到渲染目标中，因此只有一个<strong>SV_TARGET</strong>语义</p><h3 id="在CG中调用属性变量"><a href="#在CG中调用属性变量" class="headerlink" title="在CG中调用属性变量"></a>在CG中调用属性变量</h3><p>​    如果在properties中定义开放的属性，想要在shader中访问，需要在CG块中再次声明。</p><img src="/2021/11/16/Unity-shader/image-20211117152005645.png" class title="image-20211117152005645"><p>​    <strong>可以看到：</strong></p><ol><li>​    <strong>Float 和 Range 前面加入 float half fixed</strong></li><li>​    <strong>纹理贴图类2D cube 3D 要加入 sampler2D/ samplerCube/ sampler3D</strong></li><li>​    <strong>Color 和 vector    要用half4，或者float4，fixed4，其中颜色最好使用fixed4(节约性能)</strong></li></ol><h4 id="♥在shader中使用纹理贴图"><a href="#♥在shader中使用纹理贴图" class="headerlink" title="♥在shader中使用纹理贴图"></a><strong>♥在shader中使用纹理贴图</strong></h4><p>​    <strong>声明纹理坐标的时候，还要附带声明一个float4 _MainTex_ST，这是Scale &amp; Transform 首字母，表示UV的缩放和平移。</strong></p><p>​    <strong>其中x y代表Tilling的x y值，z w代表Offset的x y值。</strong></p><p><strong>所以纹理坐标的计算公式：texcoord = uv * texturename.xy + texturename.zw ;</strong></p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Properties</span><br><span class="line">   &#123;</span><br><span class="line">       _MainTex (&quot;Albedo (RGB)&quot;, <span class="number">2</span>D) = &quot;white&quot; &#123;&#125;</span><br><span class="line">   &#125;</span><br><span class="line">    SubShader</span><br><span class="line">   &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="type">sampler2D</span> _MainTex;</span><br><span class="line">  float4 _MainTex_ST;<span class="comment">//在cg中定义的平铺偏移变量</span></span><br><span class="line">  ..</span><br><span class="line">  &#125;<span class="comment">//好像写的很复杂，现在好像不需要了</span></span><br></pre></td></tr></table></figure><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对不起我错了，在shader中有一个叫做Unlit Shader，就是按这个语法来写的</span></span><br><span class="line">Shader &quot;Unlit/<span class="number">333</span>&quot;</span><br><span class="line">&#123;</span><br><span class="line">    Properties</span><br><span class="line">    &#123;</span><br><span class="line">        _MainTex (&quot;Texture&quot;, <span class="number">2</span>D) = &quot;white&quot; &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    SubShader</span><br><span class="line">    &#123;</span><br><span class="line">        Tags &#123; &quot;RenderType&quot;=&quot;Opaque&quot; &#125;</span><br><span class="line">        LOD <span class="number">100</span></span><br><span class="line"></span><br><span class="line">        Pass</span><br><span class="line">        &#123;</span><br><span class="line">            CGPROGRAM</span><br><span class="line">            <span class="meta">#pragma vertex vert</span></span><br><span class="line">            <span class="meta">#pragma fragment frag</span></span><br><span class="line">            <span class="comment">// make fog work</span></span><br><span class="line">            <span class="meta">#pragma multi_compile_fog</span></span><br><span class="line"></span><br><span class="line">            <span class="meta">#include &quot;UnityCG.cginc&quot;</span></span><br><span class="line"></span><br><span class="line">            struct appdata</span><br><span class="line">            &#123;</span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                float2 uv : TEXCOORD0;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            struct v2f</span><br><span class="line">            &#123;</span><br><span class="line">                float2 uv : TEXCOORD0;</span><br><span class="line">                UNITY_FOG_COORDS(<span class="number">1</span>)</span><br><span class="line">                float4 vertex : SV_POSITION;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="type">sampler2D</span> _MainTex;</span><br><span class="line">            float4 _MainTex_ST;</span><br><span class="line"></span><br><span class="line">            v2f vert (appdata v)</span><br><span class="line">            &#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                o.vertex = UnityObjectToClipPos(v.vertex);</span><br><span class="line">                o.uv = TRANSFORM_TEX(v.uv, _MainTex);</span><br><span class="line">                UNITY_TRANSFER_FOG(o,o.vertex);</span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            fixed4 frag (v2f i) : SV_Target</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// sample the texture</span></span><br><span class="line">                fixed4 col = tex2D(_MainTex, i.uv);</span><br><span class="line">                <span class="comment">// apply fog</span></span><br><span class="line">                UNITY_APPLY_FOG(i.fogCoord, col);</span><br><span class="line">                <span class="keyword">return</span> col;</span><br><span class="line">            &#125;</span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="在Unity中使用立方体贴图"><a href="#在Unity中使用立方体贴图" class="headerlink" title="在Unity中使用立方体贴图"></a>在Unity中使用立方体贴图</h4><p>​    ……</p><h1 id="Unity包含文件"><a href="#Unity包含文件" class="headerlink" title="Unity包含文件"></a>Unity包含文件</h1><p>在cg代码块中#include即可</p><h2 id="UnityCG-cginc"><a href="#UnityCG-cginc" class="headerlink" title="UnityCG.cginc"></a>UnityCG.cginc</h2><h3 id="顶点着色器输入结构体"><a href="#顶点着色器输入结构体" class="headerlink" title="顶点着色器输入结构体"></a>顶点着色器输入结构体</h3><p>​    appdata_base     顶点坐标，顶点法线，第一组纹理坐标<br>​    appdata_tan        顶点坐标，顶点切线，顶点法线，第一组纹理坐标<br>​    appdata_full        顶点坐标，顶点切线，顶点法线，四组（或更多）纹理坐标<br>​    appdata_img       顶点坐标，第一组纹理坐标<br>​    v2f_img：             裁剪空间中的位置，纹理坐标</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">struct appdata_base &#123;</span><br><span class="line">    float4 vertex : POSITION;</span><br><span class="line">    float3 normal : NORMAL;</span><br><span class="line">    float4 texcoord : TEXCOORD0;</span><br><span class="line">    UNITY_VERTEX_INPUT_INSTANCE_ID</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct appdata_tan &#123;</span><br><span class="line">    float4 vertex : POSITION;</span><br><span class="line">    float4 tangent : TANGENT;</span><br><span class="line">    float3 normal : NORMAL;</span><br><span class="line">    float4 texcoord : TEXCOORD0;</span><br><span class="line">    UNITY_VERTEX_INPUT_INSTANCE_ID</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct appdata_full &#123;</span><br><span class="line">    float4 vertex : POSITION;</span><br><span class="line">    float4 tangent : TANGENT;</span><br><span class="line">    float3 normal : NORMAL;</span><br><span class="line">    float4 texcoord : TEXCOORD0;</span><br><span class="line">    float4 texcoord1 : TEXCOORD1;</span><br><span class="line">    float4 texcoord2 : TEXCOORD2;</span><br><span class="line">    float4 texcoord3 : TEXCOORD3;</span><br><span class="line">    fixed4 color : COLOR;</span><br><span class="line">    UNITY_VERTEX_INPUT_INSTANCE_ID</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct appdata_img</span><br><span class="line">&#123;</span><br><span class="line">    float4 vertex : POSITION;</span><br><span class="line">    half2 texcoord : TEXCOORD0;</span><br><span class="line">    UNITY_VERTEX_INPUT_INSTANCE_ID</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct v2f_img</span><br><span class="line">&#123;</span><br><span class="line">    float4 pos : SV_POSITION;</span><br><span class="line">    half2 uv : TEXCOORD0;</span><br><span class="line">    UNITY_VERTEX_INPUT_INSTANCE_ID</span><br><span class="line">    UNITY_VERTEX_OUTPUT_STEREO</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="各种帮助函数"><a href="#各种帮助函数" class="headerlink" title="各种帮助函数"></a>各种帮助函数</h3><h4 id="1-顶点变换函数"><a href="#1-顶点变换函数" class="headerlink" title="1. 顶点变换函数"></a>1. 顶点变换函数</h4><ol><li> float4 WorldSpaceViewDir(float4 v)            输入一个模型空间中的顶点位置，返回世界空间中从该点到摄像机的观察方向</li><li> float4 UnityWorldSpaceViewDir(float4 v)            输入一个世界空间中的顶点位置，返回世界空间中从该点到摄像机的观察方向</li><li> float4 ObjSpaceViewDir(float4 v)            输入一个模型空间中的顶点位置，返回模型空间中从该店到摄像机的观察方向</li></ol><h4 id="2-灯光辅助函数"><a href="#2-灯光辅助函数" class="headerlink" title="2. 灯光辅助函数"></a>2. 灯光辅助函数</h4><ol><li> float4 WorldSpace LightDir(flaot4 v)            仅用于向前渲染。 输入一个模型空间中的顶点位置，返回世界空间中从该点到光源的光照方向。没有被归一化​</li><li> float4 ObjectSpaceLightDir(float4 v)            仅用于向前渲染中，输入一个模型空间中的顶点位置， 返回模型空间中从该点到光源的光照方向。没有被归一化</li><li> float4 UnityWorldSpaceLightDir(float4 v)            仅用于向前渲染中，输入一个世界空间中的顶点位置， 返回世界空间中从该点到光源的光照方向。没有被归一化</li></ol><h4 id="3-向量变换函数"><a href="#3-向量变换函数" class="headerlink" title="3. 向量变换函数"></a>3. 向量变换函数</h4><ol><li> float3 UnityObjectToWorldNormal(float3 norm)            把法线方向从模型空间中转换到世界空间中</li><li> float3 UnityObjectToWorldDir(float3 dir)            把方向矢量从模型空间中变换到世界空间中</li><li> float3 Unity WorldToObjectDir(float3 dir)            把方向矢量从世界空间变换到模型空间中</li></ol><h2 id="UnityShaderVariable-cginc"><a href="#UnityShaderVariable-cginc" class="headerlink" title="UnityShaderVariable.cginc"></a>UnityShaderVariable.cginc</h2><p>…….随便都可以</p><p>[TOC]</p>]]></content>
      
      
      
        <tags>
            
            <tag> Unity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【OpenGL】临时笔记</title>
      <link href="/2021/11/12/OpenGL-%E4%B8%B4%E6%97%B6%E7%AC%94-%E9%94%AE%E7%9B%98-%E8%AE%B0/"/>
      <url>/2021/11/12/OpenGL-%E4%B8%B4%E6%97%B6%E7%AC%94-%E9%94%AE%E7%9B%98-%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h5 id="1-清除缓冲区"><a href="#1-清除缓冲区" class="headerlink" title="1.清除缓冲区"></a>1.清除缓冲区</h5><p>glClearColor (0.0, 0.0, 0.0, 0.0);<br>glClearDepth(1.0);<br>glClear (GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT));</p><h5 id="2-glFlush"><a href="#2-glFlush" class="headerlink" title="2.glFlush();"></a>2.glFlush();</h5><p>强制客户机发送网络数据包，以免网络传输时，包没填满一直等待。<br>glFinish();强制之前的命令完成执行，执行完了才返回。</p><h5 id="3-reshape-int-w-int-h-回调函数"><a href="#3-reshape-int-w-int-h-回调函数" class="headerlink" title="3.reshape(int w,int h)回调函数"></a>3.reshape(int w,int h)回调函数</h5><p>void reshape (int w, int h)<br>{<br>   glViewport (0, 0, (GLsizei) w, (GLsizei) h); //调整整个像素矩形使其填满新窗口<br>   glMatrixMode (GL_PROJECTION);<br>   glLoadIdentity ();<br> //  gluPerspective(60.0, (GLfloat) w/(GLfloat) h, 1.0, 20.0);<br> //  glMatrixMode(GL_MODELVIEW);<br> //  glLoadIdentity();<br> //  gluLookAt (0.0, 0.0, 5.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0);<br>    gluOrtho2D(0.0,(GLdouble)w,0.0,(GLdouble)h);//使左下角0，0，右上角是w，h<br>}</p><h5 id="4-opengl的多边形边不能相交，必须是凸多边形-P25"><a href="#4-opengl的多边形边不能相交，必须是凸多边形-P25" class="headerlink" title="4.opengl的多边形边不能相交，必须是凸多边形//P25"></a>4.opengl的多边形边不能相交，必须是凸多边形//P25</h5><h5 id="5-指定顶点用glVertex（）-P27"><a href="#5-指定顶点用glVertex（）-P27" class="headerlink" title="5.指定顶点用glVertex（）//P27"></a>5.指定顶点用glVertex（）//P27</h5><h5 id="6-根据给定的顶点，用图元表示绘制的图形"><a href="#6-根据给定的顶点，用图元表示绘制的图形" class="headerlink" title="6.根据给定的顶点，用图元表示绘制的图形"></a>6.根据给定的顶点，用图元表示绘制的图形</h5><p>glBegin(图元名字);<br>    glVertex2f(0.0,0.0);<br>    ……..<br>    glVertex2f(4.0,4.0);<br>glEnd();<br>各类图元请看p29 当然begin和end之间还可以放glColor之类的；</p><h5 id="7-glEnable-打开功能-glIsEnabled-检测，返回GL-TURE"><a href="#7-glEnable-打开功能-glIsEnabled-检测，返回GL-TURE" class="headerlink" title="7.glEnable();打开功能 glIsEnabled();检测，返回GL_TURE"></a>7.glEnable();打开功能 glIsEnabled();检测，返回GL_TURE</h5><h5 id="8-glLineStipple-GLint-factor，Glushort-patern-画线！P34-2-5lines"><a href="#8-glLineStipple-GLint-factor，Glushort-patern-画线！P34-2-5lines" class="headerlink" title="8.glLineStipple(GLint factor，Glushort patern)画线！P34 2_5lines"></a>8.glLineStipple(GLint factor，Glushort patern)画线！P34 2_5lines</h5><p>例：<br> glEnable (GL_LINE_STIPPLE);</p><p>glLineStipple (1, 0x0101);  /*  dotted  <em>/<br>drawOneLine (50.0, 125.0, 150.0, 125.0);<br>glLineStipple (1, 0x00FF);  /</em>  dashed  <em>/<br>drawOneLine (150.0, 125.0, 250.0, 125.0);<br>glLineStipple (1, 0x1C47);  /</em>  dash/dot/dash  */<br>drawOneLine (250.0, 125.0, 350.0, 125.0);</p><h5 id="9-glPolygonMode-GL-FRONT-AND-BACK-GL-FRONT-GL-BACK-GL-FILL-GL-LINE-GL-POINT"><a href="#9-glPolygonMode-GL-FRONT-AND-BACK-GL-FRONT-GL-BACK-GL-FILL-GL-LINE-GL-POINT" class="headerlink" title="9.glPolygonMode(GL_FRONT_AND_BACK/GL_FRONT/GL_BACK , GL_FILL/GL_LINE/GL_POINT);"></a>9.glPolygonMode(GL_FRONT_AND_BACK/GL_FRONT/GL_BACK , GL_FILL/GL_LINE/GL_POINT);</h5><p>对多边形的不同面进行不同的渲染（gl3.1以上不能不同</p><h5 id="10-glPolygonStipple-32-32位的指针"><a href="#10-glPolygonStipple-32-32位的指针" class="headerlink" title="10.glPolygonStipple(32*32位的指针)"></a>10.glPolygonStipple(32*32位的指针)</h5><p>多边形的点画模式，每位的8格，为1就绘制，依次组成画（挺无聊的</p><h5 id="11-法线向量"><a href="#11-法线向量" class="headerlink" title="11. 法线向量"></a>11. 法线向量</h5><p>简称法线？！ 是一条垂直于某个表面的方向向量，在曲面上每个点的法线不同。定义了 表面在空间的方向，计算光照很有用。</p><p>用glNormal(给的那个向量)定义，和glVertex()一样，用在begin和end之间。</p><h5 id="12-顶点数组"><a href="#12-顶点数组" class="headerlink" title="12.顶点数组"></a>12.顶点数组</h5><p>用少量数组指定大量与顶点相关的数据</p><h6 id="1-启用数组-glEnableClientState-GL-VERTEX-ARRAY-…-p44"><a href="#1-启用数组-glEnableClientState-GL-VERTEX-ARRAY-…-p44" class="headerlink" title="1.启用数组 glEnableClientState(GL_VERTEX_ARRAY/…)p44"></a>1.启用数组 glEnableClientState(GL_VERTEX_ARRAY/…)p44</h6><p>glDisableClientState();</p><h6 id="2-指定数组的数据-glVertexPointer"><a href="#2-指定数组的数据-glVertexPointer" class="headerlink" title="2.指定数组的数据 glVertexPointer(//////)"></a>2.指定数组的数据 glVertexPointer(//////)</h6><p>跨距stride</p><h6 id="3-解引用和渲染-glArrayElement（int-ith）"><a href="#3-解引用和渲染-glArrayElement（int-ith）" class="headerlink" title="3.解引用和渲染 glArrayElement（int ith）"></a>3.解引用和渲染 glArrayElement（int ith）</h6><p>glDrawElement（）</p><h5 id="13-重启图元-glPrimitiveRestartIndex"><a href="#13-重启图元-glPrimitiveRestartIndex" class="headerlink" title="13.重启图元 glPrimitiveRestartIndex()???"></a>13.重启图元 glPrimitiveRestartIndex()???</h5><p>p51 (因为后面太恶心直接跳到第三章去)</p><h4 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h4><h5 id="14-视图变换"><a href="#14-视图变换" class="headerlink" title="14.视图变换"></a>14.视图变换</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   glClear (GL_COLOR_BUFFER_BIT);</span><br><span class="line">   glColor3f (<span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>);</span><br><span class="line">   glLoadIdentity ();             <span class="comment">/* clear the matrix */</span><span class="comment">//如果不设为单位，会与之前的矩阵相乘</span></span><br><span class="line">           <span class="comment">/* viewing transformation  */</span></span><br><span class="line">   gluLookAt (<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">5.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">0.0</span>);<span class="comment">//eye target up</span></span><br><span class="line">    <span class="comment">//默认是原点 z负 up-y正</span></span><br><span class="line">   glScalef (<span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">1.0</span>);      <span class="comment">/* modeling transformation */</span> </span><br><span class="line">   glutWireCube (<span class="number">1.0</span>);</span><br><span class="line">   glFlush ();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="15-对变换进行思考"><a href="#15-对变换进行思考" class="headerlink" title="15.对变换进行思考"></a>15.对变换进行思考</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">glMatrixMode(GL_MODELVIEW);</span><br><span class="line">glLoadIdentity();</span><br><span class="line">glMultMatrixf(N);</span><br><span class="line">glMultMatrixf(M);</span><br><span class="line">glMultMatrixf(L);</span><br><span class="line">glBegin(GL_POINTS);</span><br><span class="line">glVertex3f(V);<span class="comment">// 顶点变换是N(M(Lv)) 也就是v先于L相乘，再与M，再与N</span></span><br><span class="line">glEnd();<span class="comment">//顶点v的变换是相反的顺序进行的！</span></span><br></pre></td></tr></table></figure><h6 id="如果根据全局固定的坐标系统"><a href="#如果根据全局固定的坐标系统" class="headerlink" title="如果根据全局固定的坐标系统"></a>如果根据全局固定的坐标系统</h6><p>那必须注意乘法的顺序与出现的顺序相反</p><h6 id="反之，我们就要考虑局部移动坐标系统"><a href="#反之，我们就要考虑局部移动坐标系统" class="headerlink" title="反之，我们就要考虑局部移动坐标系统"></a>反之，我们就要考虑局部移动坐标系统</h6><p>想象一个固定到所绘制物体的局部坐标系统，所有操作都相对于这个不断变化的坐标系统进行。</p>]]></content>
      
      
      
        <tags>
            
            <tag> OpenGL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【OpenGL】VAO,VBO,IBO知识</title>
      <link href="/2021/11/12/OpenGL-1/"/>
      <url>/2021/11/12/OpenGL-1/</url>
      
        <content type="html"><![CDATA[<ul><li>顶点数组对象：Vertex Array Object，VAO</li><li>顶点缓冲对象：Vertex Buffer Object，VBO</li><li>索引缓冲对象：Element Buffer Object，EBO或Index Buffer Object，IBO</li></ul><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>3D坐标转为2D坐标的处理过程是由OpenGL的图形渲染管线（Graphics Pipeline，大多译为管线，实际上指的是一堆原始图形数据途经一个输送管道，期间经过各种变化处理最终出现在屏幕的过程）管理的。图形渲染管线可以被划分为两个主要部分：第一部分把你的3D坐标转换为2D坐标，第二部分是把2D坐标转变为实际的有颜色的像素。</p><p>图形渲染管线接受一组3D坐标，然后把它们转变为你屏幕上的有色2D像素输出。图形渲染管线可以被划分为几个阶段，每个阶段将会把前一个阶段的输出作为输入。所有这些阶段都是高度专门化的（它们都有一个特定的函数），并且很容易并行执行。正是由于它们具有并行执行的特性，当今大多数显卡都有成千上万的小处理核心，它们在GPU上为每一个（渲染管线）阶段运行各自的小程序，从而在图形渲染管线中快速处理你的数据。这些小程序叫做着色器(Shader)。</p><p>有些着色器允许开发者自己配置，这就允许我们用自己写的着色器来替换默认的。这样我们就可以更细致地控制图形渲染管线中的特定部分了，而且因为它们运行在GPU上，所以它们可以给我们节约宝贵的CPU时间。</p><p>图形渲染管线的每个阶段的抽象展示。要注意蓝色部分代表的是我们可以注入自定义的着色器的部分。<img src="/2021/11/12/OpenGL-1/pipeline.png" class title="img"></p><h4 id="详细解读"><a href="#详细解读" class="headerlink" title="详细解读"></a>详细解读</h4><h5 id="1"><a href="#1" class="headerlink" title="1."></a>1.</h5><p>首先，我们以数组的形式传递3个3D坐标作为图形渲染管线的输入，用来表示一个三角形，这个数组叫做顶点数据(Vertex Data)；假定每个顶点只由一个3D位置和一些颜色值组成的吧。</p><h5 id="2"><a href="#2" class="headerlink" title="2."></a>2.</h5><p>图形渲染管线的第一个部分是顶点着色器(Vertex Shader)，它把一个单独的顶点作为输入。顶点着色器主要的目的是把3D坐标转为另一种3D坐标（后面会解释），同时顶点着色器允许我们对顶点属性进行一些基本处理。</p><h5 id="3"><a href="#3" class="headerlink" title="3."></a>3.</h5><p>图元装配(Primitive Assembly)阶段将顶点着色器输出的所有顶点作为输入（如果是GL_POINTS，那么就是一个顶点），并所有的点装配成指定图元的形状；本节例子中是一个三角形。</p><h5 id="4"><a href="#4" class="headerlink" title="4."></a>4.</h5><p>图元装配阶段的输出会传递给几何着色器(Geometry Shader)。几何着色器把图元形式的一系列顶点的集合作为输入，它可以通过产生新顶点构造出新的（或是其它的）图元来生成其他形状。例子中，它生成了另一个三角形。</p><h5 id="5"><a href="#5" class="headerlink" title="5."></a>5.</h5><p>几何着色器的输出会被传入光栅化阶段(Rasterization Stage)，这里它会把图元映射为最终屏幕上相应的像素，生成供片段着色器(Fragment Shader)使用的片段(Fragment)。在片段着色器运行之前会执行裁切(Clipping)。裁切会丢弃超出你的视图以外的所有像素，用来提升执行效率。</p><p>“OpenGL中的一个片段是OpenGL渲染一个像素所需的所有数据。”</p><h5 id="6"><a href="#6" class="headerlink" title="6."></a>6.</h5><p>片段着色器的主要目的是计算一个像素的最终颜色，这也是所有OpenGL高级效果产生的地方。通常，片段着色器包含3D场景的数据（比如光照、阴影、光的颜色等等），这些数据可以被用来计算最终像素的颜色。</p><h5 id="7"><a href="#7" class="headerlink" title="7."></a>7.</h5><p>在所有对应颜色值确定以后，最终的对象将会被传到最后一个阶段，我们叫做Alpha测试和混合(Blending)阶段。这个阶段检测片段的对应的深度（和模板(Stencil)）值（后面会讲），用它们来判断这个像素是其它物体的前面还是后面，决定是否应该丢弃。这个阶段也会检查alpha值（alpha值定义了一个物体的透明度）并对物体进行混合(Blend)。所以，即使在片段着色器中计算出来了一个像素输出的颜色，在渲染多个三角形的时候最后的像素颜色也可能完全不同。</p><p>对于大多数场合，我们只需要配置顶点和片段着色器就行了。几何着色器是可选的，通常使用它默认的着色器就行了。</p><p>在现代OpenGL中，我们<strong>必须</strong>定义至少一个顶点着色器和一个片段着色器（因为GPU中没有默认的顶点/片段着色器）。</p><h3 id="正式实践"><a href="#正式实践" class="headerlink" title="正式实践"></a>正式实践</h3><h4 id="1-指定顶点"><a href="#1-指定顶点" class="headerlink" title="1.指定顶点"></a>1.指定顶点</h4><p>由于我们希望渲染一个三角形，我们一共要指定三个顶点，每个顶点都有一个3D位置。我们会将它们以标准化设备坐标的形式（OpenGL的可见区域）定义为一个<code>float</code>数组。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> vertices[] = &#123;</span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,</span><br><span class="line">     <span class="number">0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,</span><br><span class="line">     <span class="number">0.0f</span>,  <span class="number">0.5f</span>, <span class="number">0.0f</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="2-vertex-shader-顶点着色器"><a href="#2-vertex-shader-顶点着色器" class="headerlink" title="2.vertex shader 顶点着色器"></a>2.vertex shader 顶点着色器</h4>]]></content>
      
      
      
        <tags>
            
            <tag> OpenGL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Unity物理模拟】布料模拟</title>
      <link href="/2021/11/07/%E5%B8%83%E6%96%99%E6%A8%A1%E6%8B%9F/"/>
      <url>/2021/11/07/%E5%B8%83%E6%96%99%E6%A8%A1%E6%8B%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>​    布料模拟的本质，其实就是对于组成目标布料的每一个粒子（Particle）节点进行相互之间的约束，以节点的位置移动来模拟物理。</p><p>​    拿最常用的基于物理方法的质点-弹簧模型（Mass-Spring Model）来举例。实际上就是在每一个节点与其他节点之间进行一个物理的控制，增加了弹性约束，外力约束和重力约束。众多的小节点之间实现了这些力的约束，最后组合成一张布也就能较为真实地模拟真实世界中布料的特性。</p><p>​    这些物理模拟之间存在大量的耦合，比如物体受重力的同时又受到来自另一个粒子的弹性约束，两者之间是互相影响的。但对于游戏模拟而言，保证足够的可信度即可，可以容忍些许的精度缺失。所以采用松弛法(Relaxation)迭代，即每个方法独立结算，通过多次迭代达到较高精度。</p><p>​    而在unity中的布料模拟，其实就是对布料mesh进行的各顶点计算物理仿真。</p><p>​    unity中的mesh由众多三角面片构成，每个三角面片的顶点是有重复的。而我们要做的就是对这些顶点加重力，在顶点与顶点之间加一个约束力，在对其加一个碰撞的力，这样子布料模拟就完成了。</p><h1 id="质点-弹簧模型（Mass-Spring-Model）"><a href="#质点-弹簧模型（Mass-Spring-Model）" class="headerlink" title="质点-弹簧模型（Mass-Spring Model）"></a>质点-弹簧模型（Mass-Spring Model）</h1><img src="/2021/11/07/%E5%B8%83%E6%96%99%E6%A8%A1%E6%8B%9F/image-20211128153524685.png" class title="image-20211128153524685"><p>质点弹簧模型是将质点用弹簧连接，发生位移时，每个质点都受到弹性约束。概括讲就是：</p><p>·     所有的节点都是一个质点</p><p>·     节点之间的连线就是一个弹簧</p><p>·     节点之间的受力通过经典力学公式计算</p><p>·     弹簧受力通过胡可定律计算</p><p>三种弹簧分别对应结构力（拉力、压力）、剪切力、弯曲力的结算。</p><h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>​    最简单的质点弹簧模型就是俩个互相约束的点，可以考虑成一个弹簧。根据牛顿力学定律，力的作用是相互的，当我们一边的质点移动，就会带动弹簧拉伸，而拉伸之后的弹簧就会产生一个“还原”的力，使另一边的质点受到弹簧向左拉的力。</p><p>这里会用到：</p><h3 id="1-胡克定律"><a href="#1-胡克定律" class="headerlink" title="1.胡克定律"></a>1.胡克定律</h3><p>​    其力的大小与弹簧伸长量或收缩量线性成正比。</p><img src="/2021/11/07/%E5%B8%83%E6%96%99%E6%A8%A1%E6%8B%9F/clip_image001.png" class title="img"><h3 id="2-欧拉积分"><a href="#2-欧拉积分" class="headerlink" title="2.欧拉积分"></a>2.欧拉积分</h3><p>​    欧拉积分其实分为隐式欧拉和显式欧拉，为了简单开发，这里使用显式欧拉方法进行积分。欧式积分，其实可以看成我们假定在一个规定的时间，物体的速度是一致的。那么在这个一致速度的时间范围内，我们就能很好去求解质点下一刻的状态。</p><img src="/2021/11/07/%E5%B8%83%E6%96%99%E6%A8%A1%E6%8B%9F/clip_image002.png" class title="img"><h3 id="3-Verlet-积分"><a href="#3-Verlet-积分" class="headerlink" title="3.Verlet 积分"></a>3.Verlet 积分</h3><p>​    Verlet积分会使用上一个时刻的状态来推下一个时刻的状态。</p><img src="/2021/11/07/%E5%B8%83%E6%96%99%E6%A8%A1%E6%8B%9F/clip_image003.png" class title="img"><h2 id="具体实现："><a href="#具体实现：" class="headerlink" title="具体实现："></a>具体实现：</h2><p>1.ClothNode.cs </p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ClothNode</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> mass = <span class="number">1f</span>;<span class="comment">//质点的质量</span></span><br><span class="line">    <span class="keyword">public</span> Vector3 v;<span class="comment">//质点的速度</span></span><br><span class="line">    <span class="comment">// Start is called before the first frame update</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> dt = <span class="number">0.007f</span>;<span class="comment">//144帧，每帧用时7ms</span></span><br><span class="line">    <span class="comment">// Update is called once per frame</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        transform.position += v * dt;<span class="comment">//速度产生的位移</span></span><br><span class="line">        v *= <span class="number">0.99f</span>;<span class="comment">//空气阻力会使速度减小</span></span><br><span class="line">        AddForce(<span class="keyword">new</span> Vector3(<span class="number">0</span>, <span class="number">-9.8f</span>, <span class="number">0</span>));<span class="comment">//重力。</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">AddForce</span>(<span class="params">Vector3 force</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (mass &gt; <span class="number">100</span>) <span class="keyword">return</span>;<span class="comment">//若质量大于某一值，不作受力计算直接返回，用于固定的点。</span></span><br><span class="line">        Vector3 a = force / mass;<span class="comment">//此力作用于当前质点上产生的加速度</span></span><br><span class="line">        v += a * dt;<span class="comment">//加速度对质点速度的作用：用来加速度</span></span><br><span class="line">        transform.position += <span class="number">0.5f</span> * a * dt * dt;<span class="comment">//加速度产生的位移</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>2.ClothNodeAll.cs</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ClothNodeAll</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> GameObject node;<span class="comment">//质点的预设体</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> boundLength, height;<span class="comment">//布料的底边长和高</span></span><br><span class="line"></span><br><span class="line">    List&lt;GameObject&gt; nodes;<span class="comment">//质点的List</span></span><br><span class="line">    List&lt;Spring&gt; springs;<span class="comment">//弹簧的List</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">float</span> structK, shearK, bendK,<span class="comment">//分别是结构弹簧、剪切弹簧、弯曲弹簧的参数</span></span><br><span class="line">          structL, shearL, bendL;</span><br><span class="line">    <span class="comment">// Start is called before the first frame update</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        structL = <span class="number">1f</span>; shearL = Mathf.Sqrt(<span class="number">2f</span>); bendL = <span class="number">2f</span>;</span><br><span class="line">        structK = <span class="number">1000f</span>; shearK = <span class="number">500f</span>; bendK = <span class="number">1000f</span>;</span><br><span class="line"></span><br><span class="line">        nodes = <span class="keyword">new</span> List&lt;GameObject&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 生成质点们</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; boundLength; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> j = <span class="number">0</span>; j &lt; height; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                GameObject o = Instantiate(node, transform);</span><br><span class="line">                o.transform.position = <span class="keyword">new</span> Vector3(i, j, <span class="number">0</span>);<span class="comment">//初始位置随便设</span></span><br><span class="line">                nodes.Add(o);</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="comment">//设置固定的质点，用其质量来区分</span></span><br><span class="line">        nodes[<span class="number">0</span>].GetComponent&lt;ClothNode&gt;().mass = <span class="number">100000f</span>;</span><br><span class="line">        nodes[boundLength - <span class="number">1</span>].GetComponent&lt;ClothNode&gt;().mass = <span class="number">100000f</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 构建弹簧们</span></span><br><span class="line">        springs = <span class="keyword">new</span> List&lt;Spring&gt;();</span><br><span class="line">        <span class="comment">//结构弹簧</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; boundLength - <span class="number">1</span>; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> j = <span class="number">0</span>; j &lt; height; j++)</span><br><span class="line">                springs.Add(<span class="keyword">new</span> Spring(</span><br><span class="line">                    nodes[j * boundLength + i],</span><br><span class="line">                    nodes[j * boundLength + i + <span class="number">1</span>],</span><br><span class="line">                    structK,</span><br><span class="line">                    structL));</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; boundLength; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> j = <span class="number">0</span>; j &lt; height - <span class="number">1</span>; j++)</span><br><span class="line">                springs.Add(<span class="keyword">new</span> Spring(</span><br><span class="line">                    nodes[j * boundLength + i],</span><br><span class="line">                    nodes[(j + <span class="number">1</span>) * boundLength + i],</span><br><span class="line">                    structK,</span><br><span class="line">                    structL));</span><br><span class="line">        <span class="comment">//剪切弹簧</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; boundLength - <span class="number">1</span>; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> j = <span class="number">0</span>; j &lt; height - <span class="number">1</span>; j++)</span><br><span class="line">                springs.Add(<span class="keyword">new</span> Spring(</span><br><span class="line">                    nodes[i * height + j],</span><br><span class="line">                    nodes[(i + <span class="number">1</span>) * height + j + <span class="number">1</span>],</span><br><span class="line">                    shearK,</span><br><span class="line">                    shearL));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">1</span>; i &lt; boundLength; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> j = <span class="number">0</span>; j &lt; height - <span class="number">1</span>; j++)</span><br><span class="line">                springs.Add(<span class="keyword">new</span> Spring(</span><br><span class="line">                    nodes[i * height + j],</span><br><span class="line">                    nodes[(i - <span class="number">1</span>) * height + j + <span class="number">1</span>],</span><br><span class="line">                    shearK,</span><br><span class="line">                    shearL));</span><br><span class="line">        <span class="comment">//弯曲弹簧</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; boundLength - <span class="number">2</span>; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> j = <span class="number">0</span>; j &lt; height; j++)</span><br><span class="line">                springs.Add(<span class="keyword">new</span> Spring(</span><br><span class="line">                    nodes[j * boundLength + i],</span><br><span class="line">                    nodes[j * boundLength + i + <span class="number">2</span>],</span><br><span class="line">                    bendK,</span><br><span class="line">                    bendL));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; boundLength; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> j = <span class="number">0</span>; j &lt; height - <span class="number">2</span>; j++)</span><br><span class="line">                springs.Add(<span class="keyword">new</span> Spring(</span><br><span class="line">                    nodes[j * boundLength + i],</span><br><span class="line">                    nodes[(j + <span class="number">2</span>) * boundLength + i],</span><br><span class="line">                    bendK,</span><br><span class="line">                    bendL));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Update is called once per frame</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">foreach</span> (Spring s <span class="keyword">in</span> springs) s.Flex();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>3.Spring.cs</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Spring</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> Transform nodeA, nodeB;<span class="comment">//链接的两个质点的Transform</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> k, L;<span class="comment">//劲度系数，自然长度</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Spring</span>(<span class="params">GameObject a, GameObject b, <span class="built_in">float</span> k, <span class="built_in">float</span> L</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        nodeA = a.transform;</span><br><span class="line">        nodeB = b.transform;</span><br><span class="line">        <span class="keyword">this</span>.k = k;</span><br><span class="line">        <span class="keyword">this</span>.L = L;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Flex</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Vector3 dAB = nodeB.transform.position - nodeA.transform.position;<span class="comment">//由A指向B的向量</span></span><br><span class="line">        <span class="built_in">float</span> scalarF = k * (dAB.magnitude - L);<span class="comment">//产生的力的大小</span></span><br><span class="line">                                                <span class="comment">//对两个质点进行弹力的添加</span></span><br><span class="line">        nodeA.GetComponent&lt;ClothNode&gt;().AddForce(dAB.normalized * scalarF);</span><br><span class="line">        nodeB.GetComponent&lt;ClothNode&gt;().AddForce(-dAB.normalized * scalarF);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2021/11/07/%E5%B8%83%E6%96%99%E6%A8%A1%E6%8B%9F/image-20211128155615939.png" class title="image-20211128155615939"><h2 id="在Unity里的布料具体实现"><a href="#在Unity里的布料具体实现" class="headerlink" title="在Unity里的布料具体实现"></a>在Unity里的布料具体实现</h2><h3 id="方法一：抽象到点"><a href="#方法一：抽象到点" class="headerlink" title="方法一：抽象到点"></a>方法一：抽象到点</h3><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Zhascript</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    List&lt;Point&gt; pointList;</span><br><span class="line">    List&lt;Spring&gt; springList;</span><br><span class="line">    <span class="built_in">float</span> k;<span class="comment">//弹簧的参数</span></span><br><span class="line">    <span class="keyword">public</span> Transform collderobj;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> raduils;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Mesh mesh;</span><br><span class="line">    Mesh mesh_me;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        k = <span class="number">1000f</span>;</span><br><span class="line">        <span class="comment">// mesh = GetComponent&lt;MeshFilter&gt;().mesh;</span></span><br><span class="line"></span><br><span class="line">        mesh_me = <span class="keyword">new</span> Mesh();           <span class="comment">//进行mesh的给定</span></span><br><span class="line">        mesh_me.vertices = mesh.vertices;   <span class="comment">//mesh 的每个顶点</span></span><br><span class="line">        mesh_me.triangles = mesh.triangles;</span><br><span class="line">        mesh_me.uv = mesh.uv;</span><br><span class="line">        mesh_me.tangents = mesh.tangents;</span><br><span class="line">        mesh_me.normals = mesh.normals;</span><br><span class="line">        GetComponent&lt;MeshFilter&gt;().mesh = mesh_me;  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        pointList = <span class="keyword">new</span> List&lt;Point&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; mesh.vertices.Length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            </span><br><span class="line"></span><br><span class="line">                Point newp = <span class="keyword">new</span> Point();</span><br><span class="line">                newp.pos = mesh.vertices[i];</span><br><span class="line">                pointList.Add(newp);</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        springList = <span class="keyword">new</span> List&lt;Spring&gt;();</span><br><span class="line">        <span class="built_in">int</span>[] triangleList = mesh_me.triangles;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; triangleList.Length; i += <span class="number">3</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Spring sp1 = <span class="keyword">new</span> Spring(pointList[triangleList[i]],</span><br><span class="line">                                    pointList[triangleList[i + <span class="number">1</span>]],</span><br><span class="line">                                    Vector3.Distance(pointList[triangleList[i]].pos, pointList[triangleList[i + <span class="number">1</span>]].pos),</span><br><span class="line">                                    k);</span><br><span class="line">            Spring sp2 = <span class="keyword">new</span> Spring(pointList[triangleList[i]],</span><br><span class="line">                                    pointList[triangleList[i + <span class="number">2</span>]],</span><br><span class="line">                                    Vector3.Distance(pointList[triangleList[i]].pos, pointList[triangleList[i + <span class="number">2</span>]].pos),</span><br><span class="line">                                    k);</span><br><span class="line">            Spring sp3 = <span class="keyword">new</span> Spring(pointList[triangleList[i + <span class="number">2</span>]],</span><br><span class="line">                                    pointList[triangleList[i + <span class="number">1</span>]],</span><br><span class="line">                                    Vector3.Distance(pointList[triangleList[i + <span class="number">2</span>]].pos, pointList[triangleList[i + <span class="number">1</span>]].pos),</span><br><span class="line">                                    k);</span><br><span class="line">            springList.Add(sp1);</span><br><span class="line">            springList.Add(sp2);</span><br><span class="line">            springList.Add(sp3);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Update is called once per frame</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">foreach</span> (Spring s <span class="keyword">in</span> springList)</span><br><span class="line">        &#123;</span><br><span class="line">            s.flex();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">foreach</span> (Point p <span class="keyword">in</span> pointList)</span><br><span class="line">        &#123;</span><br><span class="line">            p.update();</span><br><span class="line">            p.Update_collide(collderobj.position - transform.position, raduils);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        mesh_me.vertices = Point.Tov3(pointList);  <span class="comment">//返回点的位置</span></span><br><span class="line">        mesh_me.RecalculateNormals();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Point</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> Vector3 pos;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> mass = <span class="number">1f</span>;</span><br><span class="line">    <span class="comment">//public float velocity;//速度</span></span><br><span class="line">    <span class="keyword">public</span> Vector3 velocity;<span class="comment">//速度</span></span><br><span class="line">    <span class="comment">//public float a;//加速度</span></span><br><span class="line">    <span class="keyword">public</span> Vector3 a;<span class="comment">//加速度</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">List</span>&lt;<span class="title">Vector3</span>&gt; posMaybe</span> = <span class="keyword">new</span> List&lt;Vector3&gt;();<span class="comment">//存可能的值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> dt = <span class="number">0.007f</span>;<span class="comment">//144帧，每帧用时7mscop</span></span><br><span class="line">    <span class="keyword">public</span> Vector3 gravity = <span class="keyword">new</span> Vector3(<span class="number">0</span>, <span class="number">-9.8f</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Vector3 allpos = Vector3.zero;<span class="comment">//这里进行posmaybe里面的值的平均</span></span><br><span class="line">        <span class="keyword">foreach</span> (Vector3 p <span class="keyword">in</span> posMaybe)</span><br><span class="line">        &#123;</span><br><span class="line">            allpos += p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//allpos = allpos / posMaybe.Count;</span></span><br><span class="line">        <span class="comment">//velocity = (pos - allpos) / dt + velocity;</span></span><br><span class="line">        <span class="comment">//pos = allpos;</span></span><br><span class="line">        <span class="keyword">if</span> (posMaybe.Count &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Vector3 npos = allpos / posMaybe.Count;</span><br><span class="line">            velocity += (npos - pos) / dt;</span><br><span class="line">            pos = npos;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        posMaybe.Clear();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//这里进行力的添加，如重力</span></span><br><span class="line">        pos += velocity * dt;<span class="comment">//速度产生的位移</span></span><br><span class="line">        velocity *= <span class="number">0.99f</span>;<span class="comment">//空气阻力会使速度减小ss</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//给重力</span></span><br><span class="line">        Vector3 a = gravity / mass;</span><br><span class="line">        velocity += a * dt;</span><br><span class="line">        pos += <span class="number">0.5f</span> * a * dt * dt;<span class="comment">//加速度产生的位移</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Update_collide</span>(<span class="params">Vector3 Object, <span class="built_in">float</span> r</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ((pos - Object).magnitude &lt; r)<span class="comment">//如果下落距离大于俩者本来的差距 那就不进去</span></span><br><span class="line">        &#123;</span><br><span class="line">            pos = Object + r * (pos - Object).normalized;</span><br><span class="line">            velocity = Vector3.zero;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Vector3[] <span class="title">Tov3</span>(<span class="params">List&lt;Point&gt; points</span>)<span class="comment">//copy </span></span></span><br><span class="line">    &#123;</span><br><span class="line">        Vector3[] v = <span class="keyword">new</span> Vector3[points.Count];</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; points.Count; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            v[i] = points[i].pos;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Spring</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> Point pa, pb;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> orinLength;</span><br><span class="line">    <span class="comment">//public float length;</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> k;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> L0;<span class="comment">//向量的长度！！！</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Spring</span>(<span class="params">Point a1, Point b1, <span class="built_in">float</span> l1, <span class="built_in">float</span> k1</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        pa = a1;</span><br><span class="line">        pb = b1;</span><br><span class="line">        <span class="keyword">this</span>.orinLength = l1;</span><br><span class="line">        <span class="keyword">this</span>.k = k1;</span><br><span class="line">        <span class="keyword">this</span>.L0 = (a1.pos - b1.pos).magnitude;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flex</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Vector3 pa1 = (pa.pos + pb.pos + L0 * (pa.pos - pb.pos).normalized) / <span class="number">2f</span>;</span><br><span class="line">        Vector3 pb1 = (pa.pos + pb.pos + L0 * (pb.pos - pa.pos).normalized) / <span class="number">2f</span>;</span><br><span class="line">        pa.posMaybe.Add(pa1);</span><br><span class="line">        pb.posMaybe.Add(pb1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2021/11/07/%E5%B8%83%E6%96%99%E6%A8%A1%E6%8B%9F/image-20211128160030224.png" class title="image-20211128160030224"><h3 id="或者另一种实现："><a href="#或者另一种实现：" class="headerlink" title="或者另一种实现："></a>或者另一种实现：</h3><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">cloth_motion</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">float</span> t;</span><br><span class="line"><span class="built_in">int</span>[] edge_list;</span><br><span class="line"><span class="built_in">float</span> mass;</span><br><span class="line"><span class="built_in">float</span> damping;</span><br><span class="line"><span class="built_in">float</span> stiffness;</span><br><span class="line"><span class="built_in">float</span>[] L0;</span><br><span class="line">Vector3[] velocities;</span><br><span class="line"><span class="keyword">public</span> Vector3 gravity = <span class="keyword">new</span> Vector3(<span class="number">0</span>, <span class="number">-9.8f</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">public</span> <span class="built_in">float</span> dt = <span class="number">0.007f</span>;<span class="comment">//144帧，每帧用时7mscop</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">List</span>&lt;<span class="title">Vector3</span>&gt; posMaybe1</span> = <span class="keyword">new</span> List&lt;Vector3&gt;();<span class="comment">//存可能的值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">List</span>&lt;<span class="title">Vector3</span>&gt; posMaybe2</span> = <span class="keyword">new</span> List&lt;Vector3&gt;();</span><br><span class="line"><span class="keyword">public</span> Vector3[] vertices;<span class="comment">//记录各顶点</span></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">float</span> r;</span><br><span class="line"><span class="keyword">public</span> Vector3 heart;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> GameObject obj;</span><br><span class="line"><span class="comment">// Use this for initialization</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">t = <span class="number">0.075f</span>;</span><br><span class="line">mass = <span class="number">5.0f</span>;</span><br><span class="line">damping = <span class="number">0.99f</span>;</span><br><span class="line">stiffness = <span class="number">1000.0f</span>;</span><br><span class="line"></span><br><span class="line">Mesh mesh = GetComponent&lt;MeshFilter&gt;().mesh;</span><br><span class="line"><span class="built_in">int</span>[] triangles = mesh.triangles;   <span class="comment">//存的是三角形顶点的序列</span></span><br><span class="line">vertices = mesh.vertices;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Construct the original edge list</span></span><br><span class="line"><span class="built_in">int</span>[] original_edge_list = <span class="keyword">new</span> <span class="built_in">int</span>[triangles.Length * <span class="number">2</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; triangles.Length; i += <span class="number">3</span>)</span><br><span class="line">&#123;</span><br><span class="line">original_edge_list[i * <span class="number">2</span> + <span class="number">0</span>] = triangles[i + <span class="number">0</span>];</span><br><span class="line">original_edge_list[i * <span class="number">2</span> + <span class="number">1</span>] = triangles[i + <span class="number">1</span>];</span><br><span class="line">original_edge_list[i * <span class="number">2</span> + <span class="number">2</span>] = triangles[i + <span class="number">1</span>];</span><br><span class="line">original_edge_list[i * <span class="number">2</span> + <span class="number">3</span>] = triangles[i + <span class="number">2</span>];</span><br><span class="line">original_edge_list[i * <span class="number">2</span> + <span class="number">4</span>] = triangles[i + <span class="number">2</span>];</span><br><span class="line">original_edge_list[i * <span class="number">2</span> + <span class="number">5</span>] = triangles[i + <span class="number">0</span>];<span class="comment">//每俩位是一条边</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Reorder the original edge list</span></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; original_edge_list.Length; i += <span class="number">2</span>)</span><br><span class="line"><span class="keyword">if</span> (original_edge_list[i] &gt; original_edge_list[i + <span class="number">1</span>])</span><br><span class="line">Swap(<span class="keyword">ref</span> original_edge_list[i], <span class="keyword">ref</span> original_edge_list[i + <span class="number">1</span>]);<span class="comment">//让每条边的序号小的点在前面</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Sort the original edge list using quicksort</span></span><br><span class="line">Quick_Sort(<span class="keyword">ref</span> original_edge_list, <span class="number">0</span>, original_edge_list.Length / <span class="number">2</span> - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; original_edge_list.Length; i += <span class="number">2</span>)</span><br><span class="line"><span class="keyword">if</span> (i == <span class="number">0</span> ||</span><br><span class="line">original_edge_list[i + <span class="number">0</span>] != original_edge_list[i - <span class="number">2</span>] ||</span><br><span class="line">original_edge_list[i + <span class="number">1</span>] != original_edge_list[i - <span class="number">1</span>])</span><br><span class="line">count++;<span class="comment">//除重</span></span><br><span class="line"></span><br><span class="line">edge_list = <span class="keyword">new</span> <span class="built_in">int</span>[count * <span class="number">2</span>];</span><br><span class="line"><span class="built_in">int</span> r_count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; original_edge_list.Length; i += <span class="number">2</span>)</span><br><span class="line"><span class="keyword">if</span> (i == <span class="number">0</span> ||</span><br><span class="line">original_edge_list[i + <span class="number">0</span>] != original_edge_list[i - <span class="number">2</span>] ||</span><br><span class="line">original_edge_list[i + <span class="number">1</span>] != original_edge_list[i - <span class="number">1</span>])</span><br><span class="line">&#123;</span><br><span class="line">edge_list[r_count * <span class="number">2</span> + <span class="number">0</span>] = original_edge_list[i + <span class="number">0</span>];</span><br><span class="line">edge_list[r_count * <span class="number">2</span> + <span class="number">1</span>] = original_edge_list[i + <span class="number">1</span>];</span><br><span class="line">r_count++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">L0 = <span class="keyword">new</span> <span class="built_in">float</span>[edge_list.Length / <span class="number">2</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> e = <span class="number">0</span>; e &lt; edge_list.Length / <span class="number">2</span>; e++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">int</span> v0 = edge_list[e * <span class="number">2</span> + <span class="number">0</span>];</span><br><span class="line"><span class="built_in">int</span> v1 = edge_list[e * <span class="number">2</span> + <span class="number">1</span>];</span><br><span class="line">L0[e] = (vertices[v0] - vertices[v1]).magnitude;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">velocities = <span class="keyword">new</span> Vector3[vertices.Length];</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> v = <span class="number">0</span>; v &lt; vertices.Length; v++)</span><br><span class="line">velocities[v] = <span class="keyword">new</span> Vector3(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//for(int i=0; i&lt;edge_list.Length/2; i++)</span></span><br><span class="line"><span class="comment">//Debug.Log (&quot;number&quot;+i+&quot; is&quot; + edge_list [i*2] + &quot;and&quot;+ edge_list [i*2+1]);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Quick_Sort</span>(<span class="params"><span class="keyword">ref</span> <span class="built_in">int</span>[] a, <span class="built_in">int</span> l, <span class="built_in">int</span> r</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">int</span> j;</span><br><span class="line"><span class="keyword">if</span> (l &lt; r)</span><br><span class="line">&#123;</span><br><span class="line">j = Quick_Sort_Partition(<span class="keyword">ref</span> a, l, r);</span><br><span class="line">Quick_Sort(<span class="keyword">ref</span> a, l, j - <span class="number">1</span>);</span><br><span class="line">Quick_Sort(<span class="keyword">ref</span> a, j + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="built_in">int</span> <span class="title">Quick_Sort_Partition</span>(<span class="params"><span class="keyword">ref</span> <span class="built_in">int</span>[] a, <span class="built_in">int</span> l, <span class="built_in">int</span> r</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">int</span> pivot_0, pivot_1, i, j;</span><br><span class="line">pivot_0 = a[l * <span class="number">2</span> + <span class="number">0</span>];</span><br><span class="line">pivot_1 = a[l * <span class="number">2</span> + <span class="number">1</span>];</span><br><span class="line">i = l;</span><br><span class="line">j = r + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">do</span> ++i; <span class="keyword">while</span> (i &lt;= r &amp;&amp; (a[i * <span class="number">2</span>] &lt; pivot_0 || a[i * <span class="number">2</span>] == pivot_0 &amp;&amp; a[i * <span class="number">2</span> + <span class="number">1</span>] &lt;= pivot_1));</span><br><span class="line"><span class="keyword">do</span> --j; <span class="keyword">while</span> (a[j * <span class="number">2</span>] &gt; pivot_0 || a[j * <span class="number">2</span>] == pivot_0 &amp;&amp; a[j * <span class="number">2</span> + <span class="number">1</span>] &gt; pivot_1);</span><br><span class="line"><span class="keyword">if</span> (i &gt;= j) <span class="keyword">break</span>;</span><br><span class="line">Swap(<span class="keyword">ref</span> a[i * <span class="number">2</span>], <span class="keyword">ref</span> a[j * <span class="number">2</span>]);</span><br><span class="line">Swap(<span class="keyword">ref</span> a[i * <span class="number">2</span> + <span class="number">1</span>], <span class="keyword">ref</span> a[j * <span class="number">2</span> + <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line">Swap(<span class="keyword">ref</span> a[l * <span class="number">2</span> + <span class="number">0</span>], <span class="keyword">ref</span> a[j * <span class="number">2</span> + <span class="number">0</span>]);</span><br><span class="line">Swap(<span class="keyword">ref</span> a[l * <span class="number">2</span> + <span class="number">1</span>], <span class="keyword">ref</span> a[j * <span class="number">2</span> + <span class="number">1</span>]);</span><br><span class="line"><span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Swap</span>(<span class="params"><span class="keyword">ref</span> <span class="built_in">int</span> a, <span class="keyword">ref</span> <span class="built_in">int</span> b</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">int</span> temp = a;</span><br><span class="line">a = b;</span><br><span class="line">b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Vector3[] allposMaybe;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Strain_Limiting</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">int</span>[] count1 = <span class="keyword">new</span> <span class="built_in">int</span>[vertices.Length];</span><br><span class="line">Vector3[] finalV3 = <span class="keyword">new</span> Vector3[vertices.Length];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> val = <span class="number">0</span>; val &lt; vertices.Length; val++)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> e = <span class="number">0</span>; e &lt; edge_list.Length / <span class="number">2</span>; e++)  <span class="comment">//对每条线来说</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (edge_list[e * <span class="number">2</span>] == val)</span><br><span class="line">&#123;</span><br><span class="line">Vector3 pa1 = (vertices[edge_list[e * <span class="number">2</span> + <span class="number">0</span>]] + vertices[edge_list[e * <span class="number">2</span> + <span class="number">1</span>]]</span><br><span class="line"> + L0[e] * ((vertices[edge_list[e * <span class="number">2</span> + <span class="number">0</span>]] - vertices[edge_list[e * <span class="number">2</span> + <span class="number">1</span>]]).normalized)) / <span class="number">2f</span>;</span><br><span class="line">posMaybe1.Add(pa1);</span><br><span class="line"><span class="comment">//Debug.Log(pa1);</span></span><br><span class="line">count1[val]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (edge_list[e * <span class="number">2</span> + <span class="number">1</span>] == val)</span><br><span class="line">&#123;</span><br><span class="line">Vector3 pa2 = (vertices[edge_list[e * <span class="number">2</span> + <span class="number">0</span>]] + vertices[edge_list[e * <span class="number">2</span> + <span class="number">1</span>]]</span><br><span class="line"> + L0[e] * ((-vertices[edge_list[e * <span class="number">2</span> + <span class="number">0</span>]] + vertices[edge_list[e * <span class="number">2</span> + <span class="number">1</span>]]).normalized)) / <span class="number">2f</span>;</span><br><span class="line">posMaybe1.Add(pa2);</span><br><span class="line">count1[val]++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">foreach</span> (Vector3 temp <span class="keyword">in</span> posMaybe1)</span><br><span class="line">&#123;</span><br><span class="line">finalV3[val] += temp;</span><br><span class="line">&#125;</span><br><span class="line">posMaybe1.Clear();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> val = <span class="number">0</span>; val &lt; vertices.Length; val++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (val != <span class="number">0</span> &amp;&amp; val != <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">finalV3[val] = finalV3[val] / count1[val];</span><br><span class="line"></span><br><span class="line">vertices[val] = finalV3[val];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Collision_Handling</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> val = <span class="number">0</span>; val &lt; vertices.Length; val++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> ((vertices[val] - heart).magnitude &lt; r)<span class="comment">//如果下落距离大于俩者本来的差距 那就不进去</span></span><br><span class="line">&#123;</span><br><span class="line">vertices[val] = heart + r * (vertices[val] - heart).normalized;</span><br><span class="line">velocities[val] = Vector3.zero;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Update is called once per frame</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Update</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">heart = obj.transform.position;</span><br><span class="line">Mesh mesh = GetComponent&lt;MeshFilter&gt;().mesh;</span><br><span class="line">Vector3[] verticesTem = mesh.vertices;</span><br><span class="line">verticesTem = vertices;</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; verticesTem.Length; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (i != <span class="number">10</span> &amp;&amp; i != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">Vector3 a = gravity / mass;</span><br><span class="line">velocities[i] += a * dt;</span><br><span class="line">velocities[i] *= damping;</span><br><span class="line"></span><br><span class="line">verticesTem[i] += velocities[i] * dt;<span class="comment">//速度产生的位移</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Strain_Limiting();</span><br><span class="line">Collision_Handling();</span><br><span class="line">mesh.vertices = verticesTem;</span><br><span class="line">mesh.RecalculateNormals();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2021/11/07/%E5%B8%83%E6%96%99%E6%A8%A1%E6%8B%9F/image-20211128160223585.png" class title="image-20211128160223585"><hr><h1 id="Thanks"><a href="#Thanks" class="headerlink" title="Thanks:"></a>Thanks:</h1><p>Unity Mesh 初体验 :<a href="https://www.jianshu.com/p/7cd99a05cfea">https://www.jianshu.com/p/7cd99a05cfea</a></p><p>Mesh.RecalculateNormals 重新计算法线 :<a href="http://docs.manew.com/Script/Mesh.RecalculateNormals.html">http://docs.manew.com/Script/Mesh.RecalculateNormals.html</a></p><p>C# and Shader Tutorials for the Unity Engine :<a href="https://catlikecoding.com/unity/tutorials/">https://catlikecoding.com/unity/tutorials/</a></p><p>Unity Mesh变形（制作一个弹力球）:<a href="https://blog.csdn.net/haog87/article/details/108162792">https://blog.csdn.net/haog87/article/details/108162792</a></p><p>Unity3D中文手册:<a href="https://dev.gameres.com/Program/Unity3Dmanual/Script/index.Classes.html">https://dev.gameres.com/Program/Unity3Dmanual/Script/index.Classes.html</a></p><p>快速排序quicksort的Ｃ实现：<a href="http://blog.chinaunix.net/uid-24774106-id-2238633.html">http://blog.chinaunix.net/uid-24774106-id-2238633.html</a></p><p>Unity里的Mesh属性：<a href="https://zhuanlan.zhihu.com/p/353794573">https://zhuanlan.zhihu.com/p/353794573</a></p><p><a href="https://blog.csdn.net/u011618339/article/details/106225426?spm=1001.2101.3001.6650.14&amp;utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~default-15.no_search_link&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~default-15.no_search_link">https://blog.csdn.net/u011618339/article/details/106225426?spm=1001.2101.3001.6650.14&amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7Edefault-15.no_search_link&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7Edefault-15.no_search_link</a></p><p><a href="https://blog.csdn.net/qq_37043683/article/details/80272419">https://blog.csdn.net/qq_37043683/article/details/80272419</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Unity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity杂记</title>
      <link href="/2021/11/03/Unity%E6%9D%82%E8%AE%B0/"/>
      <url>/2021/11/03/Unity%E6%9D%82%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h4 id="1-unity中Vector3-normalized和Vector3-Normalized的区别"><a href="#1-unity中Vector3-normalized和Vector3-Normalized的区别" class="headerlink" title="1.unity中Vector3.normalized和Vector3.Normalized的区别"></a>1.unity中Vector3.normalized和Vector3.Normalized的区别</h4><p>共同点：</p><p>​    实现规范化，让一个向量保持相同的方向，但它的长度为1.0，如果这个向量太小而不能被规范化，一个零向量将会被返回。</p><p>不同点：</p><p>​    Vector3.normalized的特点是当前向量是不改变的并且返回一个新的规范化的向量；</p><p>​    Vector3.Normalize的特点是改变当前向量，也就是当前向量长度是1</p><h3 id="2-vector-magnitude"><a href="#2-vector-magnitude" class="headerlink" title="2.vector.magnitude"></a>2.vector.magnitude</h3><p>返回向量的长度。向量的长度是(x<em>x+y</em>y+z*z)的平方根。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Unity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity-IntermediateScript</title>
      <link href="/2021/11/02/Unity-IntermediateScript/"/>
      <url>/2021/11/02/Unity-IntermediateScript/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h3 id="1-属性-Properties"><a href="#1-属性-Properties" class="headerlink" title="1.属性 Properties"></a>1.属性 Properties</h3><p>在外部访问类内部变量的需求，除了设其为public，还可以用properties。其在内部封装变量，称其为域，可以用get{}set{}对其内部进行访问。</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Properties</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> experience;<span class="comment">//这是一个私有的域</span></span><br><span class="line">    <span class="comment">//想要在类外访问他，就需要来一个Properties</span></span><br><span class="line">    <span class="comment">//首字母大写</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Experience  </span><br><span class="line">    &#123;   <span class="comment">//括号内是属性的访问器</span></span><br><span class="line">        <span class="keyword">get</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> experience;</span><br><span class="line">        &#125;           <span class="comment">//取值时调用</span></span><br><span class="line">        <span class="keyword">set</span></span><br><span class="line">        &#123;</span><br><span class="line">            experience=<span class="keyword">value</span>;</span><br><span class="line">        &#125;           <span class="comment">//赋值时调用</span></span><br><span class="line">        <span class="comment">//不实现其中一个，就能做到只读或者只写，这是public做不到的</span></span><br><span class="line">        <span class="comment">//2.其可以在内部加函数，或者返回值进行特定转变（例子是用   输入经验值却返回等级</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Experience1&#123;<span class="keyword">get</span>;<span class="keyword">set</span>;&#125;<span class="comment">//缩写 </span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">UseProperties</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">start</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Properties myProperties =<span class="keyword">new</span> Properties();  <span class="comment">//在类外使用他</span></span><br><span class="line">        myProperties.Experience = <span class="number">5</span>;</span><br><span class="line">        <span class="built_in">int</span> x=myProperties.Experience;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="2-三元操作符-Ternary-Operator"><a href="#2-三元操作符-Ternary-Operator" class="headerlink" title="2.三元操作符 Ternary Operator"></a>2.三元操作符 Ternary Operator</h3><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">message = health &gt; <span class="number">0</span> ? <span class="string">&quot;Player is Alive&quot;</span> : <span class="string">&quot;Player is Dead&quot;</span>; <span class="comment">//也可以嵌套循环</span></span><br></pre></td></tr></table></figure><hr><h3 id="3-静态类型-Statics"><a href="#3-静态类型-Statics" class="headerlink" title="3.静态类型 Statics"></a>3.静态类型 Statics</h3><p>静态成员可以在类的所有实例被共享，而且其可以通过类直接访问，不需要实例。</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Statics</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">int</span> enemyCount =<span class="number">0</span>;<span class="comment">//静态成员属于类本身</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Statics</span>(<span class="params"></span>)</span></span><br><span class="line">   &#123;</span><br><span class="line">       enemyCount++ ;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Game</span></span><br><span class="line">&#123;</span><br><span class="line">    Statics a1=<span class="keyword">new</span> Statics();</span><br><span class="line">    Statics a2=<span class="keyword">new</span> Statics();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">int</span> x=Statics.enemyCount;<span class="comment">//直接使用类名.静态成员名</span></span><br><span class="line">    <span class="comment">//静态函数同理。</span></span><br><span class="line">    <span class="comment">//在unity中  Input.GetButton();等都是静态函数！</span></span><br><span class="line">&#125;<span class="comment">//也可以新建一个static类，其内部全是静态成员 例如Unity的Input类</span></span><br></pre></td></tr></table></figure><hr><h3 id="4-重载-Overloading"><a href="#4-重载-Overloading" class="headerlink" title="4.重载 Overloading"></a>4.重载 Overloading</h3><p>懒得写了。需要注意的是如果没有完全匹配的重载（ExactMatch)，会类型转化(LeastConversion)，如果还没有就error。</p><hr><h3 id="5-泛型-Generics"><a href="#5-泛型-Generics" class="headerlink" title="5.泛型 Generics"></a>5.泛型 Generics</h3><p>泛型特性使类和函数等，可以接受类型作为参数。这就允许你编写通用的程序，而不需要知道要处理的数据的具体类型。就例如之前的GetComponent()，利用&lt;&gt;来获取组件，它就是泛型函数。</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Generics</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">GenericMethod</span>&lt;<span class="title">T</span>&gt;(<span class="params">T param</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> param;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//泛型函数后面可以用where限定T的类型</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">GenericMethod2</span>&lt;<span class="title">T</span>&gt;(<span class="params">T param</span>) <span class="keyword">where</span> T : <span class="keyword">struct</span>    <span class="comment">//①struct-value ②class-reference </span></span></span><br><span class="line">    &#123;<span class="keyword">return</span> param;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">GenericMethod3</span>&lt;<span class="title">T</span>&gt;(<span class="params">T param</span>) <span class="keyword">where</span> T : <span class="keyword">new</span>(<span class="params"></span>)     <span class="comment">//③new()-公有的不需要参数 ④也可以用具体的类名，确定就是这个类或者其多态 ⑤或者接口</span></span></span><br><span class="line">    &#123;<span class="keyword">return</span> param;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">GenericClass</span> &lt;<span class="title">T</span>&gt; <span class="comment">//泛型类</span></span><br><span class="line">&#123;</span><br><span class="line">    T item;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span>(<span class="params">T item2</span>)</span></span><br><span class="line">    &#123;item=item2;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">UseGenerics</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;<span class="comment">//具体的使用</span></span><br><span class="line">    <span class="comment">// Start is called before the first frame update</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Generics myGenerics = <span class="keyword">new</span> Generics();</span><br><span class="line">        myGenerics.GenericMethod&lt;<span class="built_in">int</span>&gt;(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        GenericClass&lt;<span class="built_in">int</span>&gt; myClass=<span class="keyword">new</span>  GenericClass&lt;<span class="built_in">int</span>&gt;();</span><br><span class="line">        myClass.<span class="keyword">add</span>(<span class="number">4</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="6-继承-inheritance"><a href="#6-继承-inheritance" class="headerlink" title="6.继承 inheritance"></a>6.继承 inheritance</h3><hr><h3 id="7-多态-Polymorphism"><a href="#7-多态-Polymorphism" class="headerlink" title="7.多态 Polymorphism"></a>7.多态 Polymorphism</h3><hr><h3 id="8-成员隐藏-MemberHiding"><a href="#8-成员隐藏-MemberHiding" class="headerlink" title="8.成员隐藏 MemberHiding"></a>8.成员隐藏 MemberHiding</h3><p>在继承时，基类成员自动继承到子类中，在子类中重新创建，或叫重新声明，一个基类成员就叫成员隐藏。？ </p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Humanoid</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Yell</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Enemy</span> : <span class="title">Humanoid</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="function"><span class="keyword">void</span> <span class="title">Yell</span>(<span class="params"></span>) <span class="comment">//这样子类被up casting的时候，会默认用父类的Yell()?</span></span></span><br><span class="line">    &#123;    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="9-覆盖-Overriding"><a href="#9-覆盖-Overriding" class="headerlink" title="9.覆盖 Overriding"></a>9.覆盖 Overriding</h3><p>指在子类中改变基类方法的行为</p><p>对基类函数设置virtual ，对子类函数设置override，即可进行覆盖</p><hr><h3 id="10-接口-Interfaces"><a href="#10-接口-Interfaces" class="headerlink" title="10.接口 Interfaces"></a>10.接口 Interfaces</h3><p>可以当作对功能的一种约定</p><p>实现接口的类，必须拥有所有接口规定的函数和属性。这样子这个类可以被其他类当成接口对待。</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IKillable</span> <span class="comment">//IXXXXable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Kill</span>(<span class="params"></span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IDamageable</span>&lt;<span class="title">T</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Damage</span>(<span class="params">T damageTaken</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为实现某个接口，类当中必须显式声明所有接口中的属性，事件，函数，索引器，否则报错。</p><p>好处在于，可以跨越类型，定义常用的功能。</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Interfaces</span> : <span class="title">MonoBehaviour</span> , <span class="title">IKillable</span> , <span class="title">IDamageable</span>&lt;<span class="title">float</span>&gt;</span><br><span class="line">&#123;   <span class="comment">//必须实现这些接口所需要的函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Kill</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Damage</span>(<span class="params"><span class="built_in">float</span> damage</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>可能会好奇为什么要用接口。</p><p>因为一个类可以实现多个接口，但是只能继承一个父类，所以接口提供更丰富的功能性。</p><p>或者说，接口用来定义跨越类的功能，这些类之间无关联。</p><hr><h3 id="11-扩展方法-Extension-Method"><a href="#11-扩展方法-Extension-Method" class="headerlink" title="11.扩展方法 Extension Method"></a>11.扩展方法 Extension Method</h3><p>用来给类型增加功能，而不用创建一个衍生类型或者修改原类型，非常适用于增加类的功能而不修改类本身。</p><p>必须放在无泛型的静态类当中，一般单独创建类去保存它。</p><p>也要用static关键字声明，其与静态方法区别关键在于this</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">Extension</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ResetTransformations</span>(<span class="params"><span class="keyword">this</span> Transform trans</span>)</span> &#123;</span><br><span class="line">        trans.position = Vector3.zero;</span><br><span class="line">        trans.localRotation = Quaternion.identity;</span><br><span class="line">        trans.localScale = Vector3.zero;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ExtensionMethods</span> :<span class="title">MonoBehaviour</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        transform.ResetTransformations();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="12-Namespaces"><a href="#12-Namespaces" class="headerlink" title="12.Namespaces"></a>12.Namespaces</h3><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">MyNameSpace</span>&#123;<span class="comment">//create</span></span><br><span class="line">......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> MyNameSpace;<span class="comment">//using</span></span><br><span class="line">MyNameSpace.XXX;</span><br></pre></td></tr></table></figure><hr><h3 id="13-列表和字典-Lists-and-Dictionaries"><a href="#13-列表和字典-Lists-and-Dictionaries" class="headerlink" title="13.列表和字典 Lists and Dictionaries"></a>13.列表和字典 Lists and Dictionaries</h3><p>俩个泛型集合。</p><p>list 动态数组，提供更大的灵活和丰富的功能</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections.Generic;<span class="comment">//使用前需加入</span></span><br><span class="line"><span class="keyword">using</span> System;<span class="comment">//使用list的Sort()功能需要加入</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">BadGuy</span> : <span class="title">IComparable</span>&lt;<span class="title">BadGuy</span>&gt; <span class="comment">//如果要用list的sort功能，需要加入这个接口，语法类似于继承  这个接口又在system命名空间中，所以也要加一个using </span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> name;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> power;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BadGuy</span>(<span class="params"><span class="built_in">string</span> NewName, <span class="built_in">int</span> NewPower</span>)</span>&#123;</span><br><span class="line">        name = NewName;</span><br><span class="line">        power = NewPower;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">CompareTo</span>(<span class="params">BadGuy other</span>)  <span class="comment">//如果要用list的sort功能，需要加入这个接口，并完成接口的约定，这个接口只需要我们实现这个接口</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(other == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> power-other.power;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">list</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        List&lt;BadGuy&gt; badguys = <span class="keyword">new</span> List&lt;BadGuy&gt;();</span><br><span class="line"></span><br><span class="line">        badguys.Add(<span class="keyword">new</span> BadGuy(<span class="string">&quot;Stu1&quot;</span>,<span class="number">100</span>));</span><br><span class="line">        badguys.Add(<span class="keyword">new</span> BadGuy(<span class="string">&quot;Stu2&quot;</span>,<span class="number">200</span>));</span><br><span class="line">        badguys.Add(<span class="keyword">new</span> BadGuy(<span class="string">&quot;Stu3&quot;</span>,<span class="number">50</span>));</span><br><span class="line"></span><br><span class="line">       <span class="comment">// badguys[0].name;</span></span><br><span class="line">        badguys.Sort();<span class="comment">//排序</span></span><br><span class="line">        <span class="keyword">foreach</span> (BadGuy guy <span class="keyword">in</span> badguys)</span><br><span class="line">        &#123;</span><br><span class="line">            print(guy.name + <span class="string">&quot; &quot;</span> + guy.power);</span><br><span class="line">        &#125;</span><br><span class="line">        badguys.Clear();<span class="comment">//清除</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Dictionary工作方式类似，但需要俩种类型。也就是说每个元素由键值对组成，简称kvp。</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Dictionaaa</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">start</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Dictionary&lt;<span class="built_in">string</span>,BadGuy&gt; badguys =<span class="keyword">new</span> Dictionary&lt;<span class="built_in">string</span>,BadGuy&gt;();</span><br><span class="line">                <span class="comment">//第一个参数是key，第二个是value</span></span><br><span class="line">        BadGuy bg1=<span class="keyword">new</span> BadGuy(<span class="string">&quot;Harvey&quot;</span>,<span class="number">50</span>);</span><br><span class="line">        BadGuy bg2=<span class="keyword">new</span> BadGuy(<span class="string">&quot;Magneto&quot;</span>,<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">        badguys.Add(<span class="string">&quot;aa&quot;</span>,bg1);<span class="comment">//需要同时有key和value</span></span><br><span class="line">        badguys.Add(<span class="string">&quot;bb&quot;</span>,bg2);<span class="comment">//add进dictionary</span></span><br><span class="line"></span><br><span class="line">        BadGuy magnet =badguys[<span class="string">&quot;bb&quot;</span>];   <span class="comment">//获取key保存的值，此时key是bb</span></span><br><span class="line"></span><br><span class="line">        BadGuy temp =<span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(badguys.TryGetValue(<span class="string">&quot;birds&quot;</span>,<span class="keyword">out</span> temp))<span class="comment">//如果不确定key是不是存在，可以进行这个函数</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//success</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//fail</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="14-携程-Coroutine"><a href="#14-携程-Coroutine" class="headerlink" title="14.携程 Coroutine"></a>14.携程 Coroutine</h3><p>可以被看作是间接执行的函数，用yield声明，将代码跳出到函数外，如果继续会回到原处继续执行。可以有效避免update在每一帧使用带来的资源浪费！</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Coroutine</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> smoothing=<span class="number">1f</span>;</span><br><span class="line">    <span class="keyword">public</span> Transform target;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        StartCoroutine(MyCoroutine(target));<span class="comment">//调用携程</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">IEnumerator <span class="title">MyCoroutine</span> (<span class="params">Transform target</span>)  <span class="comment">//返回任何实现了ienumerator接口的东西</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(Vector3.Distance(transform.position, target.position)&gt;<span class="number">0.05f</span>)  <span class="comment">//当俩者距离靠近之后，</span></span><br><span class="line">        &#123;</span><br><span class="line">            transform.position = Vector3.Lerp(transform.position, target.position,smoothing*Time.deltaTime);<span class="comment">//疯狂插值 接近</span></span><br><span class="line">            <span class="keyword">yield</span> <span class="keyword">return</span> <span class="literal">null</span>; <span class="comment">//跳出等到下次update， yield是重点</span></span><br><span class="line">        &#125;</span><br><span class="line">        print(<span class="string">&quot;Reached the target&quot;</span>);</span><br><span class="line">        <span class="function"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title">WaitForSeconds</span>(<span class="params"><span class="number">3f</span></span>)</span>;    <span class="comment">//跳出等3s                  </span></span><br><span class="line">        print(<span class="string">&quot;MyCoroutine is now finished&quot;</span>);   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h3 id="15-四元数-Quaternions"><a href="#15-四元数-Quaternions" class="headerlink" title="15.四元数 Quaternions"></a>15.四元数 Quaternions</h3><p>在unity中，四元数保存物体的旋转信息。是个四元向量，xyzw，四个值相互依赖，不能单独更改。</p><p>负责处理旋转的系统叫欧拉角，其基于xyz，但其会受限于万向节锁的问题，故不用。</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这是被看物体的移动</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">motion</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> speed =<span class="number">3f</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        transform.Translate(-Input.GetAxis(<span class="string">&quot;Horizontal&quot;</span>)*speed*Time.deltaTime,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这是观察者的函数</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Lookat1</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> Transform target;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Vector3 relativePos=target.position-transform.position;</span><br><span class="line">        transform.rotation=Quaternion.LookRotation(relativePos);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//绕着target旋转</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">circleRound</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> Transform target;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Vector3 relativePos =(target.position+<span class="keyword">new</span> Vector3(<span class="number">0</span>,<span class="number">1.5f</span>,<span class="number">0</span>))-transform.position;</span><br><span class="line">        Quaternion rotation = Quaternion.LookRotation(relativePos);</span><br><span class="line"></span><br><span class="line">        Quaternion current = transform.localRotation;</span><br><span class="line"></span><br><span class="line">        transform.localRotation = Quaternion.Slerp(current, rotation,Time.deltaTime);</span><br><span class="line">        transform.Translate(<span class="number">0</span>,<span class="number">0</span>,<span class="number">3</span>*Time.deltaTime);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h3 id="16-委托-Delegates"><a href="#16-委托-Delegates" class="headerlink" title="16.委托 Delegates"></a>16.委托 Delegates</h3><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">DelegateScript</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">MyDelegate</span>(<span class="params"><span class="built_in">int</span> num</span>)</span>;  <span class="comment">//我们的委托</span></span><br><span class="line">    MyDelegate myDelegate;  <span class="comment">//创建完委托类型后，接着声明成员变量</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">PrintNum</span>(<span class="params"><span class="built_in">int</span> num</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        print(<span class="string">&quot;PrintNum&quot;</span>+num);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">DoubleNum</span>(<span class="params"><span class="built_in">int</span> num</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        print(<span class="string">&quot;Double Num&quot;</span> + num);</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        myDelegate = PrintNum;  <span class="comment">//类似于函数指针，还是很好懂的</span></span><br><span class="line">        myDelegate(<span class="number">50</span>); <span class="comment">//输出就是PrintNum50</span></span><br><span class="line"></span><br><span class="line">        myDelegate =DoubleNum;</span><br><span class="line">        myDelegate(<span class="number">50</span>);</span><br><span class="line"></span><br><span class="line">        myDelegate +=PrintNum; <span class="comment">//委托广播，可以包含很多函数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="17-特性-Attributes"><a href="#17-特性-Attributes" class="headerlink" title="17.特性 Attributes"></a>17.特性 Attributes</h3><p>特性能在声明时，对函数变量或者类添加额外信息。（这里好像只讲了俩个</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"></span><br><span class="line">[<span class="meta">ExecuteInEditMode</span>] </span><br><span class="line"><span class="comment">//这个特性允许代码在场景中就生效，而不是运行时才生效，可以进行实时更改，无法还原</span></span><br><span class="line"><span class="comment">//需要写在整个代码上面，毕竟是对全体代码生效的</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">spin</span> : <span class="title">MonoBehaviour</span> &#123;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">Range(-100,100)</span>]   <span class="comment">//这里把特性放在变量声明上面</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> speed=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">Range(-100,100)</span>] <span class="keyword">public</span> <span class="built_in">int</span> maxSpeed;<span class="comment">//第二种写法，限定范围</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        transform.Rotate(<span class="keyword">new</span> Vector3(<span class="number">0</span>,speed*Time.deltaTime,<span class="number">0</span>));</span><br><span class="line">        <span class="comment">//按y轴旋转对象   </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="18-事件-Events"><a href="#18-事件-Events" class="headerlink" title="18.事件 Events"></a>18.事件 Events</h3><p>相当于公共的广播委托，用于提醒其他类有什么事发生了。 有点难理解，于是查阅发现以下解释：</p><p>“事件是拥有可以注册和解绑方法（函数）的功能。</p><p>虽然事件和委托看起来有点绕，只要捋清楚事件和委托的关系，就会很容易理解。</p><p>委托是一个类，事件则是委托类中的一个对象，该对象是能够把其他方法注册到委托类中的一个事件（如果觉得有点绕，可以忽略这句话）。</p><p>事件和函数的关系：事件具有可以注册多个函数（和解绑函数）的功能，而函数如果要注册和解绑其他在其主体上运行的函数则需要改动该函数本体的代码，这就是区别。</p><p>以下代码的大致流程：定义一个新类（事件类）–》类中声明委托–》由委托类又声明事件–》再定义触发事件的函数–》函数主体中执行事件–》在主函数中实例化事件类–》进而调用事件类中的事件对象–》事件对象再注册（+=）两个方法–》再执行事件类中触发事件的那个函数–》再解绑其中一个方法–》再次执行事件类中触发事件的函数。</p><p>由此可见：事件是拥有可以注册和解绑方法（函数）的功能。”</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">DelegateAndEvent</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//定义一个事件类</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MyEvent</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//定义一个委托</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">MyDelegate</span>(<span class="params"></span>)</span>;</span><br><span class="line">        <span class="comment">//定义一个事件</span></span><br><span class="line">        <span class="keyword">public</span> MyDelegate MyDelegateEvent;</span><br><span class="line">        <span class="comment">//定义一个触发事件的函数</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnMyDelegateEvent</span>(<span class="params"></span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//判断事件是否非空</span></span><br><span class="line">            <span class="keyword">if</span> (MyDelegateEvent != <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//执行事件</span></span><br><span class="line">                MyDelegateEvent();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//MyDelegateEvent?.Invoke(); //简化的判断和执行</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//输出一串字符</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">putOutChar</span>(<span class="params"></span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;I was fired&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//输出第二串字符</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">putOutChar2</span>(<span class="params"></span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;I was fired22222&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//实例化MyEvent2类</span></span><br><span class="line">            MyEvent myEvent = <span class="keyword">new</span> MyEvent();</span><br><span class="line">            <span class="comment">//注册一个事件</span></span><br><span class="line">            myEvent.MyDelegateEvent += <span class="keyword">new</span> MyEvent.MyDelegate(putOutChar);</span><br><span class="line">            myEvent.MyDelegateEvent += <span class="keyword">new</span> MyEvent.MyDelegate(putOutChar2);</span><br><span class="line">            <span class="comment">//执行触发事件的函数</span></span><br><span class="line">            Console.WriteLine(<span class="string">&quot;执行绑定了两个事件后的函数&quot;</span>);</span><br><span class="line">            myEvent.OnMyDelegateEvent();</span><br><span class="line">            <span class="comment">//解绑一个事件</span></span><br><span class="line">            myEvent.MyDelegateEvent -= <span class="keyword">new</span> MyEvent.MyDelegate(putOutChar);</span><br><span class="line">            <span class="comment">//再次执行触发事件的函数</span></span><br><span class="line">            Console.WriteLine(<span class="string">&quot;执行解绑了一个事件后的函数&quot;</span>);</span><br><span class="line">            myEvent.OnMyDelegateEvent();</span><br><span class="line">            Console.ReadKey();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>又或者“<strong>delegate</strong> 相当于定义一个函数类型。</p><p><strong>event</strong> 相当于定义一个 <strong>delegate</strong> 的函数指针（回调函数指针）。”</p></blockquote><hr><h3 id="Thanks"><a href="#Thanks" class="headerlink" title="Thanks:"></a>Thanks:</h3><p><a href="https://www.bilibili.com/video/BV1hs411r7ZM?spm_id_from=333.999.0.0">https://www.bilibili.com/video/BV1hs411r7ZM?spm_id_from=333.999.0.0</a></p><p><a href="https://www.runoob.com/csharp/csharp-event.html">https://www.runoob.com/csharp/csharp-event.html</a></p><p><a href="https://www.bilibili.com/video/BV1Es411t7rL?p=10">https://www.bilibili.com/video/BV1Es411t7rL?p=10</a></p><p>只是不求甚解地过了一遍，具体还是要在实践中熟练了，才算学会。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Unity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity-BasicScript2</title>
      <link href="/2021/10/31/Unity-BasicScript2/"/>
      <url>/2021/10/31/Unity-BasicScript2/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h3 id="1-DataTypes"><a href="#1-DataTypes" class="headerlink" title="1.DataTypes"></a>1.DataTypes</h3><p>初级分为Value和Reference</p><p>Value：int float double bool char Structs{Vector3,Quatenion}</p><p>Reference: Classes{Transform,GameObject}</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Transform tran=transform;<span class="comment">//这里的transform就是组件 故是地址 共同改变了属于是</span></span><br><span class="line">        tran.position = <span class="keyword">new</span> Vector3(<span class="number">0</span>,<span class="number">0</span>,<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><hr><h3 id="2-类的使用"><a href="#2-类的使用" class="headerlink" title="2.类的使用"></a>2.类的使用</h3><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Fuc1</span>&#123;</span><br><span class="line">       <span class="built_in">int</span> a1;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Fun1</span>(<span class="params"><span class="built_in">int</span> aa1</span>)</span>&#123;<span class="comment">//Constructor //no return value</span></span><br><span class="line">           a1=aa1;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="keyword">public</span> Fuc1 fuc1=<span class="keyword">new</span> Fuc1();</span><br></pre></td></tr></table></figure><hr><h3 id="3-Instantiate"><a href="#3-Instantiate" class="headerlink" title="3.Instantiate()"></a>3.Instantiate()</h3><p>Instantiate函数实例化是将original对象的所有子物体和子组件完全复制，成为一个新的对象。这个新的对象拥有与源对象完全一样的东西，包括坐标值等。</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Rigidbody rocketPrefab;<span class="comment">//需要绑定一个带Rigidbody的物体</span></span><br><span class="line"><span class="keyword">public</span> Transform barrelEnd;<span class="comment">//需要绑定一个(空)物体,坐标就是生成位置</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">Update</span>(<span class="params"></span>)</span></span><br><span class="line">   &#123;</span><br><span class="line">       <span class="keyword">if</span>(Input.GetKeyDown(KeyCode.K))</span><br><span class="line">       &#123;<span class="comment">//在Inspector中绑定物品即可 //可以用来生成子弹</span></span><br><span class="line">           Instantiate(rocketPrefab);</span><br><span class="line">           <span class="comment">//第二种 第二三个参数是新克隆体的位置和旋转值</span></span><br><span class="line">           Instantiate(rocketPrefab,barrelEnd.position,barrelEnd.rotation);   </span><br><span class="line">           <span class="comment">//第三种，当作刚体可以进行力的施加</span></span><br><span class="line">           Rigidbody rocketRigid;</span><br><span class="line">           rocketRigid=Instantiate(rocketPrefab,barrelEnd.position,barrelEnd.rotation) <span class="keyword">as</span> Rigidbody;</span><br><span class="line">           rocketRigid.AddForce(Vector3.up * <span class="number">500</span>);</span><br><span class="line">           <span class="comment">//因为克隆出来的物体会一直存在，所以如果是子弹什么的可以加一个定时销毁的脚本</span></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><hr><h3 id="4-数组Array"><a href="#4-数组Array" class="headerlink" title="4.数组Array"></a>4.数组Array</h3><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span>[] array1=<span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">4</span>];</span><br><span class="line">   <span class="built_in">int</span>[] array2=&#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">54</span>,<span class="number">53</span>&#125;;</span><br><span class="line">   <span class="keyword">public</span> GameObject[] players;  <span class="comment">//public即可界面编辑</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span></span><br><span class="line">   &#123;</span><br><span class="line">       array1[<span class="number">0</span>]=<span class="number">2</span>;</span><br><span class="line">       players=GameObject.FindGameObjectsWithTag(<span class="string">&quot;player&quot;</span>);<span class="comment">//用指定的标签去寻找</span></span><br><span class="line">       <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; players.Length; i++)</span><br><span class="line">           Debug.Log(<span class="string">&quot;Goodbye&quot;</span>+i+players[i].name);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><hr><h3 id="5-Invoke"><a href="#5-Invoke" class="headerlink" title="5.Invoke()"></a>5.Invoke()</h3><p>允许安排一个延时调用的函数。</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object target;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">SpawnObject</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">float</span> x=Random.Range(<span class="number">-3.0f</span>, <span class="number">3.0f</span>);</span><br><span class="line">        <span class="built_in">float</span> z=Random.Range(<span class="number">-3.0f</span>, <span class="number">3.0f</span>);</span><br><span class="line">        Instantiate(target,<span class="keyword">new</span> Vector3(x,<span class="number">1</span>,z),Quaternion.identity);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Invoke(<span class="string">&quot;SpawnObject&quot;</span>,<span class="number">2</span>);</span><br><span class="line">        <span class="comment">//延时俩秒调用 </span></span><br><span class="line">        <span class="comment">//只有不需要传入参数，且返回类型为void的函数才能用Invoke调用</span></span><br><span class="line">        InvokeRepeating(<span class="string">&quot;SpawnObject&quot;</span>,<span class="number">2</span>,<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//延时俩秒调用，并且之后每隔一秒调用一次</span></span><br><span class="line">        CancelInvoke();</span><br><span class="line">        CancelInvoke(<span class="string">&quot;SpawnObject&quot;</span>);</span><br><span class="line">        <span class="comment">//停止延时调用</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><hr><h3 id="6-Enumeration-Enum"><a href="#6-Enumeration-Enum" class="headerlink" title="6.Enumeration/Enum"></a>6.Enumeration/Enum</h3><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">enum</span> Enum1&#123; North, East, South, West&#125;;</span><br><span class="line"><span class="comment">//enum 可以写在class外/注意大写 因为这是类不是变量/注意最后的；</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span></span><br><span class="line">   &#123;</span><br><span class="line">       Enum1 myEnum;</span><br><span class="line">       myEnum = Enum1.North;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><p>Thanks：</p><p>Unity官方脚本P3： <a href="https://www.bilibili.com/video/BV17s411o7Mf?p=3">https://www.bilibili.com/video/BV17s411o7Mf?p=3</a></p><p>Unity入门路线： <a href="https://www.zhihu.com/question/314175363/answer/650214605">https://www.zhihu.com/question/314175363/answer/650214605</a></p><hr><p>突然想到或许我可以做一个roft学长的3d卡牌对战游戏，但是在同时加入摄像机旋转切换游戏玩家，实现双人同时玩的卡牌游戏…挺有意思的。roft学长的游戏很多用low-poly，好喜欢这个风格。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Unity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity-BasicScript1</title>
      <link href="/2021/10/31/Unity-BasicScript/"/>
      <url>/2021/10/31/Unity-BasicScript/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h3 id="1-在Unity中似乎把组件（inspecter中的属性）当成类使用，在C-中需创建类的实例，并用GetComponent获取才可以对其操作。"><a href="#1-在Unity中似乎把组件（inspecter中的属性）当成类使用，在C-中需创建类的实例，并用GetComponent获取才可以对其操作。" class="headerlink" title="1.在Unity中似乎把组件（inspecter中的属性）当成类使用，在C#中需创建类的实例，并用GetComponent获取才可以对其操作。"></a>1.在Unity中似乎把组件（inspecter中的属性）当成类使用，在C#中需创建类的实例，并用GetComponent获取才可以对其操作。</h3><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Light light1;</span><br><span class="line"><span class="keyword">private</span> CharacterController cc; <span class="comment">// 获得该组件</span></span><br><span class="line"><span class="keyword">private</span> Vector3 dir;    <span class="comment">//储存移动的方向</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span></span><br><span class="line">   &#123;</span><br><span class="line">       cc = GetComponent&lt;CharacterController&gt;();</span><br><span class="line">       light1=GetComponent&lt;Light&gt;();</span><br><span class="line">   &#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Update</span>(<span class="params"></span>)</span></span><br><span class="line">   &#123;</span><br><span class="line">       <span class="keyword">if</span> (Input.GetKeyDown())</span><br><span class="line">       &#123;</span><br><span class="line">           light1.enabled = !light1.enabled;</span><br><span class="line">       &#125;</span><br><span class="line">       cc.Move(dir * Time.deltaTime);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="2-似乎发现上方有GetKey-和GetButton-，有何不同呢"><a href="#2-似乎发现上方有GetKey-和GetButton-，有何不同呢" class="headerlink" title="2.似乎发现上方有GetKey()和GetButton()，有何不同呢"></a>2.似乎发现上方有GetKey()和GetButton()，有何不同呢</h3><p>区别在于：</p><p>GetKey需传入KeyCode.XX，如Input.GetKeyDown(KeyCode.Space)。</p><p>而GetButton则传入提前预设好的键位：如Input.GetButtonDown(“Jump”)。</p><p>路径：Edit-Project Setting-Input Manager 。好处在于你可以详细地设计键位，使得键盘手柄可以共用。</p><img src="/2021/10/31/Unity-BasicScript/image-20211031143205933.png" class title="image-20211031143205933"><h3 id="3-在以下代码中，定义了一个GameObject的实例，但是这需要在脚本组件中自行选择Object拖入，毕竟在代码中也不能选择更高维度的咯（或许可以）。"><a href="#3-在以下代码中，定义了一个GameObject的实例，但是这需要在脚本组件中自行选择Object拖入，毕竟在代码中也不能选择更高维度的咯（或许可以）。" class="headerlink" title="3.在以下代码中，定义了一个GameObject的实例，但是这需要在脚本组件中自行选择Object拖入，毕竟在代码中也不能选择更高维度的咯（或许可以）。"></a>3.在以下代码中，定义了一个GameObject的实例，但是这需要在脚本组件中自行选择Object拖入，毕竟在代码中也不能选择更高维度的咯（或许可以）。</h3><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">DetectIsActive</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> GameObject myObject;</span><br><span class="line">    <span class="comment">// Start is called before the first frame update</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Debug.Log(<span class="string">&quot;DetectIsActive&quot;</span> +myObject.activeSelf);</span><br><span class="line">        Debug.Log(<span class="string">&quot;DetectIsActive2&quot;</span> +myObject.activeInHierarchy);</span><br><span class="line">        gameObject.SetActive(<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2021/10/31/Unity-BasicScript/image-20211031144323263.png" class title="image-20211031144323263"><p>另外，这里用active来判定其物体是否激活，当然也要看父组件的激活情况。</p><h3 id="4-Translate-Rotate"><a href="#4-Translate-Rotate" class="headerlink" title="4.Translate() Rotate()"></a>4.Translate() Rotate()</h3><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">float</span> moveSpeed=<span class="number">3f</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="built_in">float</span> turnSpeed=<span class="number">1f</span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Update</span>(<span class="params"></span>)</span></span><br><span class="line">  &#123;<span class="comment">//注意transform大小写 /(ㄒoㄒ)/~~</span></span><br><span class="line">      transform.Translate(<span class="keyword">new</span> Vector3(<span class="number">0</span>,<span class="number">0</span>,<span class="number">3</span>)*moveSpeed*Time.deltaTime);</span><br><span class="line">      transform.Translate(Vector3.forward*moveSpeed*Time.deltaTime); </span><br><span class="line">      <span class="comment">//forward = 物体自己的z 等同于上行  </span></span><br><span class="line">      transform.Translate(transform.forward * moveSpeed *Time.deltaTime);</span><br><span class="line">      <span class="comment">//而Transform.forward则是当前物体的正方向</span></span><br><span class="line">      transform.Rotate(Vector3.up,-turnSpeed*Time.deltaTime); </span><br><span class="line">      <span class="comment">//up代表其旋转绕的向量轴（也就是y）</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="5-LookAt"><a href="#5-LookAt" class="headerlink" title="5.LookAt()"></a>5.LookAt()</h3><p>指定给摄像机，并绑定target即可。<del>（但是试不出来…</del> (原来是错放在start函数里了，并且需要关掉其他脚本才可运行。))</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Transform target;</span><br><span class="line">   <span class="comment">// Start is called before the first frame update</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">Update</span>(<span class="params"></span>)<span class="comment">//Start()</span></span></span><br><span class="line">   &#123;</span><br><span class="line">       transform.LookAt(target);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="5-Destory"><a href="#5-Destory" class="headerlink" title="5.Destory()"></a>5.Destory()</h3><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Update</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(Input.GetKeyDown(KeyCode.J))</span><br><span class="line">        &#123;</span><br><span class="line">            Destroy(gameObject);    <span class="comment">//删除自己</span></span><br><span class="line">            Destroy(other);     <span class="comment">//删除绑定的物体</span></span><br><span class="line">            Destroy(GetComponent&lt;Light&gt;());     <span class="comment">//删除其组件 </span></span><br><span class="line">            Destroy(GetComponent&lt;Light&gt;(),<span class="number">3f</span>);     <span class="comment">//延迟3秒 删除其组件 </span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="6-GetAxis"><a href="#6-GetAxis" class="headerlink" title="6.GetAxis()"></a>6.GetAxis()</h3><p>返回-1~1的bool ，需指定Horizontal或者Vertical，实例可以看上次的FPS Blog。</p><img src="/2021/10/31/Unity-BasicScript/image-20211031153023092.png" class title="image-20211031153023092"><p>同上在Input Manager可管理gravity：从1-0的回复速度</p><p>Sensitivity：从0-1的变化速度</p><p>Dead： 响应盲区，去避免摇杆微弱的误触</p><p>Snap：允许俩边同时响应时返回0</p><p>也可以用Input.GetAxisRaw()只返回整数，可以精确操控</p><h3 id="7-OnMouseDown"><a href="#7-OnMouseDown" class="headerlink" title="7.OnMouseDown()"></a>7.OnMouseDown()</h3><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OnMouseDown</span>(<span class="params"></span>)</span> </span><br><span class="line">   &#123;</span><br><span class="line">       GetComponent&lt;Rigidbody&gt;().AddForce(transform.forward*<span class="number">300</span>);  <span class="comment">//给一个物体z方向的力</span></span><br><span class="line">       GetComponent&lt;Rigidbody&gt;().useGravity=<span class="literal">true</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="8"><a href="#8" class="headerlink" title="8."></a>8.<img src="/2021/10/31/Unity-BasicScript/image-20211031161545879.png" class title="image-20211031161545879"></h3><hr><h3 id="Thanks"><a href="#Thanks" class="headerlink" title="Thanks:"></a>Thanks:</h3><p>Unity-Transform类：<a href="https://blog.csdn.net/weixin_42446849/article/details/81669864">https://blog.csdn.net/weixin_42446849/article/details/81669864</a></p><p>Unity官方脚本开发初级教程：<a href="https://www.bilibili.com/video/BV1cs411o7GD?p=5">https://www.bilibili.com/video/BV1cs411o7GD?p=5</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Unity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity1-FPS控制</title>
      <link href="/2021/10/29/Unity-FPS%E6%8E%A7%E5%88%B6/"/>
      <url>/2021/10/29/Unity-FPS%E6%8E%A7%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<!--好好学Unity从今天开始(lll￢ω￢)--><h2 id="一-FPS控制"><a href="#一-FPS控制" class="headerlink" title="一.FPS控制"></a>一.FPS控制</h2><p>1.导入assets建立场景， 创建一个player并将main camera绑定至player下即可。</p><p>2.为camera编写视角控制脚本：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Player</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> Transform player;<span class="comment">//用于获取transform组件</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">float</span> mouseX, mouseY;   <span class="comment">//获取鼠标移动的值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> mouseSensitivity;<span class="comment">//鼠标灵敏度</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> xRotation; </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Update</span> (<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        mouseX = Input.GetAxis(<span class="string">&quot;Mouse X&quot;</span>) * mouseSensitivity * Time.deltaTime;</span><br><span class="line">        mouseY = Input.GetAxis(<span class="string">&quot;Mouse Y&quot;</span>) * mouseSensitivity * Time.deltaTime;  <span class="comment">//GetAxis() 返回 -1_~1 向左,下是-1，向右,上是1</span></span><br><span class="line">        <span class="comment">//Time.deltaTime 是变量 指完成上一帧所用的时间 防止FPS波动导致的time波动</span></span><br><span class="line"></span><br><span class="line">        xRotation -= mouseY; <span class="comment">//累加 </span></span><br><span class="line">        xRotation = Mathf.Clamp(xRotation, <span class="number">-70f</span>, <span class="number">70f</span>);<span class="comment">//限制视角</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        player.Rotate(Vector3.up * mouseX);</span><br><span class="line">        transform.localRotation = Quaternion.Euler(xRotation, <span class="number">0</span>, <span class="number">0</span>);<span class="comment">//四元数（TODO</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>3.为player编写移动脚本：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">RealPlayer</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> CharacterController cc; <span class="comment">// 用于获得CharacterController组件</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> moveSpeed;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> jumpSpeed;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">float</span> horizontalMove, verticalMove;</span><br><span class="line">    <span class="keyword">private</span> Vector3 dir;    <span class="comment">//储存移动的方向</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> gravity;</span><br><span class="line">    <span class="keyword">private</span> Vector3 velocity;<span class="comment">// 重力加速度</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Transform groundCheck; <span class="comment">//为了检测与地面的碰撞</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> checkRadius;  </span><br><span class="line">    <span class="keyword">public</span> LayerMask groundLayer;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">bool</span> isGround;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        cc = GetComponent&lt;CharacterController&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Update</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        isGround = Physics.CheckSphere(groundCheck.position,checkRadius,groundLayer);</span><br><span class="line">        <span class="keyword">if</span>(isGround &amp;&amp; velocity.y&lt;<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            velocity.y = <span class="number">-2f</span>;<span class="comment">//防止落地后 加速度不停下降     值会影响自由落体的手感     </span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        horizontalMove = Input.GetAxis(<span class="string">&quot;Horizontal&quot;</span>)*moveSpeed;</span><br><span class="line">        verticalMove = Input.GetAxis(<span class="string">&quot;Vertical&quot;</span>)*moveSpeed;</span><br><span class="line"></span><br><span class="line">        dir = transform.forward * verticalMove + transform.right * horizontalMove;</span><br><span class="line">        cc.Move(dir * Time.deltaTime);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(Input.GetButtonDown(<span class="string">&quot;Jump&quot;</span>) <span class="comment">/*&amp;&amp; isGround*/</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            velocity.y = jumpSpeed;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        velocity.y -= gravity * Time.deltaTime;<span class="comment">//每秒减去重力的值</span></span><br><span class="line">        cc.Move(velocity * Time.deltaTime); <span class="comment">//自由落体的公式 要乘以时间的二次方 故多乘</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>4.别忘记在Inspector中删去player的碰撞，加入Character Controller。</p><p>新建空物体附在player下面，命名Ground Check，并赋给脚本中的groundCheck。再调整其高度在player的脚底板，以检测碰撞。在Inspector的layer中，新建ground层并将场景的全部environment设置为ground层。再将脚本中的那个层设为该ground层就大功告成了。</p><img src="/2021/10/29/Unity-FPS%E6%8E%A7%E5%88%B6/20211029210158.png" class width="20211029210158"><img src="/2021/10/29/Unity-FPS%E6%8E%A7%E5%88%B6/202110292119.gif" class width="202110292119"><p><del>5.借用室友调侃的话说：做出原神指日可待 (￣▽￣)”  遥遥无期</del></p><p>感谢：</p><p>Time.deltaTime 理解: <a href="https://blog.csdn.net/weixin_37608784/article/details/84859597">https://blog.csdn.net/weixin_37608784/article/details/84859597</a></p><p>Unity Documentation: <a href="https://docs.unity3d.com/cn/2021.1/ScriptReference/index.html">https://docs.unity3d.com/cn/2021.1/ScriptReference/index.html</a></p><p>​    <a href="https://docs.unity3d.com/cn/2019.3/ScriptReference/Quaternion.Euler.html">https://docs.unity3d.com/cn/2019.3/ScriptReference/Quaternion.Euler.html</a></p><p>Unity asset store：<a href="https://assetstore.unity.com/?q=low-poly%20simple%20nature&amp;orderBy=1">https://assetstore.unity.com/?q=low-poly%20simple%20nature&amp;orderBy=1</a></p><p>Blend Swap: <a href="https://blendswap.com/blend/26019#">https://blendswap.com/blend/26019#</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Unity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MY FIRST BLOG!</title>
      <link href="/2021/10/26/MY-FIRST-BLOG/"/>
      <url>/2021/10/26/MY-FIRST-BLOG/</url>
      
        <content type="html"><![CDATA[<p>行吧 辛苦了一阵子 可能总算是把这个破博客弄好了~<br>有缘更新！</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2021/10/26/hello-world/"/>
      <url>/2021/10/26/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
