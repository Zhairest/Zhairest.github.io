<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.jpg?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.jpg?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta property="og:type" content="website">
<meta property="og:title" content="旋转公寓的阁楼">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="旋转公寓的阁楼">
<meta property="og:locale">
<meta property="article:author" content="Zhairest">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://example.com/"/>





  <title>旋转公寓的阁楼</title>
  








<meta name="generator" content="Hexo 5.4.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">旋转公寓的阁楼</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">储物间</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/11/19/OpenGL-%E9%9A%8F%E7%AC%94%E8%AE%B02/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/head.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="旋转公寓的阁楼">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/11/19/OpenGL-%E9%9A%8F%E7%AC%94%E8%AE%B02/" itemprop="url">OpenGL 第三章 视图</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-11-19T15:51:00+08:00">
                2021-11-19
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于&#58;</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2021-11-19T18:56:41+08:00">
                2021-11-19
              </time>
            
          </span>

          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  687
                </span>
              

              

              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <p>​    终于终于第三章了呢，一共有十五章呢……</p>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2021/11/19/OpenGL-%E9%9A%8F%E7%AC%94%E8%AE%B02/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/11/18/Unity-shader3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/head.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="旋转公寓的阁楼">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/11/18/Unity-shader3/" itemprop="url">Unity_shader3</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-11-18T20:19:22+08:00">
                2021-11-18
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于&#58;</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2021-11-19T14:48:39+08:00">
                2021-11-19
              </time>
            
          </span>

          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  1.1k
                </span>
              

              

              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="表面着色器Surface-Shader"><a href="#表面着色器Surface-Shader" class="headerlink" title="表面着色器Surface Shader"></a>表面着色器Surface Shader</h1><p>实际上就是对顶点-片段着色器的一种抽象，并包含了很多光照模型。使其更加简便。</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">Shader &quot;Custom/NewSurfaceShader&quot;	<span class="comment">//unity默认的表面着色器</span></span><br><span class="line">&#123;</span><br><span class="line">    Properties</span><br><span class="line">    &#123;</span><br><span class="line">        _Color (&quot;Color&quot;, Color) = (<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">        _MainTex (&quot;Albedo (RGB)&quot;, <span class="number">2</span>D) = &quot;white&quot; &#123;&#125;</span><br><span class="line">        _Glossiness (&quot;Smoothness&quot;, Range(<span class="number">0</span>,<span class="number">1</span>)) = <span class="number">0.5</span></span><br><span class="line">        _Metallic (&quot;Metallic&quot;, Range(<span class="number">0</span>,<span class="number">1</span>)) = <span class="number">0.0</span></span><br><span class="line">    &#125;</span><br><span class="line">    SubShader</span><br><span class="line">    &#123;</span><br><span class="line">        Tags &#123; &quot;RenderType&quot;=&quot;Opaque&quot; &#125;</span><br><span class="line">        LOD <span class="number">200</span></span><br><span class="line"></span><br><span class="line">        CGPROGRAM</span><br><span class="line">        <span class="comment">// Physically based Standard lighting model, and enable shadows on all light types</span></span><br><span class="line">        <span class="meta">#pragma surface surf Standard fullforwardshadows</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Use shader model 3.0 target, to get nicer looking lighting</span></span><br><span class="line">        <span class="meta">#pragma target 3.0</span></span><br><span class="line"></span><br><span class="line">        <span class="type">sampler2D</span> _MainTex;</span><br><span class="line"></span><br><span class="line">        struct Input</span><br><span class="line">        &#123;</span><br><span class="line">            float2 uv_MainTex;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        half _Glossiness;</span><br><span class="line">        half _Metallic;</span><br><span class="line">        fixed4 _Color;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Add instancing support for this shader. You need to check &#x27;Enable Instancing&#x27; on materials that use the shader.</span></span><br><span class="line">        <span class="comment">// See https://docs.unity3d.com/Manual/GPUInstancing.html for more information about instancing.</span></span><br><span class="line">        <span class="comment">// #pragma instancing_options assumeuniformscaling</span></span><br><span class="line">        UNITY_INSTANCING_BUFFER_START(Props)</span><br><span class="line">            <span class="comment">// put more per-instance properties here</span></span><br><span class="line">        UNITY_INSTANCING_BUFFER_END(Props)</span><br><span class="line"></span><br><span class="line">        <span class="type">void</span> surf (Input IN, <span class="keyword">inout</span> SurfaceOutputStandard o)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// Albedo comes from a texture tinted by color</span></span><br><span class="line">            fixed4 c = tex2D (_MainTex, IN.uv_MainTex) * _Color;</span><br><span class="line">            o.Albedo = c.rgb;</span><br><span class="line">            <span class="comment">// Metallic and smoothness come from slider variables</span></span><br><span class="line">            o.Metallic = _Metallic;</span><br><span class="line">            o.Smoothness = _Glossiness;</span><br><span class="line">            o.Alpha = c.a;</span><br><span class="line">        &#125;</span><br><span class="line">        ENDCG</span><br><span class="line">    &#125;</span><br><span class="line">    FallBack &quot;Diffuse&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="表面着色器编译指令"><a href="#表面着色器编译指令" class="headerlink" title="表面着色器编译指令"></a>表面着色器编译指令</h2><p># pragma surface surfaceFunction lightModel [optionalparams]</p>
<p>lightModel - 要使用的光照模型。内置光照模型是基于物理的 Standard 和 StandardSpecular，以及简单的非基于物理的 Lambert（漫射）和 BlinnPhong（镜面反射）。</p>
<h2 id="表面函数surf"><a href="#表面函数surf" class="headerlink" title="表面函数surf()"></a>表面函数surf()</h2><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> surf (Input IN, <span class="keyword">inout</span> SurfaceOutputStandard o)</span><br><span class="line">        &#123;</span><br><span class="line">        ......</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>inout表示即是输入函数又是输出函数。</p>
<p>Input是输入的结构体，而后面的SurfaceOutputStandard是输出结构体。</p>
<h2 id="表面函数输出结构体"><a href="#表面函数输出结构体" class="headerlink" title="表面函数输出结构体"></a>表面函数输出结构体</h2><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">struct SurfaceOutput &#123;    </span><br><span class="line">    half3 Albedo;      <span class="comment">// 该像素的反射率，反应了像素的基色   </span></span><br><span class="line">    half3 Normal;     <span class="comment">// 该像素的法线方向  </span></span><br><span class="line">    half3 Emission;   <span class="comment">// 该像素的自发光颜色，使得即便没有光照也可以物体本身也可以发出光  </span></span><br><span class="line">    half Specular;     <span class="comment">// 该像素的高光指数    </span></span><br><span class="line">    half Gloss;         <span class="comment">// 该像素的高光光滑度，值越大高光反射越清晰，反之越模糊    </span></span><br><span class="line">    half Alpha;         <span class="comment">// 该像素的不透明度   </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在unity5以后，加入了基于物理属性的光照模型，有俩个：</p>
<p>Standard，适合金属工作流</p>
<p>StandardSpecular，适合高光工作流</p>
<p>其均在UnityPBSLighting.cginc中被包含</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">struct SurfaceOutputStandard</span><br><span class="line">｛</span><br><span class="line">    fixed3 Albedo;      <span class="comment">// base (diffuse or specular) color</span></span><br><span class="line">    fixed3 Normal;      <span class="comment">// tangent space normal, if written</span></span><br><span class="line">    half3 Emission;</span><br><span class="line">    half Metallic;      <span class="comment">// 0=non-metal, 1=metal</span></span><br><span class="line">    half Smoothness;    <span class="comment">// 0=rough, 1=smooth</span></span><br><span class="line">    half Occlusion;     <span class="comment">// occlusion (default 1)</span></span><br><span class="line">    fixed Alpha;        <span class="comment">// alpha for transparencies</span></span><br><span class="line">｝;</span><br><span class="line">struct SurfaceOutputStandardSpecular</span><br><span class="line">｛</span><br><span class="line">    fixed3 Albedo;      <span class="comment">// diffuse color</span></span><br><span class="line">    fixed3 Specular;    <span class="comment">// specular color</span></span><br><span class="line">    fixed3 Normal;      <span class="comment">// tangent space normal, if written</span></span><br><span class="line">    half3 Emission;</span><br><span class="line">    half Smoothness;    <span class="comment">// 0=rough, 1=smooth</span></span><br><span class="line">    half Occlusion;     <span class="comment">// occlusion (default 1)</span></span><br><span class="line">    fixed Alpha;        <span class="comment">// alpha for transparencies</span></span><br><span class="line">｝;</span><br></pre></td></tr></table></figure>

<h2 id="法线贴图"><a href="#法线贴图" class="headerlink" title="法线贴图"></a>法线贴图</h2><p>法线贴图可以逐像素修改物体表面法线的方向，使得产生凹凸不平的假象。以此可以实现低模的基础上实现高模的细节了。</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Properties</span><br><span class="line">  &#123;</span><br><span class="line">     ......</span><br><span class="line">      _Normal (&quot;Normal Map&quot;, <span class="number">2</span>D) = &quot;bump&quot; &#123;&#125;</span><br><span class="line">      _Bumpiness (&quot;Bumpiness&quot;, Range(<span class="number">0</span>, <span class="number">1</span>)) = <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">struct Input</span><br><span class="line">  &#123;</span><br><span class="line">      float2 uv_MainTex;</span><br><span class="line">      float2 uv_Normal;</span><br><span class="line">  &#125;;</span><br><span class="line"><span class="type">void</span> surf (Input IN, <span class="keyword">inout</span> SurfaceOutputStandard o)</span><br><span class="line">  &#123;</span><br><span class="line">  	......</span><br><span class="line">       <span class="comment">// 采样法线贴图并解包</span></span><br><span class="line">      fixed3 n = UnpackNormal(tex2D(_Normal, IN.uv_Normal));</span><br><span class="line">      n *= float3(_Bumpiness, _Bumpiness, <span class="number">1</span>);</span><br><span class="line">      o.Normal = n;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2021/11/18/Unity-shader3/v2-3828a0cafa4d2f5f6372d1d3e9d17a12_r.jpg" alt="img"></p>
<h2 id="表面着色器其他函数"><a href="#表面着色器其他函数" class="headerlink" title="表面着色器其他函数"></a>表面着色器其他函数</h2><p><img src="/2021/11/18/Unity-shader3/v2-2d5e6d1de528ac425502547beb41b24a_r.jpg" alt="表面着色器的计算流程"></p>
<p>虽说表面着色器是对于顶点着色器的高度封装，但是还是有很多可以定义的函数的。</p>
<h3 id="比如，可以通过对顶点修改函数的修改，实现顶点修改的效果，例如模型朝法线方向膨胀。"><a href="#比如，可以通过对顶点修改函数的修改，实现顶点修改的效果，例如模型朝法线方向膨胀。" class="headerlink" title="比如，可以通过对顶点修改函数的修改，实现顶点修改的效果，例如模型朝法线方向膨胀。"></a>比如，可以通过对顶点修改函数的修改，实现顶点修改的效果，例如模型朝法线方向膨胀。</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">Shader &quot;Unlit/9_Expansion&quot;</span><br><span class="line">&#123;</span><br><span class="line">    Properties</span><br><span class="line">    &#123;</span><br><span class="line">        _MainTex (&quot;MainTex&quot;, 2D) = &quot;white&quot; &#123;&#125;</span><br><span class="line">        _Expansion (&quot;Expansion&quot;, Range(0, 0.1)) = 0</span><br><span class="line">    &#125;</span><br><span class="line">    SubShader</span><br><span class="line">    &#123;</span><br><span class="line">        CGPROGRAM</span><br><span class="line"></span><br><span class="line">        // 添加自定义顶点修函数vert</span><br><span class="line">        #pragma surface surf Lambert vertex:vert</span><br><span class="line"></span><br><span class="line">        struct Input</span><br><span class="line">        &#123;</span><br><span class="line">            float2 uv_MainTex;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        sampler2D _MainTex;</span><br><span class="line">        fixed _Expansion;</span><br><span class="line"></span><br><span class="line">        // 顶点修改函数，输入/输出appdata_full结构体</span><br><span class="line">        void vert (inout appdata_full v)</span><br><span class="line">        &#123;</span><br><span class="line">            v.vertex.xyz += v.normal * _Expansion;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        void surf (Input IN, inout SurfaceOutput o)</span><br><span class="line">        &#123;</span><br><span class="line">            o.Albedo = tex2D(_MainTex, IN.uv_MainTex).rgb;</span><br><span class="line">        &#125;</span><br><span class="line">        ENDCG</span><br><span class="line">    &#125;</span><br><span class="line">    FallBack &quot;Diffuse&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="自定义光照函数"><a href="#自定义光照函数" class="headerlink" title="自定义光照函数"></a>自定义光照函数</h3><p>如果不乐意使用内置的俩种光照模型（实现漫反射的Lambert和实现镜面反射的BlinnPhong），就可以自定义光照模型。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">Shader &quot;Custom/10_SelfLightingModel&quot;</span><br><span class="line">&#123;</span><br><span class="line">    Properties</span><br><span class="line">    &#123;</span><br><span class="line">        _MainTex (&quot;MainTex&quot;, 2D) = &quot;white&quot; &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    SubShader</span><br><span class="line">    &#123;</span><br><span class="line">        CGPROGRAM</span><br><span class="line"></span><br><span class="line">        // 声明自定义光照模型为CustomLambert</span><br><span class="line">        #pragma surface surf CustomLambert</span><br><span class="line"></span><br><span class="line">        struct Input</span><br><span class="line">        &#123;</span><br><span class="line">            float2 uv_MainTex;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        sampler2D _MainTex;</span><br><span class="line"></span><br><span class="line">        void surf (Input IN, inout SurfaceOutput o)</span><br><span class="line">        &#123;</span><br><span class="line">            o.Albedo = tex2D(_MainTex, IN.uv_MainTex).rgb;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 自定义光照函数</span><br><span class="line">        half4 LightingCustomLambert (SurfaceOutput s, half3 lightDir, half atten)</span><br><span class="line">        &#123;</span><br><span class="line">            fixed NdotL = saturate(dot(s.Normal, lightDir));</span><br><span class="line"></span><br><span class="line">            half4 c;</span><br><span class="line">            c.rgb = s.Albedo * _LightColor0 * NdotL * atten;</span><br><span class="line">            c.a = s.Alpha;</span><br><span class="line">            return c;</span><br><span class="line">        &#125;</span><br><span class="line">        ENDCG</span><br><span class="line">    &#125;</span><br><span class="line">    FallBack &quot;Diffuse&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="此外还有最终颜色修改函数"><a href="#此外还有最终颜色修改函数" class="headerlink" title="此外还有最终颜色修改函数"></a>此外还有最终颜色修改函数</h3><h2 id="曲面细分函数"><a href="#曲面细分函数" class="headerlink" title="曲面细分函数"></a>曲面细分函数</h2><h3 id="固定数量的曲面细分"><a href="#固定数量的曲面细分" class="headerlink" title="固定数量的曲面细分"></a>固定数量的曲面细分</h3><h3 id="基于边长的曲面细分"><a href="#基于边长的曲面细分" class="headerlink" title="基于边长的曲面细分"></a>基于边长的曲面细分</h3><h3 id="视锥剔除的曲面细分"><a href="#视锥剔除的曲面细分" class="headerlink" title="视锥剔除的曲面细分"></a>视锥剔除的曲面细分</h3><h3 id="基于距离的曲面细分"><a href="#基于距离的曲面细分" class="headerlink" title="基于距离的曲面细分"></a>基于距离的曲面细分</h3><h3 id="Phong曲面细分"><a href="#Phong曲面细分" class="headerlink" title="Phong曲面细分"></a>Phong曲面细分</h3><hr>
<p>Thanks:</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/zhr_hadoop/article/details/51177972">https://blog.csdn.net/zhr_hadoop/article/details/51177972</a></p>
<p>[TOC]</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/11/17/Unity-shader2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/head.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="旋转公寓的阁楼">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/11/17/Unity-shader2/" itemprop="url">Unity_shader2_各类光照模型</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-11-17T17:03:29+08:00">
                2021-11-17
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于&#58;</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2021-11-19T14:05:25+08:00">
                2021-11-19
              </time>
            
          </span>

          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  2.5k
                </span>
              

              

              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="shader中的光照模型"><a href="#shader中的光照模型" class="headerlink" title="shader中的光照模型"></a>shader中的光照模型</h1><p>学到这一章，又为之前图形学的浑水摸鱼而感到羞耻我(＠_＠;)</p>
<h2 id="Lambert光照模型"><a href="#Lambert光照模型" class="headerlink" title="Lambert光照模型"></a>Lambert光照模型</h2><p>光射到粗糙的物体，产生漫反射（diffuse），满足Lambert定理：反射光线的强度与表面法线和光影方向之间的夹角成正比。即光线垂直物体表面时，漫反射强度最大。</p>
<p>其计算公式为：<br>$$<br>C_diffuse =(C_light<em>M_diffuse)saturate(n·l)<br>$$<br>​                        C物体的漫反射颜色=（C入射光线的颜色</em>M物体材质的漫反射颜色）将点积取[0，1]之间（物体的表面法线 -点积- 物体指向灯光的方向）</p>
<h3 id="那如何在shader里获得灯光呢"><a href="#那如何在shader里获得灯光呢" class="headerlink" title="那如何在shader里获得灯光呢"></a>那如何在shader里获得灯光呢</h3><p>Edit&gt;Project Setting&gt;Graphics 中发现已经被设置是前向渲染了</p>
<p>这下子可以使用的灯光属性变量有：_LightColor0     fixed4     灯光的颜色乘上亮度</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">Shader &quot;Hidden/<span class="number">1</span>_Lambert&quot;</span><br><span class="line">&#123;</span><br><span class="line">    Properties</span><br><span class="line">    &#123;</span><br><span class="line">        _MainColor(&quot;Main Color&quot;,Color)=(<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    SubShader</span><br><span class="line">    &#123;</span><br><span class="line">        Pass</span><br><span class="line">        &#123;</span><br><span class="line">            CGPROGRAM</span><br><span class="line">            <span class="meta">#pragma vertex vert</span></span><br><span class="line">            <span class="meta">#pragma fragment frag</span></span><br><span class="line">            <span class="meta">#include &quot;UnityCG.cginc&quot;</span></span><br><span class="line">            <span class="meta">#include &quot;UnityLightingCommon.cginc&quot;</span></span><br><span class="line"></span><br><span class="line">            struct v2f</span><br><span class="line">            &#123;</span><br><span class="line">                float4 pos : SV_POSITION;</span><br><span class="line">                fixed4 dif : COLOR0;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            fixed4 _MainColor;</span><br><span class="line"></span><br><span class="line">            v2f vert (appdata_base v)</span><br><span class="line">            &#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                o.pos =UnityObjectToClipPos(v.vertex);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//法线向量</span></span><br><span class="line">                float3 n=UnityObjectToWorldNormal(v.normal);</span><br><span class="line">                n=<span class="built_in">normalize</span>(n);</span><br><span class="line">                <span class="comment">//灯光方向向量</span></span><br><span class="line">                fixed3 l=<span class="built_in">normalize</span>(_WorldSpaceLightPos0.xyz);</span><br><span class="line">                <span class="comment">//按照公式计算漫反射s</span></span><br><span class="line">                fixed ndotl =<span class="built_in">dot</span>(n,l);<span class="comment">//点积</span></span><br><span class="line">                o.dif =_LightColor0*_MainColor*saturate(ndotl);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            fixed4 frag (v2f i) : SV_Target</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> i.dif;</span><br><span class="line">            &#125;</span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  //法线向量<br>                float3 n=UnityObjectToWorldNormal(v.normal);<br>                n=normalize(n);</p>
<p>计算光照时要确保在同一空间，而法线向量在模型空间，灯光方向向量在世界空间，因此要转化，并且进行标准化。<img src="/image-20211117201334581.png!%5Bim20211117201538527%5D(image-20211117201538527.png" alt="image-20211117201334581"></p>
<hr>
<h2 id="Half-Lambert光照模型"><a href="#Half-Lambert光照模型" class="headerlink" title="Half-Lambert光照模型"></a>Half-Lambert光照模型</h2><p>前者Lambert光照能看到，物体的背面明显过黑，只能再加灯，但不利于性能的优化。故有half出现。</p>
<p>其计算公式为：<br>$$<br>C_diffuse =(C_light<em>M_diffuse)[0.5</em>(n·l)+0.5]<br>$$<br>如此可以看到是先乘0.5将区间缩小至[-0.5,0.5]，然后再加上去，使得物体光照强度从最亮逐渐过渡到最暗。</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//仅改动vertex_shader部分</span></span><br><span class="line">            v2f vert (appdata_base v)</span><br><span class="line">            &#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                o.pos =UnityObjectToClipPos(v.vertex);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//法线向量</span></span><br><span class="line">                float3 n=UnityObjectToWorldNormal(v.normal);</span><br><span class="line">                n=<span class="built_in">normalize</span>(n);</span><br><span class="line">                <span class="comment">//灯光方向向量</span></span><br><span class="line">                fixed3 l=<span class="built_in">normalize</span>(_WorldSpaceLightPos0.xyz);</span><br><span class="line">                <span class="comment">//按照公式计算漫反射s</span></span><br><span class="line">                fixed ndotl =<span class="built_in">dot</span>(n,l);</span><br><span class="line">                o.dif =_LightColor0*_MainColor*(<span class="number">0.5</span>*ndotl+<span class="number">0.5</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2021/11/17/Unity-shader2/image-20211117201523639.png" alt="image-20211117201523639"></p>
<hr>
<h2 id="Phong光照模型"><a href="#Phong光照模型" class="headerlink" title="Phong光照模型"></a>Phong光照模型</h2><p>Lambert能模拟粗糙表面的光照，但是还有很多光滑物体，因此引入镜面反射的光照模型-Phong（印象中好像片元分的够细，俩者效果其实相差无几）</p>
<p>（Phong，越南出生的美国科学家）</p>
<p>其计算公式为：<br>$$<br>SurfaceColor=C_Ambient+C_Diffuse+C_Specular<br>$$<br>即                                环境光+漫反射+镜面反射</p>
<p>其中镜面反射的公式为：<br>$$<br>C_Specular=(C_light·M_specular)saturate(v·r)^Mshininess<br>$$<br>即                                镜面反射光=（灯光亮度·物体材质镜面反射亮度）将范围截到[0,1] (视角方向·光线的发射方向)^物体材质的光泽度</p>
<h3 id="那如何在shader里获得环境光呢"><a href="#那如何在shader里获得环境光呢" class="headerlink" title="那如何在shader里获得环境光呢"></a>那如何在shader里获得环境光呢</h3><p>Window-Rendering-LightingSetting中environmentLight选择Gradient</p>
<p>即可使用：unity_AmbientSky 环境类型的sky color</p>
<p>unity_AmbientEquator</p>
<p>unity_AmbientGround</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">Shader &quot;Hidden/<span class="number">3</span>_Phong&quot;</span><br><span class="line">&#123;</span><br><span class="line">    Properties</span><br><span class="line">    &#123;</span><br><span class="line">        _MainColor(&quot;Main Color&quot;,Color)=(<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">        _SpecularColor(&quot;Specular Color&quot;,Color)=(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>)    <span class="comment">//控制高光颜色</span></span><br><span class="line">        _Shininess(&quot;Shininess&quot;,Range(<span class="number">1</span>,<span class="number">100</span>))=<span class="number">1</span>      <span class="comment">//控制光泽度</span></span><br><span class="line">    &#125;</span><br><span class="line">    SubShader</span><br><span class="line">    &#123;</span><br><span class="line">        Pass</span><br><span class="line">        &#123;</span><br><span class="line">            CGPROGRAM</span><br><span class="line">            <span class="meta">#pragma vertex vert</span></span><br><span class="line">            <span class="meta">#pragma fragment frag</span></span><br><span class="line">            <span class="meta">#include &quot;UnityCG.cginc&quot;</span></span><br><span class="line">            <span class="meta">#include &quot;Lighting.cginc&quot;</span></span><br><span class="line"></span><br><span class="line">            struct v2f</span><br><span class="line">            &#123;</span><br><span class="line">                float4 pos : SV_POSITION;</span><br><span class="line">                fixed4 color : COLOR0;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            fixed4 _MainColor;</span><br><span class="line">            fixed4 _SpecularColor;</span><br><span class="line">            half _Shininess;</span><br><span class="line"></span><br><span class="line">            v2f vert (appdata_base v)</span><br><span class="line">            &#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                o.pos =UnityObjectToClipPos(v.vertex);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//计算公式中各个变量</span></span><br><span class="line">                <span class="comment">//法线向量</span></span><br><span class="line">                float3 n=UnityObjectToWorldNormal(v.normal);</span><br><span class="line">                n=<span class="built_in">normalize</span>(n);</span><br><span class="line">                <span class="comment">//灯光方向向量</span></span><br><span class="line">                fixed3 l=<span class="built_in">normalize</span>(_WorldSpaceLightPos0.xyz);</span><br><span class="line">                fixed3 view=<span class="built_in">normalize</span>(WorldSpaceViewDir(v.vertex));</span><br><span class="line"></span><br><span class="line">                <span class="comment">//按照公式计算漫反射s</span></span><br><span class="line">                fixed ndotl =<span class="built_in">dot</span>(n,l);</span><br><span class="line">                fixed4 dif =_LightColor0*_MainColor*saturate(ndotl);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//镜面反射部分</span></span><br><span class="line">                float3 ref=<span class="built_in">reflect</span>(-l,n);</span><br><span class="line">                ref=<span class="built_in">normalize</span>(ref);</span><br><span class="line">                fixed rdotv=saturate(<span class="built_in">dot</span>(ref,view));</span><br><span class="line">                fixed4 spec=_LightColor0*_SpecularColor*<span class="built_in">pow</span>(rdotv,_Shininess);</span><br><span class="line"></span><br><span class="line">                o.color=unity_AmbientSky+dif+spec;</span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            fixed4 frag (v2f i) : SV_Target</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> i.color;</span><br><span class="line">            &#125;</span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p><img src="/2021/11/17/Unity-shader2/image-20211117204323435.png" alt="image-20211117204323435"></p>
<h2 id="逐像素光照-per-pixel"><a href="#逐像素光照-per-pixel" class="headerlink" title="逐像素光照 per-pixel"></a>逐像素光照 per-pixel</h2><p>据说phong被应用之后，高光部分会边缘不够圆滑。这是因为光照模型的计算一直是逐顶点光照。</p>
<p>逐顶点光照，就是在顶点着色器中计算光照颜色。GPU在对顶点进行光照计算后，得到颜色，然后通过顶点在多边形上所占的范围对像素颜色进行线性插值。</p>
<p>细分较低（多边形数量少）的模型，就会棱角分明，高光也不理想。</p>
<p>那么逐像素光照per-pixel就是在像素着色器（也就是片段着色器）进行着色的。计算不再基于顶点，而是像素，计算量增大。</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">    SubShader</span><br><span class="line">    &#123;</span><br><span class="line">        Pass</span><br><span class="line">        &#123;</span><br><span class="line">            CGPROGRAM</span><br><span class="line">            ......</span><br><span class="line"></span><br><span class="line">            struct v2f</span><br><span class="line">            &#123;</span><br><span class="line">                float4 pos : SV_POSITION;</span><br><span class="line">                float3 normal:TEXCOORD0;</span><br><span class="line">                float4 vertex:TEXCOORD1;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            fixed4 _MainColor;</span><br><span class="line">            fixed4 _SpecularColor;</span><br><span class="line">            half _Shininess;</span><br><span class="line"></span><br><span class="line">            v2f vert (appdata_base v)</span><br><span class="line">            &#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                o.pos =UnityObjectToClipPos(v.vertex);  </span><br><span class="line">                o.normal =v.normal;</span><br><span class="line">                o.vertex =v.vertex;</span><br><span class="line">                <span class="keyword">return</span> o;   </span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            fixed4 frag (v2f i) : SV_Target</span><br><span class="line">            &#123;</span><br><span class="line">                float3 n=UnityObjectToWorldNormal(i.normal);</span><br><span class="line">                n=<span class="built_in">normalize</span>(n);</span><br><span class="line">                fixed3 l=<span class="built_in">normalize</span>(_WorldSpaceLightPos0.xyz);</span><br><span class="line">                fixed3 view=<span class="built_in">normalize</span>(WorldSpaceViewDir(v.vertex));</span><br><span class="line"></span><br><span class="line">                <span class="comment">//按照公式计算漫反射s</span></span><br><span class="line">                fixed ndotl =<span class="built_in">dot</span>(n,l);</span><br><span class="line">                fixed4 dif =_LightColor0*_MainColor*saturate(ndotl);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//镜面反射部分</span></span><br><span class="line">                float3 ref=<span class="built_in">reflect</span>(-l,n);</span><br><span class="line">                ref=<span class="built_in">normalize</span>(ref);</span><br><span class="line">                fixed rdotv=saturate(<span class="built_in">dot</span>(ref,view));</span><br><span class="line">                fixed4 spec=_LightColor0*_SpecularColor*<span class="built_in">pow</span>(rdotv,_Shininess);</span><br><span class="line">                <span class="comment">//return    </span></span><br><span class="line">                <span class="keyword">return</span> unity_AmbientSky+dif+spec;</span><br><span class="line">            &#125;</span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="comment">//其实就是移过去了</span></span><br></pre></td></tr></table></figure>

<p><img src="/2021/11/17/Unity-shader2/image-20211118181116607.png" alt="per-vertex"></p>
<p><img src="/2021/11/17/Unity-shader2/image-20211118181228268.png" alt="per-pixel"></p>
<p>你能看出区别吗？（我不能）</p>
<hr>
<h2 id="Blinn-Phong光照模型"><a href="#Blinn-Phong光照模型" class="headerlink" title="Blinn-Phong光照模型"></a>Blinn-Phong光照模型</h2><p>与phong相比，将计算镜面反射光线的r（即入射光线的反射光线）替换成了入射光线和摄像机视角v的角平分线方向h。<br>$$<br>h=normalize(l,v)<br>$$</p>
<p>$$<br>C_Specular=(C_light·M_specular)saturate(v·h)^Mshininess<br>$$</p>
<p>其优点在于，在摄像机和光源都离物体无限远的时候，h只取决于俩者方向，可被视为常量，减少计算量。而phong则要根据表面曲率逐个计算反射向量r，效率低。</p>
<p>但在查阅资料后发现，phong还有一个很大的问题:<img src="/2021/11/17/Unity-shader2/92f4f5f9b284a56a0ee6e7f7235fb985.png" alt="两种模型的效果图2，此处可以发现Phong模型的一个问题"></p>
<p>“第二张效果图中，我们可以发现Phong模型在一些情况下会导致显示效果不平滑。当反射光与视线的夹角大于90度时，由于在实际渲染时余弦值总是被限制在[0,1]，在这些地方上高光项没有任何贡献。当物体的反光度非常小时，高光半径就会非常大，在反射角与视线夹角为90度的区域附近就会出现很明显的断层现象。而由于半角向量与法线夹角总不大于90度，使用Blinn-Phong模型时断层现象不会发生。”<img src="/2021/11/17/Unity-shader2/6a29e48cee2d8eee77eeddb6b49f22aa-16372315719662.png" alt="效果图2的断层问题的产生原因示意图"></p>
<hr>
<h2 id="灯光阴影"><a href="#灯光阴影" class="headerlink" title="灯光阴影"></a>灯光阴影</h2><h3 id="渲染路径"><a href="#渲染路径" class="headerlink" title="渲染路径"></a>渲染路径</h3><h4 id="延迟着色渲染"><a href="#延迟着色渲染" class="headerlink" title="延迟着色渲染"></a>延迟着色渲染</h4><p>较强，需要设备支持，所有灯光可以逐像素渲染</p>
<h4 id="前向渲染"><a href="#前向渲染" class="headerlink" title="前向渲染"></a>前向渲染</h4><p>传统的渲染方式，支持所有unity图形，兼容性好。</p>
<p>默认4个逐像素灯光（渲染模式为Important，如果不够4个，比较亮的灯光会逐像素渲染），4个逐顶点灯光，其他的都是SH渲染（Spherical Harmonics 球谐 球面调和）。SH渲染很快，只消耗较少cpu，几乎无gpu。</p>
<h3 id="Pass里面的标签"><a href="#Pass里面的标签" class="headerlink" title="Pass里面的标签"></a>Pass里面的标签</h3><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Pass&#123;</span><br><span class="line">	Tags&#123;</span><br><span class="line">	&quot;LightMode&quot; = &quot;ForwardBase&quot; </span><br><span class="line">        &quot;PassFlags&quot; = &quot;xxxx&quot;</span><br><span class="line">	<span class="comment">//定义该Pass在Unity的流水线中的角色 (只有定义它才能获取到一些Unity内置的光照变量如_LightColor0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="内置的-multi-compile-多重编译指令"><a href="#内置的-multi-compile-多重编译指令" class="headerlink" title="内置的 multi_compile 多重编译指令"></a>内置的 multi_compile 多重编译指令</h3><p>#pragma multi_compile_fwdbase是unity内置的用于前向渲染的关键字快捷方式，它包含了前向渲染光照计算需要的大多数关键字，因此会被shader带来很多的变体。</p>
<h3 id="实现阴影-投影-效果"><a href="#实现阴影-投影-效果" class="headerlink" title="实现阴影(投影)效果"></a>实现阴影(投影)效果</h3><p>案例使用Lambert光照模型，不计算镜面反射。按照前向渲染的光照标准进行，分为俩个pass。</p>
<p>基础pass用于渲染平行光和逐顶点或者SH灯光，并为平行光产生阴影投影。</p>
<p>额外pass用于逐像素，也为逐像素灯光产生阴影投影。</p>
<p><img src="/2021/11/17/Unity-shader2/image-20211118193048793.png" alt="image-20211118193048793"></p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br></pre></td><td class="code"><pre><span class="line">Shader &quot;Hidden/<span class="number">5</span>_LambertWithShadow&quot;</span><br><span class="line">&#123;</span><br><span class="line">    Properties</span><br><span class="line">    &#123;</span><br><span class="line">        _MainColor (&quot;Main Color&quot;, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    SubShader</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// -------- 基础Pass 为主要平行光产生投影 --------</span></span><br><span class="line">        Pass</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 添加Pass标签</span></span><br><span class="line">            Tags&#123;&quot;LightMode&quot; = &quot;ForwardBase&quot;&#125;</span><br><span class="line"></span><br><span class="line">            CGPROGRAM</span><br><span class="line">            <span class="meta">#pragma vertex vert</span></span><br><span class="line">            <span class="meta">#pragma fragment frag</span></span><br><span class="line">            <span class="meta">#pragma multi_compile_fwdbase</span></span><br><span class="line">            <span class="meta">#include &quot;UnityCG.cginc&quot;</span></span><br><span class="line">            <span class="meta">#include &quot;Lighting.cginc&quot;</span></span><br><span class="line">            <span class="meta">#include &quot;AutoLight.cginc&quot;</span></span><br><span class="line"></span><br><span class="line">            struct v2f</span><br><span class="line">            &#123;</span><br><span class="line">                float4 pos : SV_POSITION;</span><br><span class="line">                float3 normal : TEXCOORD0;</span><br><span class="line">                float4 vertex : TEXCOORD1;</span><br><span class="line">                SHADOW_COORDS(<span class="number">2</span>) <span class="comment">// 使用预定义宏保存阴影坐标</span></span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            fixed4 _MainColor;</span><br><span class="line"></span><br><span class="line">            v2f vert (appdata_base v)</span><br><span class="line">            &#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">                o.normal = v.normal;</span><br><span class="line">                o.vertex = v.vertex;</span><br><span class="line">                TRANSFER_SHADOW(o) <span class="comment">// 使用预定义宏变换阴影坐标</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            fixed4 frag (v2f i) : SV_Target</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 准备变量</span></span><br><span class="line">                float3 n = UnityObjectToWorldNormal(i.normal);</span><br><span class="line">                n = <span class="built_in">normalize</span>(n);</span><br><span class="line">                float3 l = WorldSpaceLightDir(i.vertex);</span><br><span class="line">                l = <span class="built_in">normalize</span>(l);</span><br><span class="line">                float4 worldPos = mul(unity_ObjectToWorld, i.vertex);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Lambert光照</span></span><br><span class="line">                fixed ndotl = saturate(<span class="built_in">dot</span>(n, l));</span><br><span class="line">                fixed4 color = _LightColor0 * _MainColor * ndotl;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 加上4个点光源的光照</span></span><br><span class="line">                color.rgb += Shade4PointLights(</span><br><span class="line">                unity_4LightPosX0, unity_4LightPosY0, unity_4LightPosZ0,</span><br><span class="line">                unity_LightColor[<span class="number">0</span>].rgb, unity_LightColor[<span class="number">1</span>].rgb,</span><br><span class="line">                unity_LightColor[<span class="number">2</span>].rgb, unity_LightColor[<span class="number">3</span>].rgb,</span><br><span class="line">                unity_4LightAtten0, worldPos.rgb, n) * _MainColor;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 加上环境光照</span></span><br><span class="line">                color += unity_AmbientSky;		<span class="comment">//区别仅仅在这？</span></span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 使用预定义宏计算阴影系数</span></span><br><span class="line">                UNITY_LIGHT_ATTENUATION(shadowmask, i, worldPos.rgb)</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 阴影合成</span></span><br><span class="line">                color.rgb *= shadowmask;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> color;</span><br><span class="line">            &#125;</span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// -------- 额外的Pass 为其他逐像素的灯光产生投影 --------</span></span><br><span class="line">        Pass</span><br><span class="line">        &#123;</span><br><span class="line">            Tags&#123;&quot;LightMode&quot; = &quot;ForwardAdd&quot;&#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 使用相加混合，使绘制的图像与上一个Pass完全混合</span></span><br><span class="line">            Blend One One</span><br><span class="line"></span><br><span class="line">            CGPROGRAM</span><br><span class="line">            <span class="meta">#pragma vertex vert</span></span><br><span class="line">            <span class="meta">#pragma fragment frag</span></span><br><span class="line">            <span class="meta">#pragma multi_compile_fwdadd_fullshadows</span></span><br><span class="line">            <span class="meta">#include &quot;UnityCG.cginc&quot;</span></span><br><span class="line">            <span class="meta">#include &quot;Lighting.cginc&quot;</span></span><br><span class="line">            <span class="meta">#include &quot;AutoLight.cginc&quot;</span></span><br><span class="line"></span><br><span class="line">            struct v2f</span><br><span class="line">            &#123;</span><br><span class="line">                float4 pos : SV_POSITION;</span><br><span class="line">                float3 normal : TEXCOORD0;</span><br><span class="line">                float4 vertex : TEXCOORD1;</span><br><span class="line">                SHADOW_COORDS(<span class="number">2</span>) <span class="comment">// 使用预定义宏保存阴影坐标</span></span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            fixed4 _MainColor;</span><br><span class="line"></span><br><span class="line">            v2f vert (appdata_base v)</span><br><span class="line">            &#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">                o.normal = v.normal;</span><br><span class="line">                o.vertex = v.vertex;</span><br><span class="line">                TRANSFER_SHADOW(o) <span class="comment">// 使用预定义宏变换阴影坐标</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            fixed4 frag (v2f i) : SV_Target</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 准备变量</span></span><br><span class="line">                float3 n = UnityObjectToWorldNormal(i.normal);</span><br><span class="line">                n = <span class="built_in">normalize</span>(n);</span><br><span class="line">                float3 l = WorldSpaceLightDir(i.vertex);</span><br><span class="line">                l = <span class="built_in">normalize</span>(l);</span><br><span class="line">                float4 worldPos = mul(unity_ObjectToWorld, i.vertex);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Lambert光照</span></span><br><span class="line">                fixed ndotl = saturate(<span class="built_in">dot</span>(n, l));</span><br><span class="line">                fixed4 color = _LightColor0 * _MainColor * ndotl;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 加上4个点光源的光照</span></span><br><span class="line">                color.rgb += Shade4PointLights(</span><br><span class="line">                unity_4LightPosX0, unity_4LightPosY0, unity_4LightPosZ0,</span><br><span class="line">                unity_LightColor[<span class="number">0</span>].rgb, unity_LightColor[<span class="number">1</span>].rgb,</span><br><span class="line">                unity_LightColor[<span class="number">2</span>].rgb, unity_LightColor[<span class="number">3</span>].rgb,</span><br><span class="line">                unity_4LightAtten0, worldPos.rgb, n) * _MainColor;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 使用预定义宏计算阴影系数</span></span><br><span class="line">                UNITY_LIGHT_ATTENUATION(shadowmask, i, worldPos.rgb)</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 阴影合成</span></span><br><span class="line">                color.rgb *= shadowmask;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> color;</span><br><span class="line">            &#125;</span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    FallBack &quot;Diffuse&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有一说一，没有很看懂…………</p>
<p>[TOC]</p>
<p>Thanks：</p>
<p><a target="_blank" rel="noopener" href="https://www.pianshen.com/article/18651304807/">https://www.pianshen.com/article/18651304807/</a></p>
<p>【GDC2008】Stupid Spherical Harmonics (SH) Tricks:<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/a379b4c6d346">https://www.jianshu.com/p/a379b4c6d346</a></p>
<p>聊一下球谐函数（Spherical Harmonics）计算光照:<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/34059900">https://zhuanlan.zhihu.com/p/34059900</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/sifenkesi/p/9942272.html">https://www.cnblogs.com/sifenkesi/p/9942272.html</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/11/16/Unity-shader/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/head.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="旋转公寓的阁楼">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/11/16/Unity-shader/" itemprop="url">Unity_shader</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-11-16T10:58:37+08:00">
                2021-11-16
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于&#58;</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2021-11-19T14:04:05+08:00">
                2021-11-19
              </time>
            
          </span>

          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  2.3k
                </span>
              

              

              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><h2 id="空间投影变换"><a href="#空间投影变换" class="headerlink" title="空间投影变换"></a>空间投影变换</h2><p>在学习shader之前，先学习空间变化把</p>
<h3 id="模型空间ModelSpace"><a href="#模型空间ModelSpace" class="headerlink" title="模型空间ModelSpace"></a>模型空间ModelSpace</h3><p>指物体自身的坐标？以模型pivot为中心，而pivot在世界坐标中就是物体的位置</p>
<h3 id="世界坐标World"><a href="#世界坐标World" class="headerlink" title="世界坐标World"></a>世界坐标World</h3><p>指相对的坐标。通过模型变换得到</p>
<h3 id="摄像机空间"><a href="#摄像机空间" class="headerlink" title="摄像机空间"></a>摄像机空间</h3><p>摄像机朝向为z轴，上y右x（为什么与opengl的完全不同？）通过上者视变换而得到</p>
<h3 id="裁切空间clip"><a href="#裁切空间clip" class="headerlink" title="裁切空间clip"></a>裁切空间clip</h3><p>通过投影变换而得到</p>
<h3 id="屏幕空间"><a href="#屏幕空间" class="headerlink" title="屏幕空间"></a>屏幕空间</h3><p>通过屏幕投影而得到</p>
<h2 id="现代gpu渲染流水线"><a href="#现代gpu渲染流水线" class="headerlink" title="现代gpu渲染流水线"></a>现代gpu渲染流水线</h2><p><img src="/2021/11/16/Unity-shader/image-20211117135949050.png" alt="image-20211117135949050"></p>
<h2 id="Shader概念"><a href="#Shader概念" class="headerlink" title="Shader概念"></a>Shader概念</h2><p>shader是渲染流水线的一部分，由顶点着色器和片段着色器构成（着色器(Shader)是运行在GPU上的小程序。这些小程序为图形渲染管线的某个特定部分而运行。从基本意义上来说，着色器只是一种把输入转化为输出的程序。着色器也是一种非常独立的程序，因为它们之间不能相互通信；它们之间唯一的沟通只有通过输入和输出。）</p>
<p>unity用cg编写，OpenGL用glsl，direct3d用hlsl。unity基于hlsl产生的cg。</p>
<h2 id="shaderlab语法基础"><a href="#shaderlab语法基础" class="headerlink" title="shaderlab语法基础"></a>shaderlab语法基础</h2><p>shader结构为：properties subshader fallback</p>
<p>如果是顶点片段着色器，里面还会包含pass{}</p>
<h3 id="properties"><a href="#properties" class="headerlink" title="properties"></a>properties</h3><p>开放出来的变量，可以在控制面板中调节</p>
<p>properties主要分为三大类：数值 颜色与向量 纹理贴图</p>
<p>每条属性的语法如下：</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">_Name(&quot;Display Name&quot;,type) = defaultValue[&#123;options&#125;]</span><br><span class="line"><span class="comment">//属性名字（“显示的名字”，属性的类型）=将shader指定给材质时初始化的默认值</span></span><br></pre></td></tr></table></figure>

<h4 id="数值类properties"><a href="#数值类properties" class="headerlink" title="数值类properties"></a>数值类properties</h4><p>基本都是float，有以下俩种</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">name(&quot;display name&quot;,Float)=number</span><br><span class="line">name(&quot;display name&quot;, Range(min,max))=number</span><br></pre></td></tr></table></figure>

<h4 id="颜色和向量类properties"><a href="#颜色和向量类properties" class="headerlink" title="颜色和向量类properties"></a>颜色和向量类properties</h4><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">name(&quot;display name&quot;, Color)=(number,number,number,number)<span class="comment">//RGBA</span></span><br><span class="line">name(&quot;display name&quot;, Vector)=(number1,number2,number3,number4)</span><br></pre></td></tr></table></figure>

<h4 id="纹理贴图类"><a href="#纹理贴图类" class="headerlink" title="纹理贴图类"></a>纹理贴图类</h4><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">name(&quot;display name&quot;, <span class="number">2</span>D)=&quot;defaulttexture&quot;&#123;&#125;</span><br><span class="line">name(&quot;display name&quot;, Cube)=&quot;defaulttexture&quot;&#123;&#125;</span><br><span class="line">name(&quot;display name&quot;, <span class="number">3</span>D)=&quot;defaulttexture&quot;&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>2D最常使用，例如漫反射贴图，法线贴图。其defaulttexture可以用各种颜色 black red</p>
<p>Cube全称CubeMapTexture立方体纹理，由六张有联系的2D贴图拼成的立方体，主要用于反射，例如Skybox和ReflectionProb</p>
<p><img src="/2021/11/16/Unity-shader/image-20211117142854328.png" alt="image-20211117142854328"></p>
<p><img src="/2021/11/16/Unity-shader/image-20211117142915137.png" alt="image-20211117142915137"></p>
<h3 id="SubShader"><a href="#SubShader" class="headerlink" title="SubShader"></a>SubShader</h3><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">SubShader</span><br><span class="line">    &#123;</span><br><span class="line">    	Tags &#123; &quot;RenderType&quot;=&quot;Opaque&quot; &#125;</span><br><span class="line">        <span class="comment">//渲染状况</span></span><br><span class="line">        cull back</span><br><span class="line">    	LOD <span class="number">200</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//1:LOD Level of Detail, 根据LOD来设置使用不同版本的Shader;</span></span><br><span class="line"><span class="comment">//2:着色器中给SubShader一个LOD值，程序来设置这个shader的LOD值，只有第一个小于等于LOD值subShader才会被执行;</span></span><br><span class="line"><span class="comment">//3: 每个shader最多只会有一个SubShader被使用;</span></span><br><span class="line">    	</span><br><span class="line">        Pass</span><br><span class="line">        &#123;</span><br><span class="line">            CGPROGRAM</span><br><span class="line">            ...</span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">FallBack &quot;Diffuse&quot;</span><br></pre></td></tr></table></figure>

<h4 id="tags"><a href="#tags" class="headerlink" title="tags"></a>tags</h4><h5 id="渲染队列"><a href="#渲染队列" class="headerlink" title="渲染队列"></a>渲染队列</h5><p>可以用Tags{“Quene”=”Geometry+1”}来指定队列，unity有五种指定的队列。当然也可以在材质面板中选择<img src="/2021/11/16/Unity-shader/image-20211117143648273.png" alt="image-20211117143648273"></p>
<h5 id="渲染类型"><a href="#渲染类型" class="headerlink" title="渲染类型"></a>渲染类型</h5><p>RenderType可以进行划分，便于替换深度纹理</p>
<p>比如 Tags { “RenderType”=”Opaque” } 普通shader。再比如Transparent为半透明等等等等</p>
<h5 id="禁用批处理"><a href="#禁用批处理" class="headerlink" title="禁用批处理"></a>禁用批处理</h5><p>DisableBatching，使用批处理时，几何体可能被变换到世界空间，模型空间被丢弃，这会导致用模型空间顶点坐标的shader出问题。</p>
<h5 id="等等等等"><a href="#等等等等" class="headerlink" title="等等等等"></a>等等等等</h5><p>请看<a target="_blank" rel="noopener" href="https://docs.unity3d.com/cn/current/Manual/SL-SubShaderTags.html">https://docs.unity3d.com/cn/current/Manual/SL-SubShaderTags.html</a> 但我觉得很难看懂</p>
<h4 id="Pass的渲染状况"><a href="#Pass的渲染状况" class="headerlink" title="Pass的渲染状况"></a>Pass的渲染状况</h4><p>例如Cull Back 设置多边形背面剔除等等</p>
<h4 id="Fallback"><a href="#Fallback" class="headerlink" title="Fallback"></a>Fallback</h4><p>在所有subShader之后定义，如果所有subshader都无法运行，就运行fallback定义的shader，常见unity内置的diffuse</p>
<h1 id="顶点-片段着色器基础"><a href="#顶点-片段着色器基础" class="headerlink" title="顶点-片段着色器基础"></a>顶点-片段着色器基础</h1><p>unity里shader有俩种用途：1.给材质用于渲染 2.给脚本用于图像处理</p>
<h2 id="CG语法"><a href="#CG语法" class="headerlink" title="CG语法"></a>CG语法</h2><p>unity的shader中，shaderlab只是组织代码结构，真正渲染部分是cg语言编写的。cg程序片段通过指令嵌入在pass中，夹在 CGPROGRAM和 ENDCG之中。</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Pass</span><br><span class="line">       &#123;</span><br><span class="line">           CGPROGRAM</span><br><span class="line">           <span class="meta">#pragma vertex vert		//编译指令</span></span><br><span class="line">           <span class="meta">#pragma fragment frag</span></span><br><span class="line">           <span class="comment">//CG_code</span></span><br><span class="line">           ENDCG</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>

<h3 id="编译指令"><a href="#编译指令" class="headerlink" title="编译指令"></a>编译指令</h3><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#pragma vertex vert	//定义顶点着色器名字</span></span><br><span class="line"><span class="meta">#pragma fragment frag//定义片段着色器名字</span></span><br><span class="line"><span class="meta">#pragma target name //定义shader编译的目标级别，默认2.5</span></span><br></pre></td></tr></table></figure>

<p>当然其他还有很多，上网看看吧，用到就知道了</p>
<h3 id="着色器函数"><a href="#着色器函数" class="headerlink" title="着色器函数"></a>着色器函数</h3><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">struct appdata</span><br><span class="line">        &#123;</span><br><span class="line">            float4 vertex : POSITION; <span class="comment">// vertex position</span></span><br><span class="line">            float2 uv : TEXCOORD0; <span class="comment">// texture coordinate</span></span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// vertex shader outputs (&quot;vertex to fragment&quot;)</span></span><br><span class="line">        struct v2f</span><br><span class="line">        &#123;</span><br><span class="line">            float2 uv : TEXCOORD0; <span class="comment">// texture coordinate</span></span><br><span class="line">            float4 vertex : SV_POSITION; <span class="comment">// clip space position</span></span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// vertex shader</span></span><br><span class="line">        v2f vert (appdata v)</span><br><span class="line">        &#123;</span><br><span class="line">            v2f o;</span><br><span class="line">            o.vertex = UnityObjectToClipPos(v.vertex);</span><br><span class="line">            <span class="comment">//******看解释</span></span><br><span class="line">            o.uv = v.uv;</span><br><span class="line">            <span class="keyword">return</span> o;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">sampler2D</span> _MainTex;</span><br><span class="line"></span><br><span class="line">        fixed4 frag (v2f i) : SV_Target</span><br><span class="line">        &#123;</span><br><span class="line">            fixed4 col = tex2D(_MainTex, i.uv);</span><br><span class="line">            <span class="keyword">return</span> col;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>在vert()中，有UnityObjectToClipPos()，这是unity内置空间变换函数，把模型空间坐标转换成裁剪空间坐标，然后输出。</p>
<h3 id="语义"><a href="#语义" class="headerlink" title="语义"></a>语义</h3><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">### 为什么参数后面有这样一个冒号呢，后面跟着全大写的关键词</span></span><br><span class="line"></span><br><span class="line">fixed4 frag (v2f i) : SV_Target&#123;&#125;</span><br><span class="line"></span><br><span class="line">v2f vert (float4 vertex : POSITION, float3 normal : NORMAL)&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>用cg编写时，需要参数填充语义来表达要传递的数据信息。</p>
<h4 id="顶点着色器的输入语义"><a href="#顶点着色器的输入语义" class="headerlink" title="顶点着色器的输入语义"></a>顶点着色器的输入语义</h4><p>POSITION, 顶点的坐标信息</p>
<p>NORMAL,    顶点的法线信息</p>
<p>TEXCOORD0,TEXCOORD1,TEXCOORD2,TEXCOORD3,    模型的第几套uv坐标</p>
<p>TANGENT,    顶点的切向量</p>
<p>COLOR    顶点的颜色坐标</p>
<h4 id="顶点着色器的输出-和-片段着色器的输入语义"><a href="#顶点着色器的输出-和-片段着色器的输入语义" class="headerlink" title="顶点着色器的输出 和 片段着色器的输入语义"></a>顶点着色器的输出 和 片段着色器的输入语义</h4><p>顶点着色器的主要任务就是输出顶点坐标在裁切空间的坐标，这样gpu才知道顶点在屏幕上的栅格化位置和深度值。</p>
<p>SV_POSITION,    顶点在裁切空间的坐标 f4</p>
<p>COLOR0,COLOR1,    低精度数据，例如顶点颜色</p>
<p>TEXCOORD0-7    </p>
<h4 id="片段着色器输出语义"><a href="#片段着色器输出语义" class="headerlink" title="片段着色器输出语义"></a>片段着色器输出语义</h4><p>只会输出一个fixed4类型的颜色信息，输出的值会存到渲染目标中，因此只有一个SV_TARGET语义</p>
<h3 id="在CG中调用属性变量"><a href="#在CG中调用属性变量" class="headerlink" title="在CG中调用属性变量"></a>在CG中调用属性变量</h3><p>如果在properties中定义开放的属性，想要在shader中访问，需要在CG块中再次声明。</p>
<p><img src="/2021/11/16/Unity-shader/image-20211117152005645.png" alt="image-20211117152005645"></p>
<p>可以看到，纹理贴图类的前面要加入sampler2D/Cube/3D</p>
<p>Color或者vector要用half4，或者float4，fixed4，其中颜色最好使用fixed4(节约性能)</p>
<p>其他就普通咯</p>
<h4 id="在shader中使用贴图"><a href="#在shader中使用贴图" class="headerlink" title="在shader中使用贴图"></a>在shader中使用贴图</h4><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Properties</span><br><span class="line">   &#123;</span><br><span class="line">       _MainTex (&quot;Albedo (RGB)&quot;, <span class="number">2</span>D) = &quot;white&quot; &#123;&#125;</span><br><span class="line">   &#125;</span><br><span class="line">    SubShader</span><br><span class="line">   &#123;</span><br><span class="line">  		...</span><br><span class="line">  		<span class="type">sampler2D</span> _MainTex;</span><br><span class="line">  		float4 _MainTex_ST;<span class="comment">//在cg中定义的平铺偏移变量</span></span><br><span class="line">  		..</span><br><span class="line">  	&#125;	<span class="comment">//好像写的很复杂，现在好像不需要了</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">       <span class="comment">//Scale &amp; Transform 首字母，表示UV的缩放和平移 xy代表Tilling的xy值，zw代表Offset的xy值</span></span><br></pre></td></tr></table></figure>

<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对不起我错了，在shader中有一个叫做Unlit Shader，就是按这个语法来写的</span></span><br><span class="line">Shader &quot;Unlit/<span class="number">333</span>&quot;</span><br><span class="line">&#123;</span><br><span class="line">    Properties</span><br><span class="line">    &#123;</span><br><span class="line">        _MainTex (&quot;Texture&quot;, <span class="number">2</span>D) = &quot;white&quot; &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    SubShader</span><br><span class="line">    &#123;</span><br><span class="line">        Tags &#123; &quot;RenderType&quot;=&quot;Opaque&quot; &#125;</span><br><span class="line">        LOD <span class="number">100</span></span><br><span class="line"></span><br><span class="line">        Pass</span><br><span class="line">        &#123;</span><br><span class="line">            CGPROGRAM</span><br><span class="line">            <span class="meta">#pragma vertex vert</span></span><br><span class="line">            <span class="meta">#pragma fragment frag</span></span><br><span class="line">            <span class="comment">// make fog work</span></span><br><span class="line">            <span class="meta">#pragma multi_compile_fog</span></span><br><span class="line"></span><br><span class="line">            <span class="meta">#include &quot;UnityCG.cginc&quot;</span></span><br><span class="line"></span><br><span class="line">            struct appdata</span><br><span class="line">            &#123;</span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                float2 uv : TEXCOORD0;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            struct v2f</span><br><span class="line">            &#123;</span><br><span class="line">                float2 uv : TEXCOORD0;</span><br><span class="line">                UNITY_FOG_COORDS(<span class="number">1</span>)</span><br><span class="line">                float4 vertex : SV_POSITION;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="type">sampler2D</span> _MainTex;</span><br><span class="line">            float4 _MainTex_ST;</span><br><span class="line"></span><br><span class="line">            v2f vert (appdata v)</span><br><span class="line">            &#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                o.vertex = UnityObjectToClipPos(v.vertex);</span><br><span class="line">                o.uv = TRANSFORM_TEX(v.uv, _MainTex);</span><br><span class="line">                UNITY_TRANSFER_FOG(o,o.vertex);</span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            fixed4 frag (v2f i) : SV_Target</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// sample the texture</span></span><br><span class="line">                fixed4 col = tex2D(_MainTex, i.uv);</span><br><span class="line">                <span class="comment">// apply fog</span></span><br><span class="line">                UNITY_APPLY_FOG(i.fogCoord, col);</span><br><span class="line">                <span class="keyword">return</span> col;</span><br><span class="line">            &#125;</span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="在Unity中使用立方体贴图"><a href="#在Unity中使用立方体贴图" class="headerlink" title="在Unity中使用立方体贴图"></a>在Unity中使用立方体贴图</h4><p>没必要写</p>
<h1 id="Unity包含文件"><a href="#Unity包含文件" class="headerlink" title="Unity包含文件"></a>Unity包含文件</h1><p>在cg代码块中#include即可</p>
<h2 id="UnityCG-cginc"><a href="#UnityCG-cginc" class="headerlink" title="UnityCG.cginc"></a>UnityCG.cginc</h2><h3 id="顶点着色器输入结构体"><a href="#顶点着色器输入结构体" class="headerlink" title="顶点着色器输入结构体"></a>顶点着色器输入结构体</h3><p>appdata_base     顶点坐标，顶点法线，第一组纹理坐标<br>appdata_tan        顶点坐标，顶点切线，顶点法线，第一组纹理坐标<br>appdata_full        顶点坐标，顶点切线，顶点法线，四组（或更多）纹理坐标<br>appdata_img       顶点坐标，第一组纹理坐标<br>v2f_img：             裁剪空间中的位置，纹理坐标</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">struct appdata_base &#123;</span><br><span class="line">    float4 vertex : POSITION;</span><br><span class="line">    float3 normal : NORMAL;</span><br><span class="line">    float4 texcoord : TEXCOORD0;</span><br><span class="line">    UNITY_VERTEX_INPUT_INSTANCE_ID</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct appdata_tan &#123;</span><br><span class="line">    float4 vertex : POSITION;</span><br><span class="line">    float4 tangent : TANGENT;</span><br><span class="line">    float3 normal : NORMAL;</span><br><span class="line">    float4 texcoord : TEXCOORD0;</span><br><span class="line">    UNITY_VERTEX_INPUT_INSTANCE_ID</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct appdata_full &#123;</span><br><span class="line">    float4 vertex : POSITION;</span><br><span class="line">    float4 tangent : TANGENT;</span><br><span class="line">    float3 normal : NORMAL;</span><br><span class="line">    float4 texcoord : TEXCOORD0;</span><br><span class="line">    float4 texcoord1 : TEXCOORD1;</span><br><span class="line">    float4 texcoord2 : TEXCOORD2;</span><br><span class="line">    float4 texcoord3 : TEXCOORD3;</span><br><span class="line">    fixed4 color : COLOR;</span><br><span class="line">    UNITY_VERTEX_INPUT_INSTANCE_ID</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct appdata_img</span><br><span class="line">&#123;</span><br><span class="line">    float4 vertex : POSITION;</span><br><span class="line">    half2 texcoord : TEXCOORD0;</span><br><span class="line">    UNITY_VERTEX_INPUT_INSTANCE_ID</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct v2f_img</span><br><span class="line">&#123;</span><br><span class="line">    float4 pos : SV_POSITION;</span><br><span class="line">    half2 uv : TEXCOORD0;</span><br><span class="line">    UNITY_VERTEX_INPUT_INSTANCE_ID</span><br><span class="line">    UNITY_VERTEX_OUTPUT_STEREO</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="各种帮助函数"><a href="#各种帮助函数" class="headerlink" title="各种帮助函数"></a>各种帮助函数</h3><h4 id="顶点变换函数"><a href="#顶点变换函数" class="headerlink" title="顶点变换函数"></a>顶点变换函数</h4><p>float4 WorldSpaceViewDir(float4 v)            输入一个模型空间中的顶点位置，返回世界空间中从该点到摄像机的观察方向<br>float4 UnityWorldSpaceViewDir(float4 v)            输入一个世界空间中的顶点位置，返回世界空间中从该点到摄像机的观察方向<br>float4 ObjSpaceViewDir(float4 v)            输入一个模型空间中的顶点位置，返回模型空间中从该店到摄像机的观察方向</p>
<h4 id="灯光辅助函数"><a href="#灯光辅助函数" class="headerlink" title="灯光辅助函数"></a>灯光辅助函数</h4><p>float4 WorldSpace LightDir(flaot4 v)            仅用于向前渲染。 输入一个模型空间中的顶点位置，返回世界空间中从该点到光源的光照方向。没有被归一化<br>float4 ObjectSpaceLightDir(float4 v)            仅用于向前渲染中，输入一个模型空间中的顶点位置， 返回模型空间中从该点到光源的光照方向。没有被归一化<br>float4 UnityWorldSpaceLightDir(float4 v)            仅用于向前渲染中，输入一个世界空间中的顶点位置， 返回世界空间中从该点到光源的光照方向。没有被归一化</p>
<h4 id="向量变换函数"><a href="#向量变换函数" class="headerlink" title="向量变换函数"></a>向量变换函数</h4><p>float3 UnityObjectToWorldNormal(float3 norm)            把法线方向从模型空间中转换到世界空间中<br>float3 UnityObjectToWorldDir(float3 dir)            把方向矢量从模型空间中变换到世界空间中<br>float3 Unity WorldToObjectDir(float3 dir)            把方向矢量从世界空间变换到模型空间中</p>
<h2 id="UnityShaderVariable-cginc"><a href="#UnityShaderVariable-cginc" class="headerlink" title="UnityShaderVariable.cginc"></a>UnityShaderVariable.cginc</h2><p>…….随便都可以</p>
<p>[TOC]</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/11/12/OpenGL-%E4%B8%B4%E6%97%B6%E7%AC%94-%E9%94%AE%E7%9B%98-%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/head.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="旋转公寓的阁楼">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/11/12/OpenGL-%E4%B8%B4%E6%97%B6%E7%AC%94-%E9%94%AE%E7%9B%98-%E8%AE%B0/" itemprop="url">OpenGL-临时笔(键盘)记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-11-12T20:53:59+08:00">
                2021-11-12
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于&#58;</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2021-11-13T10:29:57+08:00">
                2021-11-13
              </time>
            
          </span>

          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  756
                </span>
              

              

              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h5 id="1-清除缓冲区"><a href="#1-清除缓冲区" class="headerlink" title="1.清除缓冲区"></a>1.清除缓冲区</h5><p>glClearColor (0.0, 0.0, 0.0, 0.0);<br>glClearDepth(1.0);<br>glClear (GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT));</p>
<h5 id="2-glFlush"><a href="#2-glFlush" class="headerlink" title="2.glFlush();"></a>2.glFlush();</h5><p>强制客户机发送网络数据包，以免网络传输时，包没填满一直等待。<br>glFinish();强制之前的命令完成执行，执行完了才返回。</p>
<h5 id="3-reshape-int-w-int-h-回调函数"><a href="#3-reshape-int-w-int-h-回调函数" class="headerlink" title="3.reshape(int w,int h)回调函数"></a>3.reshape(int w,int h)回调函数</h5><p>void reshape (int w, int h)<br>{<br>   glViewport (0, 0, (GLsizei) w, (GLsizei) h); //调整整个像素矩形使其填满新窗口<br>   glMatrixMode (GL_PROJECTION);<br>   glLoadIdentity ();<br> //  gluPerspective(60.0, (GLfloat) w/(GLfloat) h, 1.0, 20.0);<br> //  glMatrixMode(GL_MODELVIEW);<br> //  glLoadIdentity();<br> //  gluLookAt (0.0, 0.0, 5.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0);<br>    gluOrtho2D(0.0,(GLdouble)w,0.0,(GLdouble)h);//使左下角0，0，右上角是w，h<br>}</p>
<h5 id="4-opengl的多边形边不能相交，必须是凸多边形-P25"><a href="#4-opengl的多边形边不能相交，必须是凸多边形-P25" class="headerlink" title="4.opengl的多边形边不能相交，必须是凸多边形//P25"></a>4.opengl的多边形边不能相交，必须是凸多边形//P25</h5><h5 id="5-指定顶点用glVertex（）-P27"><a href="#5-指定顶点用glVertex（）-P27" class="headerlink" title="5.指定顶点用glVertex（）//P27"></a>5.指定顶点用glVertex（）//P27</h5><h5 id="6-根据给定的顶点，用图元表示绘制的图形"><a href="#6-根据给定的顶点，用图元表示绘制的图形" class="headerlink" title="6.根据给定的顶点，用图元表示绘制的图形"></a>6.根据给定的顶点，用图元表示绘制的图形</h5><p>glBegin(图元名字);<br>    glVertex2f(0.0,0.0);<br>    ……..<br>    glVertex2f(4.0,4.0);<br>glEnd();<br>各类图元请看p29 当然begin和end之间还可以放glColor之类的；</p>
<h5 id="7-glEnable-打开功能-glIsEnabled-检测，返回GL-TURE"><a href="#7-glEnable-打开功能-glIsEnabled-检测，返回GL-TURE" class="headerlink" title="7.glEnable();打开功能 glIsEnabled();检测，返回GL_TURE"></a>7.glEnable();打开功能 glIsEnabled();检测，返回GL_TURE</h5><h5 id="8-glLineStipple-GLint-factor，Glushort-patern-画线！P34-2-5lines"><a href="#8-glLineStipple-GLint-factor，Glushort-patern-画线！P34-2-5lines" class="headerlink" title="8.glLineStipple(GLint factor，Glushort patern)画线！P34 2_5lines"></a>8.glLineStipple(GLint factor，Glushort patern)画线！P34 2_5lines</h5><p>例：<br> glEnable (GL_LINE_STIPPLE);</p>
<p>glLineStipple (1, 0x0101);  /*  dotted  <em>/<br>drawOneLine (50.0, 125.0, 150.0, 125.0);<br>glLineStipple (1, 0x00FF);  /</em>  dashed  <em>/<br>drawOneLine (150.0, 125.0, 250.0, 125.0);<br>glLineStipple (1, 0x1C47);  /</em>  dash/dot/dash  */<br>drawOneLine (250.0, 125.0, 350.0, 125.0);</p>
<h5 id="9-glPolygonMode-GL-FRONT-AND-BACK-GL-FRONT-GL-BACK-GL-FILL-GL-LINE-GL-POINT"><a href="#9-glPolygonMode-GL-FRONT-AND-BACK-GL-FRONT-GL-BACK-GL-FILL-GL-LINE-GL-POINT" class="headerlink" title="9.glPolygonMode(GL_FRONT_AND_BACK/GL_FRONT/GL_BACK , GL_FILL/GL_LINE/GL_POINT);"></a>9.glPolygonMode(GL_FRONT_AND_BACK/GL_FRONT/GL_BACK , GL_FILL/GL_LINE/GL_POINT);</h5><p>对多边形的不同面进行不同的渲染（gl3.1以上不能不同</p>
<h5 id="10-glPolygonStipple-32-32位的指针"><a href="#10-glPolygonStipple-32-32位的指针" class="headerlink" title="10.glPolygonStipple(32*32位的指针)"></a>10.glPolygonStipple(32*32位的指针)</h5><p>多边形的点画模式，每位的8格，为1就绘制，依次组成画（挺无聊的</p>
<h5 id="11-法线向量"><a href="#11-法线向量" class="headerlink" title="11. 法线向量"></a>11. 法线向量</h5><p>简称法线？！ 是一条垂直于某个表面的方向向量，在曲面上每个点的法线不同。定义了 表面在空间的方向，计算光照很有用。</p>
<p>用glNormal(给的那个向量)定义，和glVertex()一样，用在begin和end之间。</p>
<h5 id="12-顶点数组"><a href="#12-顶点数组" class="headerlink" title="12.顶点数组"></a>12.顶点数组</h5><p>用少量数组指定大量与顶点相关的数据</p>
<h6 id="1-启用数组-glEnableClientState-GL-VERTEX-ARRAY-…-p44"><a href="#1-启用数组-glEnableClientState-GL-VERTEX-ARRAY-…-p44" class="headerlink" title="1.启用数组 glEnableClientState(GL_VERTEX_ARRAY/…)p44"></a>1.启用数组 glEnableClientState(GL_VERTEX_ARRAY/…)p44</h6><p>glDisableClientState();</p>
<h6 id="2-指定数组的数据-glVertexPointer"><a href="#2-指定数组的数据-glVertexPointer" class="headerlink" title="2.指定数组的数据 glVertexPointer(//////)"></a>2.指定数组的数据 glVertexPointer(//////)</h6><p>跨距stride</p>
<h6 id="3-解引用和渲染-glArrayElement（int-ith）"><a href="#3-解引用和渲染-glArrayElement（int-ith）" class="headerlink" title="3.解引用和渲染 glArrayElement（int ith）"></a>3.解引用和渲染 glArrayElement（int ith）</h6><p>glDrawElement（）</p>
<h5 id="13-重启图元-glPrimitiveRestartIndex"><a href="#13-重启图元-glPrimitiveRestartIndex" class="headerlink" title="13.重启图元 glPrimitiveRestartIndex()???"></a>13.重启图元 glPrimitiveRestartIndex()???</h5><p>p51 (因为后面太恶心直接跳到第三章去)</p>
<h4 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h4><h5 id="14-视图变换"><a href="#14-视图变换" class="headerlink" title="14.视图变换"></a>14.视图变换</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   glClear (GL_COLOR_BUFFER_BIT);</span><br><span class="line">   glColor3f (<span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>);</span><br><span class="line">   glLoadIdentity ();             <span class="comment">/* clear the matrix */</span><span class="comment">//如果不设为单位，会与之前的矩阵相乘</span></span><br><span class="line">           <span class="comment">/* viewing transformation  */</span></span><br><span class="line">   gluLookAt (<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">5.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">0.0</span>);<span class="comment">//eye target up</span></span><br><span class="line">    <span class="comment">//默认是原点 z负 up-y正</span></span><br><span class="line">   glScalef (<span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">1.0</span>);      <span class="comment">/* modeling transformation */</span> </span><br><span class="line">   glutWireCube (<span class="number">1.0</span>);</span><br><span class="line">   glFlush ();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="15-对变换进行思考"><a href="#15-对变换进行思考" class="headerlink" title="15.对变换进行思考"></a>15.对变换进行思考</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">glMatrixMode(GL_MODELVIEW);</span><br><span class="line">glLoadIdentity();</span><br><span class="line">glMultMatrixf(N);</span><br><span class="line">glMultMatrixf(M);</span><br><span class="line">glMultMatrixf(L);</span><br><span class="line">glBegin(GL_POINTS);</span><br><span class="line">	glVertex3f(V);		<span class="comment">// 顶点变换是N(M(Lv)) 也就是v先于L相乘，再与M，再与N</span></span><br><span class="line">glEnd();				<span class="comment">//顶点v的变换是相反的顺序进行的！</span></span><br></pre></td></tr></table></figure>

<h6 id="如果根据全局固定的坐标系统"><a href="#如果根据全局固定的坐标系统" class="headerlink" title="如果根据全局固定的坐标系统"></a>如果根据全局固定的坐标系统</h6><p>那必须注意乘法的顺序与出现的顺序相反</p>
<h6 id="反之，我们就要考虑局部移动坐标系统"><a href="#反之，我们就要考虑局部移动坐标系统" class="headerlink" title="反之，我们就要考虑局部移动坐标系统"></a>反之，我们就要考虑局部移动坐标系统</h6><p>想象一个固定到所绘制物体的局部坐标系统，所有操作都相对于这个不断变化的坐标系统进行。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/11/12/OpenGL-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/head.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="旋转公寓的阁楼">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/11/12/OpenGL-1/" itemprop="url">OpenGL_1</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-11-12T19:30:30+08:00">
                2021-11-12
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于&#58;</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2021-11-12T19:42:21+08:00">
                2021-11-12
              </time>
            
          </span>

          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  1.4k
                </span>
              

              

              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <ul>
<li>顶点数组对象：Vertex Array Object，VAO</li>
<li>顶点缓冲对象：Vertex Buffer Object，VBO</li>
<li>索引缓冲对象：Element Buffer Object，EBO或Index Buffer Object，IBO</li>
</ul>
<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>3D坐标转为2D坐标的处理过程是由OpenGL的图形渲染管线（Graphics Pipeline，大多译为管线，实际上指的是一堆原始图形数据途经一个输送管道，期间经过各种变化处理最终出现在屏幕的过程）管理的。图形渲染管线可以被划分为两个主要部分：第一部分把你的3D坐标转换为2D坐标，第二部分是把2D坐标转变为实际的有颜色的像素。</p>
<p>图形渲染管线接受一组3D坐标，然后把它们转变为你屏幕上的有色2D像素输出。图形渲染管线可以被划分为几个阶段，每个阶段将会把前一个阶段的输出作为输入。所有这些阶段都是高度专门化的（它们都有一个特定的函数），并且很容易并行执行。正是由于它们具有并行执行的特性，当今大多数显卡都有成千上万的小处理核心，它们在GPU上为每一个（渲染管线）阶段运行各自的小程序，从而在图形渲染管线中快速处理你的数据。这些小程序叫做着色器(Shader)。</p>
<p>有些着色器允许开发者自己配置，这就允许我们用自己写的着色器来替换默认的。这样我们就可以更细致地控制图形渲染管线中的特定部分了，而且因为它们运行在GPU上，所以它们可以给我们节约宝贵的CPU时间。</p>
<p>图形渲染管线的每个阶段的抽象展示。要注意蓝色部分代表的是我们可以注入自定义的着色器的部分。<img src="/OpenGL-1/pipeline.png" alt="img"></p>
<h4 id="详细解读"><a href="#详细解读" class="headerlink" title="详细解读"></a>详细解读</h4><h5 id="1"><a href="#1" class="headerlink" title="1."></a>1.</h5><p>首先，我们以数组的形式传递3个3D坐标作为图形渲染管线的输入，用来表示一个三角形，这个数组叫做顶点数据(Vertex Data)；假定每个顶点只由一个3D位置和一些颜色值组成的吧。</p>
<h5 id="2"><a href="#2" class="headerlink" title="2."></a>2.</h5><p>图形渲染管线的第一个部分是顶点着色器(Vertex Shader)，它把一个单独的顶点作为输入。顶点着色器主要的目的是把3D坐标转为另一种3D坐标（后面会解释），同时顶点着色器允许我们对顶点属性进行一些基本处理。</p>
<h5 id="3"><a href="#3" class="headerlink" title="3."></a>3.</h5><p>图元装配(Primitive Assembly)阶段将顶点着色器输出的所有顶点作为输入（如果是GL_POINTS，那么就是一个顶点），并所有的点装配成指定图元的形状；本节例子中是一个三角形。</p>
<h5 id="4"><a href="#4" class="headerlink" title="4."></a>4.</h5><p>图元装配阶段的输出会传递给几何着色器(Geometry Shader)。几何着色器把图元形式的一系列顶点的集合作为输入，它可以通过产生新顶点构造出新的（或是其它的）图元来生成其他形状。例子中，它生成了另一个三角形。</p>
<h5 id="5"><a href="#5" class="headerlink" title="5."></a>5.</h5><p>几何着色器的输出会被传入光栅化阶段(Rasterization Stage)，这里它会把图元映射为最终屏幕上相应的像素，生成供片段着色器(Fragment Shader)使用的片段(Fragment)。在片段着色器运行之前会执行裁切(Clipping)。裁切会丢弃超出你的视图以外的所有像素，用来提升执行效率。</p>
<p>“OpenGL中的一个片段是OpenGL渲染一个像素所需的所有数据。”</p>
<h5 id="6"><a href="#6" class="headerlink" title="6."></a>6.</h5><p>片段着色器的主要目的是计算一个像素的最终颜色，这也是所有OpenGL高级效果产生的地方。通常，片段着色器包含3D场景的数据（比如光照、阴影、光的颜色等等），这些数据可以被用来计算最终像素的颜色。</p>
<h5 id="7"><a href="#7" class="headerlink" title="7."></a>7.</h5><p>在所有对应颜色值确定以后，最终的对象将会被传到最后一个阶段，我们叫做Alpha测试和混合(Blending)阶段。这个阶段检测片段的对应的深度（和模板(Stencil)）值（后面会讲），用它们来判断这个像素是其它物体的前面还是后面，决定是否应该丢弃。这个阶段也会检查alpha值（alpha值定义了一个物体的透明度）并对物体进行混合(Blend)。所以，即使在片段着色器中计算出来了一个像素输出的颜色，在渲染多个三角形的时候最后的像素颜色也可能完全不同。</p>
<p>对于大多数场合，我们只需要配置顶点和片段着色器就行了。几何着色器是可选的，通常使用它默认的着色器就行了。</p>
<p>在现代OpenGL中，我们<strong>必须</strong>定义至少一个顶点着色器和一个片段着色器（因为GPU中没有默认的顶点/片段着色器）。</p>
<h3 id="正式实践"><a href="#正式实践" class="headerlink" title="正式实践"></a>正式实践</h3><h4 id="1-指定顶点"><a href="#1-指定顶点" class="headerlink" title="1.指定顶点"></a>1.指定顶点</h4><p>由于我们希望渲染一个三角形，我们一共要指定三个顶点，每个顶点都有一个3D位置。我们会将它们以标准化设备坐标的形式（OpenGL的可见区域）定义为一个<code>float</code>数组。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> vertices[] = &#123;</span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,</span><br><span class="line">     <span class="number">0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,</span><br><span class="line">     <span class="number">0.0f</span>,  <span class="number">0.5f</span>, <span class="number">0.0f</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="2-vertex-shader-顶点着色器"><a href="#2-vertex-shader-顶点着色器" class="headerlink" title="2.vertex shader 顶点着色器"></a>2.vertex shader 顶点着色器</h4>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/11/07/%E5%B8%83%E6%96%99%E6%A8%A1%E6%8B%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/head.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="旋转公寓的阁楼">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/11/07/%E5%B8%83%E6%96%99%E6%A8%A1%E6%8B%9F/" itemprop="url">布料模拟</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-11-07T13:46:05+08:00">
                2021-11-07
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于&#58;</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2021-11-12T11:46:25+08:00">
                2021-11-12
              </time>
            
          </span>

          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  210
                </span>
              

              

              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>在unity中的布料模拟，其实就是对布料mesh进行的各顶点计算物理仿真。</p>
<p>unity中的mesh由众多三角面片构成，每个三角面片的顶点是有重复的。而我们要做的就是对这些顶点加重力，在顶点与顶点之间加一个约束力，在对其加一个碰撞的力，这样子布料模拟就完成了。</p>
<hr>
<h3 id="Thanks"><a href="#Thanks" class="headerlink" title="Thanks:"></a>Thanks:</h3><p>Unity Mesh 初体验 :<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/7cd99a05cfea">https://www.jianshu.com/p/7cd99a05cfea</a></p>
<p>Mesh.RecalculateNormals 重新计算法线 :<a target="_blank" rel="noopener" href="http://docs.manew.com/Script/Mesh.RecalculateNormals.html">http://docs.manew.com/Script/Mesh.RecalculateNormals.html</a></p>
<p>C# and Shader Tutorials for the Unity Engine :<a target="_blank" rel="noopener" href="https://catlikecoding.com/unity/tutorials/">https://catlikecoding.com/unity/tutorials/</a></p>
<p>Unity Mesh变形（制作一个弹力球）:<a target="_blank" rel="noopener" href="https://blog.csdn.net/haog87/article/details/108162792">https://blog.csdn.net/haog87/article/details/108162792</a></p>
<p>Unity3D中文手册:<a target="_blank" rel="noopener" href="https://dev.gameres.com/Program/Unity3Dmanual/Script/index.Classes.html">https://dev.gameres.com/Program/Unity3Dmanual/Script/index.Classes.html</a></p>
<p>快速排序quicksort的Ｃ实现：<a target="_blank" rel="noopener" href="http://blog.chinaunix.net/uid-24774106-id-2238633.html">http://blog.chinaunix.net/uid-24774106-id-2238633.html</a></p>
<p>Unity里的Mesh属性：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/353794573">https://zhuanlan.zhihu.com/p/353794573</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/11/03/Unity%E6%9D%82%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/head.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="旋转公寓的阁楼">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/11/03/Unity%E6%9D%82%E8%AE%B0/" itemprop="url">Unity杂记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-11-03T13:54:08+08:00">
                2021-11-03
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于&#58;</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2021-11-03T14:09:24+08:00">
                2021-11-03
              </time>
            
          </span>

          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  141
                </span>
              

              

              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="1-unity中Vector3-normalized和Vector3-Normalized的区别"><a href="#1-unity中Vector3-normalized和Vector3-Normalized的区别" class="headerlink" title="1.unity中Vector3.normalized和Vector3.Normalized的区别"></a>1.unity中Vector3.normalized和Vector3.Normalized的区别</h4><p>共同点：</p>
<p>​    实现规范化，让一个向量保持相同的方向，但它的长度为1.0，如果这个向量太小而不能被规范化，一个零向量将会被返回。</p>
<p>不同点：</p>
<p>​    Vector3.normalized的特点是当前向量是不改变的并且返回一个新的规范化的向量；</p>
<p>​    Vector3.Normalize的特点是改变当前向量，也就是当前向量长度是1</p>
<h3 id="2-vector-magnitude"><a href="#2-vector-magnitude" class="headerlink" title="2.vector.magnitude"></a>2.vector.magnitude</h3><p>返回向量的长度。向量的长度是(x<em>x+y</em>y+z*z)的平方根。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/11/02/Unity-IntermediateScript/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/head.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="旋转公寓的阁楼">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/11/02/Unity-IntermediateScript/" itemprop="url">Unity-IntermediateScript</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-11-02T09:20:00+08:00">
                2021-11-02
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于&#58;</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2021-11-03T10:27:16+08:00">
                2021-11-03
              </time>
            
          </span>

          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  2.9k
                </span>
              

              

              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>[TOC]</p>
<h3 id="1-属性-Properties"><a href="#1-属性-Properties" class="headerlink" title="1.属性 Properties"></a>1.属性 Properties</h3><p>在外部访问类内部变量的需求，除了设其为public，还可以用properties。其在内部封装变量，称其为域，可以用get{}set{}对其内部进行访问。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class Properties : MonoBehaviour</span><br><span class="line">&#123;</span><br><span class="line">    private int experience;//这是一个私有的域</span><br><span class="line">    //想要在类外访问他，就需要来一个Properties</span><br><span class="line">    //首字母大写</span><br><span class="line">    public int Experience  </span><br><span class="line">    &#123;   //括号内是属性的访问器</span><br><span class="line">        get</span><br><span class="line">        &#123;</span><br><span class="line">            return experience;</span><br><span class="line">        &#125;           //取值时调用</span><br><span class="line">        set</span><br><span class="line">        &#123;</span><br><span class="line">            experience=value;</span><br><span class="line">        &#125;           //赋值时调用</span><br><span class="line">        //不实现其中一个，就能做到只读或者只写，这是public做不到的</span><br><span class="line">        //2.其可以在内部加函数，或者返回值进行特定转变（例子是用   输入经验值却返回等级</span><br><span class="line">    &#125;</span><br><span class="line">    public int Experience1&#123;get;set;&#125;//缩写 </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class UseProperties : MonoBehaviour</span><br><span class="line">&#123;</span><br><span class="line">    void start()</span><br><span class="line">    &#123;</span><br><span class="line">        Properties myProperties =new Properties();  //在类外使用他</span><br><span class="line">        myProperties.Experience = 5;</span><br><span class="line">        int x=myProperties.Experience;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="2-三元操作符-Ternary-Operator"><a href="#2-三元操作符-Ternary-Operator" class="headerlink" title="2.三元操作符 Ternary Operator"></a>2.三元操作符 Ternary Operator</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">message = health &gt; 0 ? &quot;Player is Alive&quot; : &quot;Player is Dead&quot;; //也可以嵌套循环</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="3-静态类型-Statics"><a href="#3-静态类型-Statics" class="headerlink" title="3.静态类型 Statics"></a>3.静态类型 Statics</h3><p>静态成员可以在类的所有实例被共享，而且其可以通过类直接访问，不需要实例。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class Statics : MonoBehaviour</span><br><span class="line">&#123;</span><br><span class="line">   public static int enemyCount =0;//静态成员属于类本身</span><br><span class="line">   public Statics()</span><br><span class="line">   &#123;</span><br><span class="line">       enemyCount++ ;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class Game</span><br><span class="line">&#123;</span><br><span class="line">    Statics a1=new Statics();</span><br><span class="line">    Statics a2=new Statics();</span><br><span class="line"></span><br><span class="line">    int x=Statics.enemyCount;//直接使用类名.静态成员名</span><br><span class="line">    //静态函数同理。</span><br><span class="line">    //在unity中  Input.GetButton();等都是静态函数！</span><br><span class="line">&#125;//也可以新建一个static类，其内部全是静态成员 例如Unity的Input类</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="4-重载-Overloading"><a href="#4-重载-Overloading" class="headerlink" title="4.重载 Overloading"></a>4.重载 Overloading</h3><p>懒得写了。需要注意的是如果没有完全匹配的重载（ExactMatch)，会类型转化(LeastConversion)，如果还没有就error。</p>
<hr>
<h3 id="5-泛型-Generics"><a href="#5-泛型-Generics" class="headerlink" title="5.泛型 Generics"></a>5.泛型 Generics</h3><p>泛型特性使类和函数等，可以接受类型作为参数。这就允许你编写通用的程序，而不需要知道要处理的数据的具体类型。就例如之前的GetComponent()，利用&lt;&gt;来获取组件，它就是泛型函数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class Generics : MonoBehaviour</span><br><span class="line">&#123;</span><br><span class="line">    public T GenericMethod&lt;T&gt;(T param)</span><br><span class="line">    &#123;</span><br><span class="line">        return param;</span><br><span class="line">    &#125;</span><br><span class="line">	//泛型函数后面可以用where限定T的类型</span><br><span class="line">    public T GenericMethod2&lt;T&gt;(T param) where T : struct    //①struct-value ②class-reference </span><br><span class="line">    &#123;return param;&#125;</span><br><span class="line">    </span><br><span class="line">    public T GenericMethod3&lt;T&gt;(T param) where T : new()     //③new()-公有的不需要参数 ④也可以用具体的类名，确定就是这个类或者其多态 ⑤或者接口</span><br><span class="line">    &#123;return param;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class GenericClass &lt;T&gt; 	//泛型类</span><br><span class="line">&#123;</span><br><span class="line">    T item;</span><br><span class="line">    public void add(T item2)</span><br><span class="line">    &#123;item=item2;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class UseGenerics : MonoBehaviour</span><br><span class="line">&#123;	//具体的使用</span><br><span class="line">    // Start is called before the first frame update</span><br><span class="line">    void Start()</span><br><span class="line">    &#123;</span><br><span class="line">        Generics myGenerics = new Generics();</span><br><span class="line">        myGenerics.GenericMethod&lt;int&gt;(3);</span><br><span class="line"></span><br><span class="line">        GenericClass&lt;int&gt; myClass=new  GenericClass&lt;int&gt;();</span><br><span class="line">        myClass.add(4);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="6-继承-inheritance"><a href="#6-继承-inheritance" class="headerlink" title="6.继承 inheritance"></a>6.继承 inheritance</h3><hr>
<h3 id="7-多态-Polymorphism"><a href="#7-多态-Polymorphism" class="headerlink" title="7.多态 Polymorphism"></a>7.多态 Polymorphism</h3><hr>
<h3 id="8-成员隐藏-MemberHiding"><a href="#8-成员隐藏-MemberHiding" class="headerlink" title="8.成员隐藏 MemberHiding"></a>8.成员隐藏 MemberHiding</h3><p>在继承时，基类成员自动继承到子类中，在子类中重新创建，或叫重新声明，一个基类成员就叫成员隐藏。？ </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class Humanoid</span><br><span class="line">&#123;</span><br><span class="line">    void Yell()</span><br><span class="line">    &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class Enemy : Humanoid</span><br><span class="line">&#123;</span><br><span class="line">    new void Yell() //这样子类被up casting的时候，会默认用父类的Yell()?</span><br><span class="line">    &#123;    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="9-覆盖-Overriding"><a href="#9-覆盖-Overriding" class="headerlink" title="9.覆盖 Overriding"></a>9.覆盖 Overriding</h3><p>指在子类中改变基类方法的行为</p>
<p>对基类函数设置virtual ，对子类函数设置override，即可进行覆盖</p>
<hr>
<h3 id="10-接口-Interfaces"><a href="#10-接口-Interfaces" class="headerlink" title="10.接口 Interfaces"></a>10.接口 Interfaces</h3><p>可以当作对功能的一种约定</p>
<p>实现接口的类，必须拥有所有接口规定的函数和属性。这样子这个类可以被其他类当成接口对待。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public interface IKillable	 //IXXXXable</span><br><span class="line">&#123;</span><br><span class="line">    void Kill();</span><br><span class="line">&#125;</span><br><span class="line">public interface IDamageable&lt;T&gt;</span><br><span class="line">&#123;</span><br><span class="line">    void Damage(T damageTaken);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为实现某个接口，类当中必须显式声明所有接口中的属性，事件，函数，索引器，否则报错。</p>
<p>好处在于，可以跨越类型，定义常用的功能。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class Interfaces : MonoBehaviour , IKillable , IDamageable&lt;float&gt;</span><br><span class="line">&#123;   //必须实现这些接口所需要的函数</span><br><span class="line">    public void Kill()</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void Damage(float damage)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>可能会好奇为什么要用接口。</p>
<p>因为一个类可以实现多个接口，但是只能继承一个父类，所以接口提供更丰富的功能性。</p>
<p>或者说，接口用来定义跨越类的功能，这些类之间无关联。</p>
<hr>
<h3 id="11-扩展方法-Extension-Method"><a href="#11-扩展方法-Extension-Method" class="headerlink" title="11.扩展方法 Extension Method"></a>11.扩展方法 Extension Method</h3><p>用来给类型增加功能，而不用创建一个衍生类型或者修改原类型，非常适用于增加类的功能而不修改类本身。</p>
<p>必须放在无泛型的静态类当中，一般单独创建类去保存它。</p>
<p>也要用static关键字声明，其与静态方法区别关键在于this</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public static class Extension &#123;</span><br><span class="line">    public static void ResetTransformations(this Transform trans) &#123;</span><br><span class="line">        trans.position = Vector3.zero;</span><br><span class="line">        trans.localRotation = Quaternion.identity;</span><br><span class="line">        trans.localScale = Vector3.zero;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ExtensionMethods :MonoBehaviour &#123;</span><br><span class="line">    private void Start() &#123;</span><br><span class="line">        transform.ResetTransformations();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="12-Namespaces"><a href="#12-Namespaces" class="headerlink" title="12.Namespaces"></a>12.Namespaces</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">namespace MyNameSpace&#123;	//create</span><br><span class="line">......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">using MyNameSpace;//using</span><br><span class="line">MyNameSpace.XXX;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="13-列表和字典-Lists-and-Dictionaries"><a href="#13-列表和字典-Lists-and-Dictionaries" class="headerlink" title="13.列表和字典 Lists and Dictionaries"></a>13.列表和字典 Lists and Dictionaries</h3><p>俩个泛型集合。</p>
<p>list 动态数组，提供更大的灵活和丰富的功能</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">using System.Collections.Generic;	//使用前需加入</span><br><span class="line">using System;		//使用list的Sort()功能需要加入</span><br><span class="line"></span><br><span class="line">public class BadGuy : IComparable&lt;BadGuy&gt; //如果要用list的sort功能，需要加入这个接口，语法类似于继承  这个接口又在system命名空间中，所以也要加一个using </span><br><span class="line">&#123;</span><br><span class="line">    public string name;</span><br><span class="line">    public int power;</span><br><span class="line">    public BadGuy(string NewName, int NewPower)&#123;</span><br><span class="line">        name = NewName;</span><br><span class="line">        power = NewPower;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int CompareTo(BadGuy other)  //如果要用list的sort功能，需要加入这个接口，并完成接口的约定，这个接口只需要我们实现这个接口</span><br><span class="line">    &#123;</span><br><span class="line">        if(other == null) return 1;</span><br><span class="line">        return power-other.power;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class list : MonoBehaviour</span><br><span class="line">&#123;</span><br><span class="line">    void Start()</span><br><span class="line">    &#123;</span><br><span class="line">        List&lt;BadGuy&gt; badguys = new List&lt;BadGuy&gt;();</span><br><span class="line"></span><br><span class="line">        badguys.Add(new BadGuy(&quot;Stu1&quot;,100));</span><br><span class="line">        badguys.Add(new BadGuy(&quot;Stu2&quot;,200));</span><br><span class="line">        badguys.Add(new BadGuy(&quot;Stu3&quot;,50));</span><br><span class="line"></span><br><span class="line">       // badguys[0].name;</span><br><span class="line">        badguys.Sort();//排序</span><br><span class="line">        foreach (BadGuy guy in badguys)</span><br><span class="line">        &#123;</span><br><span class="line">            print(guy.name + &quot; &quot; + guy.power);</span><br><span class="line">        &#125;</span><br><span class="line">        badguys.Clear();//清除</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Dictionary工作方式类似，但需要俩种类型。也就是说每个元素由键值对组成，简称kvp。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public class Dictionaaa : MonoBehaviour</span><br><span class="line">&#123;</span><br><span class="line">    void start()</span><br><span class="line">    &#123;</span><br><span class="line">        Dictionary&lt;string,BadGuy&gt; badguys =new Dictionary&lt;string,BadGuy&gt;();</span><br><span class="line">                //第一个参数是key，第二个是value</span><br><span class="line">        BadGuy bg1=new BadGuy(&quot;Harvey&quot;,50);</span><br><span class="line">        BadGuy bg2=new BadGuy(&quot;Magneto&quot;,100);</span><br><span class="line"></span><br><span class="line">        badguys.Add(&quot;aa&quot;,bg1);//需要同时有key和value</span><br><span class="line">        badguys.Add(&quot;bb&quot;,bg2);//add进dictionary</span><br><span class="line"></span><br><span class="line">        BadGuy magnet =badguys[&quot;bb&quot;];   //获取key保存的值，此时key是bb</span><br><span class="line"></span><br><span class="line">        BadGuy temp =null;</span><br><span class="line">        if(badguys.TryGetValue(&quot;birds&quot;,out temp))//如果不确定key是不是存在，可以进行这个函数</span><br><span class="line">        &#123;</span><br><span class="line">            //success</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            //fail</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="14-携程-Coroutine"><a href="#14-携程-Coroutine" class="headerlink" title="14.携程 Coroutine"></a>14.携程 Coroutine</h3><p>可以被看作是间接执行的函数，用yield声明，将代码跳出到函数外，如果继续会回到原处继续执行。可以有效避免update在每一帧使用带来的资源浪费！</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class Coroutine : MonoBehaviour</span><br><span class="line">&#123;</span><br><span class="line">    public float smoothing=1f;</span><br><span class="line">    public Transform target;</span><br><span class="line">    void Start()</span><br><span class="line">    &#123;</span><br><span class="line">        StartCoroutine(MyCoroutine(target));//调用携程</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    IEnumerator MyCoroutine (Transform target)  //返回任何实现了ienumerator接口的东西</span><br><span class="line">    &#123;</span><br><span class="line">        while(Vector3.Distance(transform.position, target.position)&gt;0.05f)  //当俩者距离靠近之后，</span><br><span class="line">        &#123;</span><br><span class="line">            transform.position = Vector3.Lerp(transform.position, target.position,smoothing*Time.deltaTime);//疯狂插值 接近</span><br><span class="line">            yield return null; //跳出等到下次update， yield是重点</span><br><span class="line">        &#125;</span><br><span class="line">        print(&quot;Reached the target&quot;);</span><br><span class="line">        yield return new WaitForSeconds(3f);    //跳出等3s                  </span><br><span class="line">        print(&quot;MyCoroutine is now finished&quot;);   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="15-四元数-Quaternions"><a href="#15-四元数-Quaternions" class="headerlink" title="15.四元数 Quaternions"></a>15.四元数 Quaternions</h3><p>在unity中，四元数保存物体的旋转信息。是个四元向量，xyzw，四个值相互依赖，不能单独更改。</p>
<p>负责处理旋转的系统叫欧拉角，其基于xyz，但其会受限于万向节锁的问题，故不用。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//这是被看物体的移动</span><br><span class="line">public class motion : MonoBehaviour</span><br><span class="line">&#123;</span><br><span class="line">    public float speed =3f;</span><br><span class="line">    void Update()</span><br><span class="line">    &#123;</span><br><span class="line">        transform.Translate(-Input.GetAxis(&quot;Horizontal&quot;)*speed*Time.deltaTime,0,0);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//这是观察者的函数</span><br><span class="line">public class Lookat1 : MonoBehaviour</span><br><span class="line">&#123;</span><br><span class="line">    public Transform target;</span><br><span class="line">    void Update()</span><br><span class="line">    &#123;</span><br><span class="line">        Vector3 relativePos=target.position-transform.position;</span><br><span class="line">        transform.rotation=Quaternion.LookRotation(relativePos);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//绕着target旋转</span><br><span class="line">public class circleRound : MonoBehaviour</span><br><span class="line">&#123;</span><br><span class="line">    public Transform target;</span><br><span class="line"></span><br><span class="line">    void Update()</span><br><span class="line">    &#123;</span><br><span class="line">        Vector3 relativePos =(target.position+new Vector3(0,1.5f,0))-transform.position;</span><br><span class="line">        Quaternion rotation = Quaternion.LookRotation(relativePos);</span><br><span class="line"></span><br><span class="line">        Quaternion current = transform.localRotation;</span><br><span class="line"></span><br><span class="line">        transform.localRotation = Quaternion.Slerp(current, rotation,Time.deltaTime);</span><br><span class="line">        transform.Translate(0,0,3*Time.deltaTime);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="16-委托-Delegates"><a href="#16-委托-Delegates" class="headerlink" title="16.委托 Delegates"></a>16.委托 Delegates</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public class DelegateScript : MonoBehaviour</span><br><span class="line">&#123;</span><br><span class="line">    delegate void MyDelegate(int num);  //我们的委托</span><br><span class="line">    MyDelegate myDelegate;  //创建完委托类型后，接着声明成员变量</span><br><span class="line"></span><br><span class="line">    void PrintNum(int num)</span><br><span class="line">    &#123;</span><br><span class="line">        print(&quot;PrintNum&quot;+num);</span><br><span class="line">    &#125;</span><br><span class="line">    void DoubleNum(int num)</span><br><span class="line">    &#123;</span><br><span class="line">        print(&quot;Double Num&quot; + num);</span><br><span class="line">    &#125;</span><br><span class="line">        void Start()</span><br><span class="line">    &#123;</span><br><span class="line">        myDelegate = PrintNum;  //类似于函数指针，还是很好懂的</span><br><span class="line">        myDelegate(50); //输出就是PrintNum50</span><br><span class="line"></span><br><span class="line">        myDelegate =DoubleNum;</span><br><span class="line">        myDelegate(50);</span><br><span class="line"></span><br><span class="line">        myDelegate +=PrintNum; //委托广播，可以包含很多函数</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="17-特性-Attributes"><a href="#17-特性-Attributes" class="headerlink" title="17.特性 Attributes"></a>17.特性 Attributes</h3><p>特性能在声明时，对函数变量或者类添加额外信息。（这里好像只讲了俩个</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">using UnityEngine;</span><br><span class="line">using System.Collections;</span><br><span class="line"></span><br><span class="line">[ExecuteInEditMode] </span><br><span class="line">//这个特性允许代码在场景中就生效，而不是运行时才生效，可以进行实时更改，无法还原</span><br><span class="line">//需要写在整个代码上面，毕竟是对全体代码生效的</span><br><span class="line">public class spin : MonoBehaviour &#123;</span><br><span class="line"></span><br><span class="line">    [Range(-100,100)]   //这里把特性放在变量声明上面</span><br><span class="line">    public int speed=0;</span><br><span class="line"></span><br><span class="line">    [Range(-100,100)] public int maxSpeed;	//第二种写法，限定范围</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    void Update()</span><br><span class="line">    &#123;</span><br><span class="line">        transform.Rotate(new Vector3(0,speed*Time.deltaTime,0));</span><br><span class="line">        //按y轴旋转对象   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="18-事件-Events"><a href="#18-事件-Events" class="headerlink" title="18.事件 Events"></a>18.事件 Events</h3><p>相当于公共的广播委托，用于提醒其他类有什么事发生了。 有点难理解，于是查阅发现以下解释：</p>
<p>“事件是拥有可以注册和解绑方法（函数）的功能。</p>
<p>虽然事件和委托看起来有点绕，只要捋清楚事件和委托的关系，就会很容易理解。</p>
<p>委托是一个类，事件则是委托类中的一个对象，该对象是能够把其他方法注册到委托类中的一个事件（如果觉得有点绕，可以忽略这句话）。</p>
<p>事件和函数的关系：事件具有可以注册多个函数（和解绑函数）的功能，而函数如果要注册和解绑其他在其主体上运行的函数则需要改动该函数本体的代码，这就是区别。</p>
<p>以下代码的大致流程：定义一个新类（事件类）–》类中声明委托–》由委托类又声明事件–》再定义触发事件的函数–》函数主体中执行事件–》在主函数中实例化事件类–》进而调用事件类中的事件对象–》事件对象再注册（+=）两个方法–》再执行事件类中触发事件的那个函数–》再解绑其中一个方法–》再次执行事件类中触发事件的函数。</p>
<p>由此可见：事件是拥有可以注册和解绑方法（函数）的功能。”</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line"></span><br><span class="line">namespace DelegateAndEvent</span><br><span class="line">&#123;</span><br><span class="line">    //定义一个事件类</span><br><span class="line">    public class MyEvent</span><br><span class="line">    &#123;</span><br><span class="line">        //定义一个委托</span><br><span class="line">        public delegate void MyDelegate();</span><br><span class="line">        //定义一个事件</span><br><span class="line">        public MyDelegate MyDelegateEvent;</span><br><span class="line">        //定义一个触发事件的函数</span><br><span class="line">        public void OnMyDelegateEvent()</span><br><span class="line">        &#123;</span><br><span class="line">            //判断事件是否非空</span><br><span class="line">            if (MyDelegateEvent != null)</span><br><span class="line">            &#123;</span><br><span class="line">                //执行事件</span><br><span class="line">                MyDelegateEvent();</span><br><span class="line">            &#125;</span><br><span class="line">            //MyDelegateEvent?.Invoke(); //简化的判断和执行</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    class Program</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        //输出一串字符</span><br><span class="line">        public static void putOutChar()</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(&quot;I was fired&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        //输出第二串字符</span><br><span class="line">        public static void putOutChar2()</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(&quot;I was fired22222&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        static void Main(string[] args)</span><br><span class="line">        &#123;</span><br><span class="line">            //实例化MyEvent2类</span><br><span class="line">            MyEvent myEvent = new MyEvent();</span><br><span class="line">            //注册一个事件</span><br><span class="line">            myEvent.MyDelegateEvent += new MyEvent.MyDelegate(putOutChar);</span><br><span class="line">            myEvent.MyDelegateEvent += new MyEvent.MyDelegate(putOutChar2);</span><br><span class="line">            //执行触发事件的函数</span><br><span class="line">            Console.WriteLine(&quot;执行绑定了两个事件后的函数&quot;);</span><br><span class="line">            myEvent.OnMyDelegateEvent();</span><br><span class="line">            //解绑一个事件</span><br><span class="line">            myEvent.MyDelegateEvent -= new MyEvent.MyDelegate(putOutChar);</span><br><span class="line">            //再次执行触发事件的函数</span><br><span class="line">            Console.WriteLine(&quot;执行解绑了一个事件后的函数&quot;);</span><br><span class="line">            myEvent.OnMyDelegateEvent();</span><br><span class="line">            Console.ReadKey();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>又或者“<strong>delegate</strong> 相当于定义一个函数类型。</p>
<p><strong>event</strong> 相当于定义一个 <strong>delegate</strong> 的函数指针（回调函数指针）。”</p>
</blockquote>
<hr>
<h3 id="Thanks"><a href="#Thanks" class="headerlink" title="Thanks:"></a>Thanks:</h3><p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1hs411r7ZM?spm_id_from=333.999.0.0">https://www.bilibili.com/video/BV1hs411r7ZM?spm_id_from=333.999.0.0</a></p>
<p><a target="_blank" rel="noopener" href="https://www.runoob.com/csharp/csharp-event.html">https://www.runoob.com/csharp/csharp-event.html</a></p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Es411t7rL?p=10">https://www.bilibili.com/video/BV1Es411t7rL?p=10</a></p>
<p>只是不求甚解地过了一遍，具体还是要在实践中熟练了，才算学会。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/10/31/Unity-BasicScript2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/head.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="旋转公寓的阁楼">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/10/31/Unity-BasicScript2/" itemprop="url">Unity-BasicScript2</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-10-31T18:47:11+08:00">
                2021-10-31
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于&#58;</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2021-11-03T10:28:51+08:00">
                2021-11-03
              </time>
            
          </span>

          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  633
                </span>
              

              

              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>[TOC]</p>
<h3 id="1-DataTypes"><a href="#1-DataTypes" class="headerlink" title="1.DataTypes"></a>1.DataTypes</h3><p>初级分为Value和Reference</p>
<p>Value：int float double bool char Structs{Vector3,Quatenion}</p>
<p>Reference: Classes{Transform,GameObject}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void Start()</span><br><span class="line">    &#123;</span><br><span class="line">        Transform tran=transform;	//这里的transform就是组件 故是地址 共同改变了属于是</span><br><span class="line">        tran.position = new Vector3(0,0,2);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="2-类的使用"><a href="#2-类的使用" class="headerlink" title="2.类的使用"></a>2.类的使用</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class Fuc1&#123;</span><br><span class="line">       int a1;</span><br><span class="line">    	public Fun1(int aa1)&#123;	//Constructor //no return value</span><br><span class="line">           a1=aa1;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">public Fuc1 fuc1=new Fuc1();</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="3-Instantiate"><a href="#3-Instantiate" class="headerlink" title="3.Instantiate()"></a>3.Instantiate()</h3><p>Instantiate函数实例化是将original对象的所有子物体和子组件完全复制，成为一个新的对象。这个新的对象拥有与源对象完全一样的东西，包括坐标值等。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public Rigidbody rocketPrefab;	//需要绑定一个带Rigidbody的物体</span><br><span class="line">	public Transform barrelEnd;	//需要绑定一个(空)物体,坐标就是生成位置</span><br><span class="line">   void Update()</span><br><span class="line">   &#123;</span><br><span class="line">       if(Input.GetKeyDown(KeyCode.K))</span><br><span class="line">       &#123;	//在Inspector中绑定物品即可 //可以用来生成子弹</span><br><span class="line">           Instantiate(rocketPrefab);</span><br><span class="line">           //第二种 第二三个参数是新克隆体的位置和旋转值</span><br><span class="line">           Instantiate(rocketPrefab,barrelEnd.position,barrelEnd.rotation);   </span><br><span class="line">           //第三种，当作刚体可以进行力的施加</span><br><span class="line">           Rigidbody rocketRigid;</span><br><span class="line">           rocketRigid=Instantiate(rocketPrefab,barrelEnd.position,barrelEnd.rotation) as Rigidbody;</span><br><span class="line">           rocketRigid.AddForce(Vector3.up * 500);</span><br><span class="line">           //因为克隆出来的物体会一直存在，所以如果是子弹什么的可以加一个定时销毁的脚本</span><br><span class="line">       &#125;	</span><br><span class="line">   &#125;	</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="4-数组Array"><a href="#4-数组Array" class="headerlink" title="4.数组Array"></a>4.数组Array</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int[] array1=new int[4];</span><br><span class="line">   int[] array2=&#123;1,3,54,53&#125;;</span><br><span class="line">   public GameObject[] players;  //public即可界面编辑</span><br><span class="line">   void Start()</span><br><span class="line">   &#123;</span><br><span class="line">       array1[0]=2;</span><br><span class="line">       players=GameObject.FindGameObjectsWithTag(&quot;player&quot;);//用指定的标签去寻找</span><br><span class="line">       for (int i = 0; i &lt; players.Length; i++)</span><br><span class="line">           Debug.Log(&quot;Goodbye&quot;+i+players[i].name);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="5-Invoke"><a href="#5-Invoke" class="headerlink" title="5.Invoke()"></a>5.Invoke()</h3><p>允许安排一个延时调用的函数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public Object target;</span><br><span class="line">    void SpawnObject()</span><br><span class="line">    &#123;</span><br><span class="line">        float x=Random.Range(-3.0f, 3.0f);</span><br><span class="line">        float z=Random.Range(-3.0f, 3.0f);</span><br><span class="line">        Instantiate(target,new Vector3(x,1,z),Quaternion.identity);</span><br><span class="line">    &#125;</span><br><span class="line">    void Start()</span><br><span class="line">    &#123;</span><br><span class="line">        Invoke(&quot;SpawnObject&quot;,2);</span><br><span class="line">        //延时俩秒调用 </span><br><span class="line">        //只有不需要传入参数，且返回类型为void的函数才能用Invoke调用</span><br><span class="line">        InvokeRepeating(&quot;SpawnObject&quot;,2,1);</span><br><span class="line">        //延时俩秒调用，并且之后每隔一秒调用一次</span><br><span class="line">        CancelInvoke();</span><br><span class="line">        CancelInvoke(&quot;SpawnObject&quot;);</span><br><span class="line">        //停止延时调用</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="6-Enumeration-Enum"><a href="#6-Enumeration-Enum" class="headerlink" title="6.Enumeration/Enum"></a>6.Enumeration/Enum</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">enum Enum1&#123; North, East, South, West&#125;;	</span><br><span class="line">//enum 可以写在class外/注意大写 因为这是类不是变量/注意最后的；</span><br><span class="line">   void Start()</span><br><span class="line">   &#123;</span><br><span class="line">       Enum1 myEnum;</span><br><span class="line">       myEnum = Enum1.North;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<p>Thanks：</p>
<p>Unity官方脚本P3： <a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV17s411o7Mf?p=3">https://www.bilibili.com/video/BV17s411o7Mf?p=3</a></p>
<p>Unity入门路线： <a target="_blank" rel="noopener" href="https://www.zhihu.com/question/314175363/answer/650214605">https://www.zhihu.com/question/314175363/answer/650214605</a></p>
<hr>
<p>突然想到或许我可以做一个roft学长的3d卡牌对战游戏，但是在同时加入摄像机旋转切换游戏玩家，实现双人同时玩的卡牌游戏…挺有意思的。roft学长的游戏很多用low-poly，好喜欢这个风格。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-hand-o-right" aria-label="accessibility.next_page"></i></a>
  </nav>


          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/head.jpg"
                alt="" />
            
              <p class="site-author-name" itemprop="name"></p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">15</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">3</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/Zhairest" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://music.163.com/#/user/home?id=70879973" target="_blank" title="CloudMusic">
                      
                        <i class="fa fa-fw fa-cloud"></i>CloudMusic</a>
                  </span>
                
            </div>
          

          
          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-block">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-link"></i>
                Links
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="http://www.baidu.com/" title="百度" target="_blank">百度</a>
                  </li>
                
              </ul>
            </div>
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Zhairest</span>

  
</div>









        <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  
  

  

  
  

  

  

  

</body>
</html>
