<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>旋转公寓的阁楼</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="旋转公寓的阁楼">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="旋转公寓的阁楼">
<meta property="og:locale">
<meta property="article:author" content="Zhairest">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="旋转公寓的阁楼" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">旋转公寓的阁楼</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">储物间</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-OpenGL-临时笔-键盘-记" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/11/12/OpenGL-%E4%B8%B4%E6%97%B6%E7%AC%94-%E9%94%AE%E7%9B%98-%E8%AE%B0/" class="article-date">
  <time class="dt-published" datetime="2021-11-12T12:53:59.000Z" itemprop="datePublished">2021-11-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/11/12/OpenGL-%E4%B8%B4%E6%97%B6%E7%AC%94-%E9%94%AE%E7%9B%98-%E8%AE%B0/">OpenGL-临时笔(键盘)记</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h5 id="1-清除缓冲区"><a href="#1-清除缓冲区" class="headerlink" title="1.清除缓冲区"></a>1.清除缓冲区</h5><p>glClearColor (0.0, 0.0, 0.0, 0.0);<br>glClearDepth(1.0);<br>glClear (GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT));</p>
<h5 id="2-glFlush"><a href="#2-glFlush" class="headerlink" title="2.glFlush();"></a>2.glFlush();</h5><p>强制客户机发送网络数据包，以免网络传输时，包没填满一直等待。<br>glFinish();强制之前的命令完成执行，执行完了才返回。</p>
<h5 id="3-reshape-int-w-int-h-回调函数"><a href="#3-reshape-int-w-int-h-回调函数" class="headerlink" title="3.reshape(int w,int h)回调函数"></a>3.reshape(int w,int h)回调函数</h5><p>void reshape (int w, int h)<br>{<br>   glViewport (0, 0, (GLsizei) w, (GLsizei) h); //调整整个像素矩形使其填满新窗口<br>   glMatrixMode (GL_PROJECTION);<br>   glLoadIdentity ();<br> //  gluPerspective(60.0, (GLfloat) w/(GLfloat) h, 1.0, 20.0);<br> //  glMatrixMode(GL_MODELVIEW);<br> //  glLoadIdentity();<br> //  gluLookAt (0.0, 0.0, 5.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0);<br>    gluOrtho2D(0.0,(GLdouble)w,0.0,(GLdouble)h);//使左下角0，0，右上角是w，h<br>}</p>
<h5 id="4-opengl的多边形边不能相交，必须是凸多边形-P25"><a href="#4-opengl的多边形边不能相交，必须是凸多边形-P25" class="headerlink" title="4.opengl的多边形边不能相交，必须是凸多边形//P25"></a>4.opengl的多边形边不能相交，必须是凸多边形//P25</h5><h5 id="5-指定顶点用glVertex（）-P27"><a href="#5-指定顶点用glVertex（）-P27" class="headerlink" title="5.指定顶点用glVertex（）//P27"></a>5.指定顶点用glVertex（）//P27</h5><h5 id="6-根据给定的顶点，用图元表示绘制的图形"><a href="#6-根据给定的顶点，用图元表示绘制的图形" class="headerlink" title="6.根据给定的顶点，用图元表示绘制的图形"></a>6.根据给定的顶点，用图元表示绘制的图形</h5><p>glBegin(图元名字);<br>    glVertex2f(0.0,0.0);<br>    ……..<br>    glVertex2f(4.0,4.0);<br>glEnd();<br>各类图元请看p29 当然begin和end之间还可以放glColor之类的；</p>
<h5 id="7-glEnable-打开功能-glIsEnabled-检测，返回GL-TURE"><a href="#7-glEnable-打开功能-glIsEnabled-检测，返回GL-TURE" class="headerlink" title="7.glEnable();打开功能 glIsEnabled();检测，返回GL_TURE"></a>7.glEnable();打开功能 glIsEnabled();检测，返回GL_TURE</h5><h5 id="8-glLineStipple-GLint-factor，Glushort-patern-画线！P34-2-5lines"><a href="#8-glLineStipple-GLint-factor，Glushort-patern-画线！P34-2-5lines" class="headerlink" title="8.glLineStipple(GLint factor，Glushort patern)画线！P34 2_5lines"></a>8.glLineStipple(GLint factor，Glushort patern)画线！P34 2_5lines</h5><p>例：<br> glEnable (GL_LINE_STIPPLE);</p>
<p>glLineStipple (1, 0x0101);  /*  dotted  <em>/<br>drawOneLine (50.0, 125.0, 150.0, 125.0);<br>glLineStipple (1, 0x00FF);  /</em>  dashed  <em>/<br>drawOneLine (150.0, 125.0, 250.0, 125.0);<br>glLineStipple (1, 0x1C47);  /</em>  dash/dot/dash  */<br>drawOneLine (250.0, 125.0, 350.0, 125.0);</p>
<h5 id="9-glPolygonMode-GL-FRONT-AND-BACK-GL-FRONT-GL-BACK-GL-FILL-GL-LINE-GL-POINT"><a href="#9-glPolygonMode-GL-FRONT-AND-BACK-GL-FRONT-GL-BACK-GL-FILL-GL-LINE-GL-POINT" class="headerlink" title="9.glPolygonMode(GL_FRONT_AND_BACK/GL_FRONT/GL_BACK , GL_FILL/GL_LINE/GL_POINT);"></a>9.glPolygonMode(GL_FRONT_AND_BACK/GL_FRONT/GL_BACK , GL_FILL/GL_LINE/GL_POINT);</h5><p>对多边形的不同面进行不同的渲染（gl3.1以上不能不同</p>
<h5 id="10-glPolygonStipple-32-32位的指针"><a href="#10-glPolygonStipple-32-32位的指针" class="headerlink" title="10.glPolygonStipple(32*32位的指针)"></a>10.glPolygonStipple(32*32位的指针)</h5><p>多边形的点画模式，每位的8格，为1就绘制，依次组成画（挺无聊的</p>
<h5 id="11-法线向量"><a href="#11-法线向量" class="headerlink" title="11. 法线向量"></a>11. 法线向量</h5><p>简称法线？！ 是一条垂直于某个表面的方向向量，在曲面上每个点的法线不同。定义了 表面在空间的方向，计算光照很有用。</p>
<p>用glNormal(给的那个向量)定义，和glVertex()一样，用在begin和end之间。</p>
<h5 id="12-顶点数组"><a href="#12-顶点数组" class="headerlink" title="12.顶点数组"></a>12.顶点数组</h5><p>用少量数组指定大量与顶点相关的数据</p>
<h6 id="1-启用数组-glEnableClientState-GL-VERTEX-ARRAY-…-p44"><a href="#1-启用数组-glEnableClientState-GL-VERTEX-ARRAY-…-p44" class="headerlink" title="1.启用数组 glEnableClientState(GL_VERTEX_ARRAY/…)p44"></a>1.启用数组 glEnableClientState(GL_VERTEX_ARRAY/…)p44</h6><p>glDisableClientState();</p>
<h6 id="2-指定数组的数据-glVertexPointer"><a href="#2-指定数组的数据-glVertexPointer" class="headerlink" title="2.指定数组的数据 glVertexPointer(//////)"></a>2.指定数组的数据 glVertexPointer(//////)</h6><p>跨距stride</p>
<h6 id="3-解引用和渲染-glArrayElement（int-ith）"><a href="#3-解引用和渲染-glArrayElement（int-ith）" class="headerlink" title="3.解引用和渲染 glArrayElement（int ith）"></a>3.解引用和渲染 glArrayElement（int ith）</h6><p>glDrawElement（）</p>
<h5 id="13-重启图元-glPrimitiveRestartIndex"><a href="#13-重启图元-glPrimitiveRestartIndex" class="headerlink" title="13.重启图元 glPrimitiveRestartIndex()???"></a>13.重启图元 glPrimitiveRestartIndex()???</h5><p>p51 (因为后面太恶心直接跳到第三章去)</p>
<h4 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h4><h5 id="14-视图变换"><a href="#14-视图变换" class="headerlink" title="14.视图变换"></a>14.视图变换</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   glClear (GL_COLOR_BUFFER_BIT);</span><br><span class="line">   glColor3f (<span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>);</span><br><span class="line">   glLoadIdentity ();             <span class="comment">/* clear the matrix */</span><span class="comment">//如果不设为单位，会与之前的矩阵相乘</span></span><br><span class="line">           <span class="comment">/* viewing transformation  */</span></span><br><span class="line">   gluLookAt (<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">5.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">0.0</span>);<span class="comment">//eye target up</span></span><br><span class="line">    <span class="comment">//默认是原点 z负 up-y正</span></span><br><span class="line">   glScalef (<span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">1.0</span>);      <span class="comment">/* modeling transformation */</span> </span><br><span class="line">   glutWireCube (<span class="number">1.0</span>);</span><br><span class="line">   glFlush ();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="15-对变换进行思考"><a href="#15-对变换进行思考" class="headerlink" title="15.对变换进行思考"></a>15.对变换进行思考</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">glMatrixMode(GL_MODELVIEW);</span><br><span class="line">glLoadIdentity();</span><br><span class="line">glMultMatrixf(N);</span><br><span class="line">glMultMatrixf(M);</span><br><span class="line">glMultMatrixf(L);</span><br><span class="line">glBegin(GL_POINTS);</span><br><span class="line">	glVertex3f(V);		<span class="comment">// 顶点变换是N(M(Lv)) 也就是v先于L相乘，再与M，再与N</span></span><br><span class="line">glEnd();				<span class="comment">//顶点v的变换是相反的顺序进行的！</span></span><br></pre></td></tr></table></figure>

<h6 id="如果根据全局固定的坐标系统"><a href="#如果根据全局固定的坐标系统" class="headerlink" title="如果根据全局固定的坐标系统"></a>如果根据全局固定的坐标系统</h6><p>那必须注意乘法的顺序与出现的顺序相反</p>
<h6 id="反之，我们就要考虑局部移动坐标系统"><a href="#反之，我们就要考虑局部移动坐标系统" class="headerlink" title="反之，我们就要考虑局部移动坐标系统"></a>反之，我们就要考虑局部移动坐标系统</h6><p>想象一个固定到所绘制物体的局部坐标系统，所有操作都相对于这个不断变化的坐标系统进行。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/11/12/OpenGL-%E4%B8%B4%E6%97%B6%E7%AC%94-%E9%94%AE%E7%9B%98-%E8%AE%B0/" data-id="ckvxh48zw0004rccf741268zf" data-title="OpenGL-临时笔(键盘)记" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/OpenGL/" rel="tag">OpenGL</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-OpenGL-1" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/11/12/OpenGL-1/" class="article-date">
  <time class="dt-published" datetime="2021-11-12T11:30:30.000Z" itemprop="datePublished">2021-11-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/11/12/OpenGL-1/">OpenGL_1</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <ul>
<li>顶点数组对象：Vertex Array Object，VAO</li>
<li>顶点缓冲对象：Vertex Buffer Object，VBO</li>
<li>索引缓冲对象：Element Buffer Object，EBO或Index Buffer Object，IBO</li>
</ul>
<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>3D坐标转为2D坐标的处理过程是由OpenGL的图形渲染管线（Graphics Pipeline，大多译为管线，实际上指的是一堆原始图形数据途经一个输送管道，期间经过各种变化处理最终出现在屏幕的过程）管理的。图形渲染管线可以被划分为两个主要部分：第一部分把你的3D坐标转换为2D坐标，第二部分是把2D坐标转变为实际的有颜色的像素。</p>
<p>图形渲染管线接受一组3D坐标，然后把它们转变为你屏幕上的有色2D像素输出。图形渲染管线可以被划分为几个阶段，每个阶段将会把前一个阶段的输出作为输入。所有这些阶段都是高度专门化的（它们都有一个特定的函数），并且很容易并行执行。正是由于它们具有并行执行的特性，当今大多数显卡都有成千上万的小处理核心，它们在GPU上为每一个（渲染管线）阶段运行各自的小程序，从而在图形渲染管线中快速处理你的数据。这些小程序叫做着色器(Shader)。</p>
<p>有些着色器允许开发者自己配置，这就允许我们用自己写的着色器来替换默认的。这样我们就可以更细致地控制图形渲染管线中的特定部分了，而且因为它们运行在GPU上，所以它们可以给我们节约宝贵的CPU时间。</p>
<p>图形渲染管线的每个阶段的抽象展示。要注意蓝色部分代表的是我们可以注入自定义的着色器的部分。<img src="/OpenGL-1/pipeline.png" alt="img"></p>
<h4 id="详细解读"><a href="#详细解读" class="headerlink" title="详细解读"></a>详细解读</h4><h5 id="1"><a href="#1" class="headerlink" title="1."></a>1.</h5><p>首先，我们以数组的形式传递3个3D坐标作为图形渲染管线的输入，用来表示一个三角形，这个数组叫做顶点数据(Vertex Data)；假定每个顶点只由一个3D位置和一些颜色值组成的吧。</p>
<h5 id="2"><a href="#2" class="headerlink" title="2."></a>2.</h5><p>图形渲染管线的第一个部分是顶点着色器(Vertex Shader)，它把一个单独的顶点作为输入。顶点着色器主要的目的是把3D坐标转为另一种3D坐标（后面会解释），同时顶点着色器允许我们对顶点属性进行一些基本处理。</p>
<h5 id="3"><a href="#3" class="headerlink" title="3."></a>3.</h5><p>图元装配(Primitive Assembly)阶段将顶点着色器输出的所有顶点作为输入（如果是GL_POINTS，那么就是一个顶点），并所有的点装配成指定图元的形状；本节例子中是一个三角形。</p>
<h5 id="4"><a href="#4" class="headerlink" title="4."></a>4.</h5><p>图元装配阶段的输出会传递给几何着色器(Geometry Shader)。几何着色器把图元形式的一系列顶点的集合作为输入，它可以通过产生新顶点构造出新的（或是其它的）图元来生成其他形状。例子中，它生成了另一个三角形。</p>
<h5 id="5"><a href="#5" class="headerlink" title="5."></a>5.</h5><p>几何着色器的输出会被传入光栅化阶段(Rasterization Stage)，这里它会把图元映射为最终屏幕上相应的像素，生成供片段着色器(Fragment Shader)使用的片段(Fragment)。在片段着色器运行之前会执行裁切(Clipping)。裁切会丢弃超出你的视图以外的所有像素，用来提升执行效率。</p>
<p>“OpenGL中的一个片段是OpenGL渲染一个像素所需的所有数据。”</p>
<h5 id="6"><a href="#6" class="headerlink" title="6."></a>6.</h5><p>片段着色器的主要目的是计算一个像素的最终颜色，这也是所有OpenGL高级效果产生的地方。通常，片段着色器包含3D场景的数据（比如光照、阴影、光的颜色等等），这些数据可以被用来计算最终像素的颜色。</p>
<h5 id="7"><a href="#7" class="headerlink" title="7."></a>7.</h5><p>在所有对应颜色值确定以后，最终的对象将会被传到最后一个阶段，我们叫做Alpha测试和混合(Blending)阶段。这个阶段检测片段的对应的深度（和模板(Stencil)）值（后面会讲），用它们来判断这个像素是其它物体的前面还是后面，决定是否应该丢弃。这个阶段也会检查alpha值（alpha值定义了一个物体的透明度）并对物体进行混合(Blend)。所以，即使在片段着色器中计算出来了一个像素输出的颜色，在渲染多个三角形的时候最后的像素颜色也可能完全不同。</p>
<p>对于大多数场合，我们只需要配置顶点和片段着色器就行了。几何着色器是可选的，通常使用它默认的着色器就行了。</p>
<p>在现代OpenGL中，我们<strong>必须</strong>定义至少一个顶点着色器和一个片段着色器（因为GPU中没有默认的顶点/片段着色器）。</p>
<h3 id="正式实践"><a href="#正式实践" class="headerlink" title="正式实践"></a>正式实践</h3><h4 id="1-指定顶点"><a href="#1-指定顶点" class="headerlink" title="1.指定顶点"></a>1.指定顶点</h4><p>由于我们希望渲染一个三角形，我们一共要指定三个顶点，每个顶点都有一个3D位置。我们会将它们以标准化设备坐标的形式（OpenGL的可见区域）定义为一个<code>float</code>数组。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> vertices[] = &#123;</span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,</span><br><span class="line">     <span class="number">0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,</span><br><span class="line">     <span class="number">0.0f</span>,  <span class="number">0.5f</span>, <span class="number">0.0f</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="2-vertex-shader-顶点着色器"><a href="#2-vertex-shader-顶点着色器" class="headerlink" title="2.vertex shader 顶点着色器"></a>2.vertex shader 顶点着色器</h4>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/11/12/OpenGL-1/" data-id="ckvxh48zt0001rccfe0td3wp3" data-title="OpenGL_1" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/OpenGL/" rel="tag">OpenGL</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-布料模拟" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/11/07/%E5%B8%83%E6%96%99%E6%A8%A1%E6%8B%9F/" class="article-date">
  <time class="dt-published" datetime="2021-11-07T05:46:05.000Z" itemprop="datePublished">2021-11-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/11/07/%E5%B8%83%E6%96%99%E6%A8%A1%E6%8B%9F/">布料模拟</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>在unity中的布料模拟，其实就是对布料mesh进行的各顶点计算物理仿真。</p>
<p>unity中的mesh由众多三角面片构成，每个三角面片的顶点是有重复的。而我们要做的就是对这些顶点加重力，在顶点与顶点之间加一个约束力，在对其加一个碰撞的力，这样子布料模拟就完成了。</p>
<hr>
<h3 id="Thanks"><a href="#Thanks" class="headerlink" title="Thanks:"></a>Thanks:</h3><p>Unity Mesh 初体验 :<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/7cd99a05cfea">https://www.jianshu.com/p/7cd99a05cfea</a></p>
<p>Mesh.RecalculateNormals 重新计算法线 :<a target="_blank" rel="noopener" href="http://docs.manew.com/Script/Mesh.RecalculateNormals.html">http://docs.manew.com/Script/Mesh.RecalculateNormals.html</a></p>
<p>C# and Shader Tutorials for the Unity Engine :<a target="_blank" rel="noopener" href="https://catlikecoding.com/unity/tutorials/">https://catlikecoding.com/unity/tutorials/</a></p>
<p>Unity Mesh变形（制作一个弹力球）:<a target="_blank" rel="noopener" href="https://blog.csdn.net/haog87/article/details/108162792">https://blog.csdn.net/haog87/article/details/108162792</a></p>
<p>Unity3D中文手册:<a target="_blank" rel="noopener" href="https://dev.gameres.com/Program/Unity3Dmanual/Script/index.Classes.html">https://dev.gameres.com/Program/Unity3Dmanual/Script/index.Classes.html</a></p>
<p>快速排序quicksort的Ｃ实现：<a target="_blank" rel="noopener" href="http://blog.chinaunix.net/uid-24774106-id-2238633.html">http://blog.chinaunix.net/uid-24774106-id-2238633.html</a></p>
<p>Unity里的Mesh属性：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/353794573">https://zhuanlan.zhihu.com/p/353794573</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/11/07/%E5%B8%83%E6%96%99%E6%A8%A1%E6%8B%9F/" data-id="ckvxh4907000nrccfh2w292nq" data-title="布料模拟" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Unity/" rel="tag">Unity</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Unity杂记" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/11/03/Unity%E6%9D%82%E8%AE%B0/" class="article-date">
  <time class="dt-published" datetime="2021-11-03T05:54:08.000Z" itemprop="datePublished">2021-11-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/11/03/Unity%E6%9D%82%E8%AE%B0/">Unity杂记</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h4 id="1-unity中Vector3-normalized和Vector3-Normalized的区别"><a href="#1-unity中Vector3-normalized和Vector3-Normalized的区别" class="headerlink" title="1.unity中Vector3.normalized和Vector3.Normalized的区别"></a>1.unity中Vector3.normalized和Vector3.Normalized的区别</h4><p>共同点：</p>
<p>​    实现规范化，让一个向量保持相同的方向，但它的长度为1.0，如果这个向量太小而不能被规范化，一个零向量将会被返回。</p>
<p>不同点：</p>
<p>​    Vector3.normalized的特点是当前向量是不改变的并且返回一个新的规范化的向量；</p>
<p>​    Vector3.Normalize的特点是改变当前向量，也就是当前向量长度是1</p>
<h3 id="2-vector-magnitude"><a href="#2-vector-magnitude" class="headerlink" title="2.vector.magnitude"></a>2.vector.magnitude</h3><p>返回向量的长度。向量的长度是(x<em>x+y</em>y+z*z)的平方根。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/11/03/Unity%E6%9D%82%E8%AE%B0/" data-id="ckvxh4904000hrccfb0n36hwt" data-title="Unity杂记" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Unity/" rel="tag">Unity</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Unity-IntermediateScript" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/11/02/Unity-IntermediateScript/" class="article-date">
  <time class="dt-published" datetime="2021-11-02T01:20:00.000Z" itemprop="datePublished">2021-11-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/11/02/Unity-IntermediateScript/">Unity-IntermediateScript</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>[TOC]</p>
<h3 id="1-属性-Properties"><a href="#1-属性-Properties" class="headerlink" title="1.属性 Properties"></a>1.属性 Properties</h3><p>在外部访问类内部变量的需求，除了设其为public，还可以用properties。其在内部封装变量，称其为域，可以用get{}set{}对其内部进行访问。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class Properties : MonoBehaviour</span><br><span class="line">&#123;</span><br><span class="line">    private int experience;//这是一个私有的域</span><br><span class="line">    //想要在类外访问他，就需要来一个Properties</span><br><span class="line">    //首字母大写</span><br><span class="line">    public int Experience  </span><br><span class="line">    &#123;   //括号内是属性的访问器</span><br><span class="line">        get</span><br><span class="line">        &#123;</span><br><span class="line">            return experience;</span><br><span class="line">        &#125;           //取值时调用</span><br><span class="line">        set</span><br><span class="line">        &#123;</span><br><span class="line">            experience=value;</span><br><span class="line">        &#125;           //赋值时调用</span><br><span class="line">        //不实现其中一个，就能做到只读或者只写，这是public做不到的</span><br><span class="line">        //2.其可以在内部加函数，或者返回值进行特定转变（例子是用   输入经验值却返回等级</span><br><span class="line">    &#125;</span><br><span class="line">    public int Experience1&#123;get;set;&#125;//缩写 </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class UseProperties : MonoBehaviour</span><br><span class="line">&#123;</span><br><span class="line">    void start()</span><br><span class="line">    &#123;</span><br><span class="line">        Properties myProperties =new Properties();  //在类外使用他</span><br><span class="line">        myProperties.Experience = 5;</span><br><span class="line">        int x=myProperties.Experience;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="2-三元操作符-Ternary-Operator"><a href="#2-三元操作符-Ternary-Operator" class="headerlink" title="2.三元操作符 Ternary Operator"></a>2.三元操作符 Ternary Operator</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">message = health &gt; 0 ? &quot;Player is Alive&quot; : &quot;Player is Dead&quot;; //也可以嵌套循环</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="3-静态类型-Statics"><a href="#3-静态类型-Statics" class="headerlink" title="3.静态类型 Statics"></a>3.静态类型 Statics</h3><p>静态成员可以在类的所有实例被共享，而且其可以通过类直接访问，不需要实例。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class Statics : MonoBehaviour</span><br><span class="line">&#123;</span><br><span class="line">   public static int enemyCount =0;//静态成员属于类本身</span><br><span class="line">   public Statics()</span><br><span class="line">   &#123;</span><br><span class="line">       enemyCount++ ;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class Game</span><br><span class="line">&#123;</span><br><span class="line">    Statics a1=new Statics();</span><br><span class="line">    Statics a2=new Statics();</span><br><span class="line"></span><br><span class="line">    int x=Statics.enemyCount;//直接使用类名.静态成员名</span><br><span class="line">    //静态函数同理。</span><br><span class="line">    //在unity中  Input.GetButton();等都是静态函数！</span><br><span class="line">&#125;//也可以新建一个static类，其内部全是静态成员 例如Unity的Input类</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="4-重载-Overloading"><a href="#4-重载-Overloading" class="headerlink" title="4.重载 Overloading"></a>4.重载 Overloading</h3><p>懒得写了。需要注意的是如果没有完全匹配的重载（ExactMatch)，会类型转化(LeastConversion)，如果还没有就error。</p>
<hr>
<h3 id="5-泛型-Generics"><a href="#5-泛型-Generics" class="headerlink" title="5.泛型 Generics"></a>5.泛型 Generics</h3><p>泛型特性使类和函数等，可以接受类型作为参数。这就允许你编写通用的程序，而不需要知道要处理的数据的具体类型。就例如之前的GetComponent()，利用&lt;&gt;来获取组件，它就是泛型函数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class Generics : MonoBehaviour</span><br><span class="line">&#123;</span><br><span class="line">    public T GenericMethod&lt;T&gt;(T param)</span><br><span class="line">    &#123;</span><br><span class="line">        return param;</span><br><span class="line">    &#125;</span><br><span class="line">	//泛型函数后面可以用where限定T的类型</span><br><span class="line">    public T GenericMethod2&lt;T&gt;(T param) where T : struct    //①struct-value ②class-reference </span><br><span class="line">    &#123;return param;&#125;</span><br><span class="line">    </span><br><span class="line">    public T GenericMethod3&lt;T&gt;(T param) where T : new()     //③new()-公有的不需要参数 ④也可以用具体的类名，确定就是这个类或者其多态 ⑤或者接口</span><br><span class="line">    &#123;return param;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class GenericClass &lt;T&gt; 	//泛型类</span><br><span class="line">&#123;</span><br><span class="line">    T item;</span><br><span class="line">    public void add(T item2)</span><br><span class="line">    &#123;item=item2;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class UseGenerics : MonoBehaviour</span><br><span class="line">&#123;	//具体的使用</span><br><span class="line">    // Start is called before the first frame update</span><br><span class="line">    void Start()</span><br><span class="line">    &#123;</span><br><span class="line">        Generics myGenerics = new Generics();</span><br><span class="line">        myGenerics.GenericMethod&lt;int&gt;(3);</span><br><span class="line"></span><br><span class="line">        GenericClass&lt;int&gt; myClass=new  GenericClass&lt;int&gt;();</span><br><span class="line">        myClass.add(4);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="6-继承-inheritance"><a href="#6-继承-inheritance" class="headerlink" title="6.继承 inheritance"></a>6.继承 inheritance</h3><hr>
<h3 id="7-多态-Polymorphism"><a href="#7-多态-Polymorphism" class="headerlink" title="7.多态 Polymorphism"></a>7.多态 Polymorphism</h3><hr>
<h3 id="8-成员隐藏-MemberHiding"><a href="#8-成员隐藏-MemberHiding" class="headerlink" title="8.成员隐藏 MemberHiding"></a>8.成员隐藏 MemberHiding</h3><p>在继承时，基类成员自动继承到子类中，在子类中重新创建，或叫重新声明，一个基类成员就叫成员隐藏。？ </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class Humanoid</span><br><span class="line">&#123;</span><br><span class="line">    void Yell()</span><br><span class="line">    &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class Enemy : Humanoid</span><br><span class="line">&#123;</span><br><span class="line">    new void Yell() //这样子类被up casting的时候，会默认用父类的Yell()?</span><br><span class="line">    &#123;    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="9-覆盖-Overriding"><a href="#9-覆盖-Overriding" class="headerlink" title="9.覆盖 Overriding"></a>9.覆盖 Overriding</h3><p>指在子类中改变基类方法的行为</p>
<p>对基类函数设置virtual ，对子类函数设置override，即可进行覆盖</p>
<hr>
<h3 id="10-接口-Interfaces"><a href="#10-接口-Interfaces" class="headerlink" title="10.接口 Interfaces"></a>10.接口 Interfaces</h3><p>可以当作对功能的一种约定</p>
<p>实现接口的类，必须拥有所有接口规定的函数和属性。这样子这个类可以被其他类当成接口对待。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public interface IKillable	 //IXXXXable</span><br><span class="line">&#123;</span><br><span class="line">    void Kill();</span><br><span class="line">&#125;</span><br><span class="line">public interface IDamageable&lt;T&gt;</span><br><span class="line">&#123;</span><br><span class="line">    void Damage(T damageTaken);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为实现某个接口，类当中必须显式声明所有接口中的属性，事件，函数，索引器，否则报错。</p>
<p>好处在于，可以跨越类型，定义常用的功能。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class Interfaces : MonoBehaviour , IKillable , IDamageable&lt;float&gt;</span><br><span class="line">&#123;   //必须实现这些接口所需要的函数</span><br><span class="line">    public void Kill()</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void Damage(float damage)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>可能会好奇为什么要用接口。</p>
<p>因为一个类可以实现多个接口，但是只能继承一个父类，所以接口提供更丰富的功能性。</p>
<p>或者说，接口用来定义跨越类的功能，这些类之间无关联。</p>
<hr>
<h3 id="11-扩展方法-Extension-Method"><a href="#11-扩展方法-Extension-Method" class="headerlink" title="11.扩展方法 Extension Method"></a>11.扩展方法 Extension Method</h3><p>用来给类型增加功能，而不用创建一个衍生类型或者修改原类型，非常适用于增加类的功能而不修改类本身。</p>
<p>必须放在无泛型的静态类当中，一般单独创建类去保存它。</p>
<p>也要用static关键字声明，其与静态方法区别关键在于this</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public static class Extension &#123;</span><br><span class="line">    public static void ResetTransformations(this Transform trans) &#123;</span><br><span class="line">        trans.position = Vector3.zero;</span><br><span class="line">        trans.localRotation = Quaternion.identity;</span><br><span class="line">        trans.localScale = Vector3.zero;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ExtensionMethods :MonoBehaviour &#123;</span><br><span class="line">    private void Start() &#123;</span><br><span class="line">        transform.ResetTransformations();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="12-Namespaces"><a href="#12-Namespaces" class="headerlink" title="12.Namespaces"></a>12.Namespaces</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">namespace MyNameSpace&#123;	//create</span><br><span class="line">......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">using MyNameSpace;//using</span><br><span class="line">MyNameSpace.XXX;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="13-列表和字典-Lists-and-Dictionaries"><a href="#13-列表和字典-Lists-and-Dictionaries" class="headerlink" title="13.列表和字典 Lists and Dictionaries"></a>13.列表和字典 Lists and Dictionaries</h3><p>俩个泛型集合。</p>
<p>list 动态数组，提供更大的灵活和丰富的功能</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">using System.Collections.Generic;	//使用前需加入</span><br><span class="line">using System;		//使用list的Sort()功能需要加入</span><br><span class="line"></span><br><span class="line">public class BadGuy : IComparable&lt;BadGuy&gt; //如果要用list的sort功能，需要加入这个接口，语法类似于继承  这个接口又在system命名空间中，所以也要加一个using </span><br><span class="line">&#123;</span><br><span class="line">    public string name;</span><br><span class="line">    public int power;</span><br><span class="line">    public BadGuy(string NewName, int NewPower)&#123;</span><br><span class="line">        name = NewName;</span><br><span class="line">        power = NewPower;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int CompareTo(BadGuy other)  //如果要用list的sort功能，需要加入这个接口，并完成接口的约定，这个接口只需要我们实现这个接口</span><br><span class="line">    &#123;</span><br><span class="line">        if(other == null) return 1;</span><br><span class="line">        return power-other.power;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class list : MonoBehaviour</span><br><span class="line">&#123;</span><br><span class="line">    void Start()</span><br><span class="line">    &#123;</span><br><span class="line">        List&lt;BadGuy&gt; badguys = new List&lt;BadGuy&gt;();</span><br><span class="line"></span><br><span class="line">        badguys.Add(new BadGuy(&quot;Stu1&quot;,100));</span><br><span class="line">        badguys.Add(new BadGuy(&quot;Stu2&quot;,200));</span><br><span class="line">        badguys.Add(new BadGuy(&quot;Stu3&quot;,50));</span><br><span class="line"></span><br><span class="line">       // badguys[0].name;</span><br><span class="line">        badguys.Sort();//排序</span><br><span class="line">        foreach (BadGuy guy in badguys)</span><br><span class="line">        &#123;</span><br><span class="line">            print(guy.name + &quot; &quot; + guy.power);</span><br><span class="line">        &#125;</span><br><span class="line">        badguys.Clear();//清除</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Dictionary工作方式类似，但需要俩种类型。也就是说每个元素由键值对组成，简称kvp。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public class Dictionaaa : MonoBehaviour</span><br><span class="line">&#123;</span><br><span class="line">    void start()</span><br><span class="line">    &#123;</span><br><span class="line">        Dictionary&lt;string,BadGuy&gt; badguys =new Dictionary&lt;string,BadGuy&gt;();</span><br><span class="line">                //第一个参数是key，第二个是value</span><br><span class="line">        BadGuy bg1=new BadGuy(&quot;Harvey&quot;,50);</span><br><span class="line">        BadGuy bg2=new BadGuy(&quot;Magneto&quot;,100);</span><br><span class="line"></span><br><span class="line">        badguys.Add(&quot;aa&quot;,bg1);//需要同时有key和value</span><br><span class="line">        badguys.Add(&quot;bb&quot;,bg2);//add进dictionary</span><br><span class="line"></span><br><span class="line">        BadGuy magnet =badguys[&quot;bb&quot;];   //获取key保存的值，此时key是bb</span><br><span class="line"></span><br><span class="line">        BadGuy temp =null;</span><br><span class="line">        if(badguys.TryGetValue(&quot;birds&quot;,out temp))//如果不确定key是不是存在，可以进行这个函数</span><br><span class="line">        &#123;</span><br><span class="line">            //success</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            //fail</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="14-携程-Coroutine"><a href="#14-携程-Coroutine" class="headerlink" title="14.携程 Coroutine"></a>14.携程 Coroutine</h3><p>可以被看作是间接执行的函数，用yield声明，将代码跳出到函数外，如果继续会回到原处继续执行。可以有效避免update在每一帧使用带来的资源浪费！</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class Coroutine : MonoBehaviour</span><br><span class="line">&#123;</span><br><span class="line">    public float smoothing=1f;</span><br><span class="line">    public Transform target;</span><br><span class="line">    void Start()</span><br><span class="line">    &#123;</span><br><span class="line">        StartCoroutine(MyCoroutine(target));//调用携程</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    IEnumerator MyCoroutine (Transform target)  //返回任何实现了ienumerator接口的东西</span><br><span class="line">    &#123;</span><br><span class="line">        while(Vector3.Distance(transform.position, target.position)&gt;0.05f)  //当俩者距离靠近之后，</span><br><span class="line">        &#123;</span><br><span class="line">            transform.position = Vector3.Lerp(transform.position, target.position,smoothing*Time.deltaTime);//疯狂插值 接近</span><br><span class="line">            yield return null; //跳出等到下次update， yield是重点</span><br><span class="line">        &#125;</span><br><span class="line">        print(&quot;Reached the target&quot;);</span><br><span class="line">        yield return new WaitForSeconds(3f);    //跳出等3s                  </span><br><span class="line">        print(&quot;MyCoroutine is now finished&quot;);   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="15-四元数-Quaternions"><a href="#15-四元数-Quaternions" class="headerlink" title="15.四元数 Quaternions"></a>15.四元数 Quaternions</h3><p>在unity中，四元数保存物体的旋转信息。是个四元向量，xyzw，四个值相互依赖，不能单独更改。</p>
<p>负责处理旋转的系统叫欧拉角，其基于xyz，但其会受限于万向节锁的问题，故不用。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//这是被看物体的移动</span><br><span class="line">public class motion : MonoBehaviour</span><br><span class="line">&#123;</span><br><span class="line">    public float speed =3f;</span><br><span class="line">    void Update()</span><br><span class="line">    &#123;</span><br><span class="line">        transform.Translate(-Input.GetAxis(&quot;Horizontal&quot;)*speed*Time.deltaTime,0,0);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//这是观察者的函数</span><br><span class="line">public class Lookat1 : MonoBehaviour</span><br><span class="line">&#123;</span><br><span class="line">    public Transform target;</span><br><span class="line">    void Update()</span><br><span class="line">    &#123;</span><br><span class="line">        Vector3 relativePos=target.position-transform.position;</span><br><span class="line">        transform.rotation=Quaternion.LookRotation(relativePos);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//绕着target旋转</span><br><span class="line">public class circleRound : MonoBehaviour</span><br><span class="line">&#123;</span><br><span class="line">    public Transform target;</span><br><span class="line"></span><br><span class="line">    void Update()</span><br><span class="line">    &#123;</span><br><span class="line">        Vector3 relativePos =(target.position+new Vector3(0,1.5f,0))-transform.position;</span><br><span class="line">        Quaternion rotation = Quaternion.LookRotation(relativePos);</span><br><span class="line"></span><br><span class="line">        Quaternion current = transform.localRotation;</span><br><span class="line"></span><br><span class="line">        transform.localRotation = Quaternion.Slerp(current, rotation,Time.deltaTime);</span><br><span class="line">        transform.Translate(0,0,3*Time.deltaTime);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="16-委托-Delegates"><a href="#16-委托-Delegates" class="headerlink" title="16.委托 Delegates"></a>16.委托 Delegates</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public class DelegateScript : MonoBehaviour</span><br><span class="line">&#123;</span><br><span class="line">    delegate void MyDelegate(int num);  //我们的委托</span><br><span class="line">    MyDelegate myDelegate;  //创建完委托类型后，接着声明成员变量</span><br><span class="line"></span><br><span class="line">    void PrintNum(int num)</span><br><span class="line">    &#123;</span><br><span class="line">        print(&quot;PrintNum&quot;+num);</span><br><span class="line">    &#125;</span><br><span class="line">    void DoubleNum(int num)</span><br><span class="line">    &#123;</span><br><span class="line">        print(&quot;Double Num&quot; + num);</span><br><span class="line">    &#125;</span><br><span class="line">        void Start()</span><br><span class="line">    &#123;</span><br><span class="line">        myDelegate = PrintNum;  //类似于函数指针，还是很好懂的</span><br><span class="line">        myDelegate(50); //输出就是PrintNum50</span><br><span class="line"></span><br><span class="line">        myDelegate =DoubleNum;</span><br><span class="line">        myDelegate(50);</span><br><span class="line"></span><br><span class="line">        myDelegate +=PrintNum; //委托广播，可以包含很多函数</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="17-特性-Attributes"><a href="#17-特性-Attributes" class="headerlink" title="17.特性 Attributes"></a>17.特性 Attributes</h3><p>特性能在声明时，对函数变量或者类添加额外信息。（这里好像只讲了俩个</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">using UnityEngine;</span><br><span class="line">using System.Collections;</span><br><span class="line"></span><br><span class="line">[ExecuteInEditMode] </span><br><span class="line">//这个特性允许代码在场景中就生效，而不是运行时才生效，可以进行实时更改，无法还原</span><br><span class="line">//需要写在整个代码上面，毕竟是对全体代码生效的</span><br><span class="line">public class spin : MonoBehaviour &#123;</span><br><span class="line"></span><br><span class="line">    [Range(-100,100)]   //这里把特性放在变量声明上面</span><br><span class="line">    public int speed=0;</span><br><span class="line"></span><br><span class="line">    [Range(-100,100)] public int maxSpeed;	//第二种写法，限定范围</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    void Update()</span><br><span class="line">    &#123;</span><br><span class="line">        transform.Rotate(new Vector3(0,speed*Time.deltaTime,0));</span><br><span class="line">        //按y轴旋转对象   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="18-事件-Events"><a href="#18-事件-Events" class="headerlink" title="18.事件 Events"></a>18.事件 Events</h3><p>相当于公共的广播委托，用于提醒其他类有什么事发生了。 有点难理解，于是查阅发现以下解释：</p>
<p>“事件是拥有可以注册和解绑方法（函数）的功能。</p>
<p>虽然事件和委托看起来有点绕，只要捋清楚事件和委托的关系，就会很容易理解。</p>
<p>委托是一个类，事件则是委托类中的一个对象，该对象是能够把其他方法注册到委托类中的一个事件（如果觉得有点绕，可以忽略这句话）。</p>
<p>事件和函数的关系：事件具有可以注册多个函数（和解绑函数）的功能，而函数如果要注册和解绑其他在其主体上运行的函数则需要改动该函数本体的代码，这就是区别。</p>
<p>以下代码的大致流程：定义一个新类（事件类）–》类中声明委托–》由委托类又声明事件–》再定义触发事件的函数–》函数主体中执行事件–》在主函数中实例化事件类–》进而调用事件类中的事件对象–》事件对象再注册（+=）两个方法–》再执行事件类中触发事件的那个函数–》再解绑其中一个方法–》再次执行事件类中触发事件的函数。</p>
<p>由此可见：事件是拥有可以注册和解绑方法（函数）的功能。”</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line"></span><br><span class="line">namespace DelegateAndEvent</span><br><span class="line">&#123;</span><br><span class="line">    //定义一个事件类</span><br><span class="line">    public class MyEvent</span><br><span class="line">    &#123;</span><br><span class="line">        //定义一个委托</span><br><span class="line">        public delegate void MyDelegate();</span><br><span class="line">        //定义一个事件</span><br><span class="line">        public MyDelegate MyDelegateEvent;</span><br><span class="line">        //定义一个触发事件的函数</span><br><span class="line">        public void OnMyDelegateEvent()</span><br><span class="line">        &#123;</span><br><span class="line">            //判断事件是否非空</span><br><span class="line">            if (MyDelegateEvent != null)</span><br><span class="line">            &#123;</span><br><span class="line">                //执行事件</span><br><span class="line">                MyDelegateEvent();</span><br><span class="line">            &#125;</span><br><span class="line">            //MyDelegateEvent?.Invoke(); //简化的判断和执行</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    class Program</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        //输出一串字符</span><br><span class="line">        public static void putOutChar()</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(&quot;I was fired&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        //输出第二串字符</span><br><span class="line">        public static void putOutChar2()</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(&quot;I was fired22222&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        static void Main(string[] args)</span><br><span class="line">        &#123;</span><br><span class="line">            //实例化MyEvent2类</span><br><span class="line">            MyEvent myEvent = new MyEvent();</span><br><span class="line">            //注册一个事件</span><br><span class="line">            myEvent.MyDelegateEvent += new MyEvent.MyDelegate(putOutChar);</span><br><span class="line">            myEvent.MyDelegateEvent += new MyEvent.MyDelegate(putOutChar2);</span><br><span class="line">            //执行触发事件的函数</span><br><span class="line">            Console.WriteLine(&quot;执行绑定了两个事件后的函数&quot;);</span><br><span class="line">            myEvent.OnMyDelegateEvent();</span><br><span class="line">            //解绑一个事件</span><br><span class="line">            myEvent.MyDelegateEvent -= new MyEvent.MyDelegate(putOutChar);</span><br><span class="line">            //再次执行触发事件的函数</span><br><span class="line">            Console.WriteLine(&quot;执行解绑了一个事件后的函数&quot;);</span><br><span class="line">            myEvent.OnMyDelegateEvent();</span><br><span class="line">            Console.ReadKey();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>又或者“<strong>delegate</strong> 相当于定义一个函数类型。</p>
<p><strong>event</strong> 相当于定义一个 <strong>delegate</strong> 的函数指针（回调函数指针）。”</p>
</blockquote>
<hr>
<h3 id="Thanks"><a href="#Thanks" class="headerlink" title="Thanks:"></a>Thanks:</h3><p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1hs411r7ZM?spm_id_from=333.999.0.0">https://www.bilibili.com/video/BV1hs411r7ZM?spm_id_from=333.999.0.0</a></p>
<p><a target="_blank" rel="noopener" href="https://www.runoob.com/csharp/csharp-event.html">https://www.runoob.com/csharp/csharp-event.html</a></p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Es411t7rL?p=10">https://www.bilibili.com/video/BV1Es411t7rL?p=10</a></p>
<p>只是不求甚解地过了一遍，具体还是要在实践中熟练了，才算学会。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/11/02/Unity-IntermediateScript/" data-id="ckvxh4904000jrccfcjwwbru0" data-title="Unity-IntermediateScript" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Unity/" rel="tag">Unity</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Unity-BasicScript2" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/10/31/Unity-BasicScript2/" class="article-date">
  <time class="dt-published" datetime="2021-10-31T10:47:11.000Z" itemprop="datePublished">2021-10-31</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/10/31/Unity-BasicScript2/">Unity-BasicScript2</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>[TOC]</p>
<h3 id="1-DataTypes"><a href="#1-DataTypes" class="headerlink" title="1.DataTypes"></a>1.DataTypes</h3><p>初级分为Value和Reference</p>
<p>Value：int float double bool char Structs{Vector3,Quatenion}</p>
<p>Reference: Classes{Transform,GameObject}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void Start()</span><br><span class="line">    &#123;</span><br><span class="line">        Transform tran=transform;	//这里的transform就是组件 故是地址 共同改变了属于是</span><br><span class="line">        tran.position = new Vector3(0,0,2);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="2-类的使用"><a href="#2-类的使用" class="headerlink" title="2.类的使用"></a>2.类的使用</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class Fuc1&#123;</span><br><span class="line">       int a1;</span><br><span class="line">    	public Fun1(int aa1)&#123;	//Constructor //no return value</span><br><span class="line">           a1=aa1;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">public Fuc1 fuc1=new Fuc1();</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="3-Instantiate"><a href="#3-Instantiate" class="headerlink" title="3.Instantiate()"></a>3.Instantiate()</h3><p>Instantiate函数实例化是将original对象的所有子物体和子组件完全复制，成为一个新的对象。这个新的对象拥有与源对象完全一样的东西，包括坐标值等。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public Rigidbody rocketPrefab;	//需要绑定一个带Rigidbody的物体</span><br><span class="line">	public Transform barrelEnd;	//需要绑定一个(空)物体,坐标就是生成位置</span><br><span class="line">   void Update()</span><br><span class="line">   &#123;</span><br><span class="line">       if(Input.GetKeyDown(KeyCode.K))</span><br><span class="line">       &#123;	//在Inspector中绑定物品即可 //可以用来生成子弹</span><br><span class="line">           Instantiate(rocketPrefab);</span><br><span class="line">           //第二种 第二三个参数是新克隆体的位置和旋转值</span><br><span class="line">           Instantiate(rocketPrefab,barrelEnd.position,barrelEnd.rotation);   </span><br><span class="line">           //第三种，当作刚体可以进行力的施加</span><br><span class="line">           Rigidbody rocketRigid;</span><br><span class="line">           rocketRigid=Instantiate(rocketPrefab,barrelEnd.position,barrelEnd.rotation) as Rigidbody;</span><br><span class="line">           rocketRigid.AddForce(Vector3.up * 500);</span><br><span class="line">           //因为克隆出来的物体会一直存在，所以如果是子弹什么的可以加一个定时销毁的脚本</span><br><span class="line">       &#125;	</span><br><span class="line">   &#125;	</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="4-数组Array"><a href="#4-数组Array" class="headerlink" title="4.数组Array"></a>4.数组Array</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int[] array1=new int[4];</span><br><span class="line">   int[] array2=&#123;1,3,54,53&#125;;</span><br><span class="line">   public GameObject[] players;  //public即可界面编辑</span><br><span class="line">   void Start()</span><br><span class="line">   &#123;</span><br><span class="line">       array1[0]=2;</span><br><span class="line">       players=GameObject.FindGameObjectsWithTag(&quot;player&quot;);//用指定的标签去寻找</span><br><span class="line">       for (int i = 0; i &lt; players.Length; i++)</span><br><span class="line">           Debug.Log(&quot;Goodbye&quot;+i+players[i].name);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="5-Invoke"><a href="#5-Invoke" class="headerlink" title="5.Invoke()"></a>5.Invoke()</h3><p>允许安排一个延时调用的函数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public Object target;</span><br><span class="line">    void SpawnObject()</span><br><span class="line">    &#123;</span><br><span class="line">        float x=Random.Range(-3.0f, 3.0f);</span><br><span class="line">        float z=Random.Range(-3.0f, 3.0f);</span><br><span class="line">        Instantiate(target,new Vector3(x,1,z),Quaternion.identity);</span><br><span class="line">    &#125;</span><br><span class="line">    void Start()</span><br><span class="line">    &#123;</span><br><span class="line">        Invoke(&quot;SpawnObject&quot;,2);</span><br><span class="line">        //延时俩秒调用 </span><br><span class="line">        //只有不需要传入参数，且返回类型为void的函数才能用Invoke调用</span><br><span class="line">        InvokeRepeating(&quot;SpawnObject&quot;,2,1);</span><br><span class="line">        //延时俩秒调用，并且之后每隔一秒调用一次</span><br><span class="line">        CancelInvoke();</span><br><span class="line">        CancelInvoke(&quot;SpawnObject&quot;);</span><br><span class="line">        //停止延时调用</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="6-Enumeration-Enum"><a href="#6-Enumeration-Enum" class="headerlink" title="6.Enumeration/Enum"></a>6.Enumeration/Enum</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">enum Enum1&#123; North, East, South, West&#125;;	</span><br><span class="line">//enum 可以写在class外/注意大写 因为这是类不是变量/注意最后的；</span><br><span class="line">   void Start()</span><br><span class="line">   &#123;</span><br><span class="line">       Enum1 myEnum;</span><br><span class="line">       myEnum = Enum1.North;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<p>Thanks：</p>
<p>Unity官方脚本P3： <a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV17s411o7Mf?p=3">https://www.bilibili.com/video/BV17s411o7Mf?p=3</a></p>
<p>Unity入门路线： <a target="_blank" rel="noopener" href="https://www.zhihu.com/question/314175363/answer/650214605">https://www.zhihu.com/question/314175363/answer/650214605</a></p>
<hr>
<p>突然想到或许我可以做一个roft学长的3d卡牌对战游戏，但是在同时加入摄像机旋转切换游戏玩家，实现双人同时玩的卡牌游戏…挺有意思的。roft学长的游戏很多用low-poly，好喜欢这个风格。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/10/31/Unity-BasicScript2/" data-id="ckvxh48zy0006rccf1ifg2zyk" data-title="Unity-BasicScript2" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Unity/" rel="tag">Unity</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Unity-BasicScript" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/10/31/Unity-BasicScript/" class="article-date">
  <time class="dt-published" datetime="2021-10-31T05:55:53.000Z" itemprop="datePublished">2021-10-31</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/10/31/Unity-BasicScript/">Unity-BasicScript1</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>[TOC]</p>
<h3 id="1-在Unity中似乎把组件（inspecter中的属性）当成类使用，在C-中需创建类的实例，并用GetComponent获取才可以对其操作。"><a href="#1-在Unity中似乎把组件（inspecter中的属性）当成类使用，在C-中需创建类的实例，并用GetComponent获取才可以对其操作。" class="headerlink" title="1.在Unity中似乎把组件（inspecter中的属性）当成类使用，在C#中需创建类的实例，并用GetComponent获取才可以对其操作。"></a>1.在Unity中似乎把组件（inspecter中的属性）当成类使用，在C#中需创建类的实例，并用GetComponent获取才可以对其操作。</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">private Light light1;</span><br><span class="line">private CharacterController cc; // 获得该组件</span><br><span class="line">	private Vector3 dir;    //储存移动的方向</span><br><span class="line">   private void Start()</span><br><span class="line">   &#123;</span><br><span class="line">       cc = GetComponent&lt;CharacterController&gt;();</span><br><span class="line">       light1=GetComponent&lt;Light&gt;();</span><br><span class="line">   &#125;</span><br><span class="line">private void Update()</span><br><span class="line">   &#123;</span><br><span class="line">       if (Input.GetKeyDown())</span><br><span class="line">       &#123;</span><br><span class="line">           light1.enabled = !light1.enabled;</span><br><span class="line">       &#125;</span><br><span class="line">       cc.Move(dir * Time.deltaTime);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-似乎发现上方有GetKey-和GetButton-，有何不同呢"><a href="#2-似乎发现上方有GetKey-和GetButton-，有何不同呢" class="headerlink" title="2.似乎发现上方有GetKey()和GetButton()，有何不同呢"></a>2.似乎发现上方有GetKey()和GetButton()，有何不同呢</h3><p>区别在于：</p>
<p>GetKey需传入KeyCode.XX，如Input.GetKeyDown(KeyCode.Space)。</p>
<p>而GetButton则传入提前预设好的键位：如Input.GetButtonDown(“Jump”)。</p>
<p>路径：Edit-Project Setting-Input Manager 。好处在于你可以详细地设计键位，使得键盘手柄可以共用。</p>
<p><img src="/2021/10/31/Unity-BasicScript/image-20211031143205933.png" alt="image-20211031143205933"></p>
<h3 id="3-在以下代码中，定义了一个GameObject的实例，但是这需要在脚本组件中自行选择Object拖入，毕竟在代码中也不能选择更高维度的咯（或许可以）。"><a href="#3-在以下代码中，定义了一个GameObject的实例，但是这需要在脚本组件中自行选择Object拖入，毕竟在代码中也不能选择更高维度的咯（或许可以）。" class="headerlink" title="3.在以下代码中，定义了一个GameObject的实例，但是这需要在脚本组件中自行选择Object拖入，毕竟在代码中也不能选择更高维度的咯（或许可以）。"></a>3.在以下代码中，定义了一个GameObject的实例，但是这需要在脚本组件中自行选择Object拖入，毕竟在代码中也不能选择更高维度的咯（或许可以）。</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class DetectIsActive : MonoBehaviour</span><br><span class="line">&#123;</span><br><span class="line">    public GameObject myObject;</span><br><span class="line">    // Start is called before the first frame update</span><br><span class="line">    void Start()</span><br><span class="line">    &#123;</span><br><span class="line">        Debug.Log(&quot;DetectIsActive&quot; +myObject.activeSelf);</span><br><span class="line">        Debug.Log(&quot;DetectIsActive2&quot; +myObject.activeInHierarchy);</span><br><span class="line">        gameObject.SetActive(false);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2021/10/31/Unity-BasicScript/image-20211031144323263.png" alt="image-20211031144323263"></p>
<p>另外，这里用active来判定其物体是否激活，当然也要看父组件的激活情况。</p>
<h3 id="4-Translate-Rotate"><a href="#4-Translate-Rotate" class="headerlink" title="4.Translate() Rotate()"></a>4.Translate() Rotate()</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public float moveSpeed=3f;</span><br><span class="line">  public float turnSpeed=1f;</span><br><span class="line">  void Update()</span><br><span class="line">  &#123;	//注意transform大小写 /(ㄒoㄒ)/~~</span><br><span class="line">      transform.Translate(new Vector3(0,0,3)*moveSpeed*Time.deltaTime);</span><br><span class="line">      transform.Translate(Vector3.forward*moveSpeed*Time.deltaTime); </span><br><span class="line">      //forward = 物体自己的z 等同于上行  </span><br><span class="line">      transform.Translate(transform.forward * moveSpeed *Time.deltaTime);</span><br><span class="line">      //而Transform.forward则是当前物体的正方向</span><br><span class="line">      transform.Rotate(Vector3.up,-turnSpeed*Time.deltaTime); </span><br><span class="line">      //up代表其旋转绕的向量轴（也就是y）</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-LookAt"><a href="#5-LookAt" class="headerlink" title="5.LookAt()"></a>5.LookAt()</h3><p>指定给摄像机，并绑定target即可。<del>（但是试不出来…</del> (原来是错放在start函数里了，并且需要关掉其他脚本才可运行。))</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public Transform target;</span><br><span class="line">   // Start is called before the first frame update</span><br><span class="line">   void Update()//Start()</span><br><span class="line">   &#123;</span><br><span class="line">       transform.LookAt(target);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-Destory"><a href="#5-Destory" class="headerlink" title="5.Destory()"></a>5.Destory()</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void Update()</span><br><span class="line">    &#123;</span><br><span class="line">        if(Input.GetKeyDown(KeyCode.J))</span><br><span class="line">        &#123;</span><br><span class="line">            Destroy(gameObject);    //删除自己</span><br><span class="line">            Destroy(other);     //删除绑定的物体</span><br><span class="line">            Destroy(GetComponent&lt;Light&gt;());     //删除其组件 </span><br><span class="line">            Destroy(GetComponent&lt;Light&gt;(),3f);     //延迟3秒 删除其组件 </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-GetAxis"><a href="#6-GetAxis" class="headerlink" title="6.GetAxis()"></a>6.GetAxis()</h3><p>返回-1~1的bool ，需指定Horizontal或者Vertical，实例可以看上次的FPS Blog。</p>
<p><img src="/2021/10/31/Unity-BasicScript/image-20211031153023092.png" alt="image-20211031153023092"></p>
<p>同上在Input Manager可管理gravity：从1-0的回复速度</p>
<p>Sensitivity：从0-1的变化速度</p>
<p>Dead： 响应盲区，去避免摇杆微弱的误触</p>
<p>Snap：允许俩边同时响应时返回0</p>
<p>也可以用Input.GetAxisRaw()只返回整数，可以精确操控</p>
<h3 id="7-OnMouseDown"><a href="#7-OnMouseDown" class="headerlink" title="7.OnMouseDown()"></a>7.OnMouseDown()</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void OnMouseDown() </span><br><span class="line">   &#123;</span><br><span class="line">       GetComponent&lt;Rigidbody&gt;().AddForce(transform.forward*300);  //给一个物体z方向的力</span><br><span class="line">       GetComponent&lt;Rigidbody&gt;().useGravity=true;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h3 id="8"><a href="#8" class="headerlink" title="8."></a>8.<img src="/2021/10/31/Unity-BasicScript/image-20211031161545879.png" alt="image-20211031161545879"></h3><hr>
<h3 id="Thanks"><a href="#Thanks" class="headerlink" title="Thanks:"></a>Thanks:</h3><p>Unity-Transform类：<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_42446849/article/details/81669864">https://blog.csdn.net/weixin_42446849/article/details/81669864</a></p>
<p>Unity官方脚本开发初级教程：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1cs411o7GD?p=5">https://www.bilibili.com/video/BV1cs411o7GD?p=5</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/10/31/Unity-BasicScript/" data-id="ckvxh48zx0005rccfcxms24a1" data-title="Unity-BasicScript1" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Unity/" rel="tag">Unity</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Unity-FPS控制" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/10/29/Unity-FPS%E6%8E%A7%E5%88%B6/" class="article-date">
  <time class="dt-published" datetime="2021-10-29T12:39:42.000Z" itemprop="datePublished">2021-10-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/10/29/Unity-FPS%E6%8E%A7%E5%88%B6/">Unity1-FPS控制</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <!--好好学Unity从今天开始(lll￢ω￢)-->

<h2 id="一-FPS控制"><a href="#一-FPS控制" class="headerlink" title="一.FPS控制"></a>一.FPS控制</h2><p>1.导入assets建立场景， 创建一个player并将main camera绑定至player下即可。</p>
<p>2.为camera编写视角控制脚本：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">using System.Collections;</span><br><span class="line">using System.Collections.Generic;		</span><br><span class="line">using UnityEngine;</span><br><span class="line"></span><br><span class="line">public class Player : MonoBehaviour</span><br><span class="line">&#123;</span><br><span class="line">    public Transform player;//用于获取transform组件</span><br><span class="line">    </span><br><span class="line">    private float mouseX, mouseY;   //获取鼠标移动的值</span><br><span class="line">    public float mouseSensitivity;	//鼠标灵敏度</span><br><span class="line">    public float xRotation; </span><br><span class="line"></span><br><span class="line">    private void Update ()</span><br><span class="line">    &#123;</span><br><span class="line">        mouseX = Input.GetAxis(&quot;Mouse X&quot;) * mouseSensitivity * Time.deltaTime;</span><br><span class="line">        mouseY = Input.GetAxis(&quot;Mouse Y&quot;) * mouseSensitivity * Time.deltaTime;  		//GetAxis() 返回 -1_~1 向左,下是-1，向右,上是1</span><br><span class="line">        //Time.deltaTime 是变量 指完成上一帧所用的时间 防止FPS波动导致的time波动</span><br><span class="line"></span><br><span class="line">        xRotation -= mouseY; //累加 </span><br><span class="line">        xRotation = Mathf.Clamp(xRotation, -70f, 70f);//限制视角</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        player.Rotate(Vector3.up * mouseX);</span><br><span class="line">        transform.localRotation = Quaternion.Euler(xRotation, 0, 0);//四元数（TODO</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>3.为player编写移动脚本：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">using System.Collections;</span><br><span class="line">using System.Collections.Generic;</span><br><span class="line">using UnityEngine;</span><br><span class="line"></span><br><span class="line">public class RealPlayer : MonoBehaviour</span><br><span class="line">&#123;</span><br><span class="line">    private CharacterController cc; // 用于获得CharacterController组件</span><br><span class="line">    public float moveSpeed;</span><br><span class="line">    public float jumpSpeed;</span><br><span class="line"></span><br><span class="line">    private float horizontalMove, verticalMove;</span><br><span class="line">    private Vector3 dir;    //储存移动的方向</span><br><span class="line"></span><br><span class="line">    public float gravity;</span><br><span class="line">    private Vector3 velocity;// 重力加速度</span><br><span class="line"></span><br><span class="line">    public Transform groundCheck; //为了检测与地面的碰撞</span><br><span class="line">    public float checkRadius;  </span><br><span class="line">    public LayerMask groundLayer;</span><br><span class="line">    public bool isGround;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    private void Start()</span><br><span class="line">    &#123;</span><br><span class="line">        cc = GetComponent&lt;CharacterController&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void Update()</span><br><span class="line">    &#123;</span><br><span class="line">        isGround = Physics.CheckSphere(groundCheck.position,checkRadius,groundLayer);</span><br><span class="line">        if(isGround &amp;&amp; velocity.y&lt;0)</span><br><span class="line">        &#123;</span><br><span class="line">            velocity.y = -2f;//防止落地后 加速度不停下降     值会影响自由落体的手感     </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        horizontalMove = Input.GetAxis(&quot;Horizontal&quot;)*moveSpeed;</span><br><span class="line">        verticalMove = Input.GetAxis(&quot;Vertical&quot;)*moveSpeed;</span><br><span class="line"></span><br><span class="line">        dir = transform.forward * verticalMove + transform.right * horizontalMove;</span><br><span class="line">        cc.Move(dir * Time.deltaTime);</span><br><span class="line"></span><br><span class="line">        if(Input.GetButtonDown(&quot;Jump&quot;) /*&amp;&amp; isGround*/)</span><br><span class="line">        &#123;</span><br><span class="line">            velocity.y = jumpSpeed;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        velocity.y -= gravity * Time.deltaTime;//每秒减去重力的值</span><br><span class="line">        cc.Move(velocity * Time.deltaTime); //自由落体的公式 要乘以时间的二次方 故多乘</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>4.别忘记在Inspector中删去player的碰撞，加入Character Controller。</p>
<p>新建空物体附在player下面，命名Ground Check，并赋给脚本中的groundCheck。再调整其高度在player的脚底板，以检测碰撞。在Inspector的layer中，新建ground层并将场景的全部environment设置为ground层。再将脚本中的那个层设为该ground层就大功告成了。</p>
<p><img src="/2021/10/29/Unity-FPS%E6%8E%A7%E5%88%B6/20211029210158.png" alt="20211029210158"></p>
<p><img src="/2021/10/29/Unity-FPS%E6%8E%A7%E5%88%B6/202110292119.gif" alt="202110292119"></p>
<p><del>5.借用室友调侃的话说：做出原神指日可待 (￣▽￣)”  遥遥无期</del></p>
<p>感谢：</p>
<p>Time.deltaTime 理解: <a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_37608784/article/details/84859597">https://blog.csdn.net/weixin_37608784/article/details/84859597</a></p>
<p>Unity Documentation: <a target="_blank" rel="noopener" href="https://docs.unity3d.com/cn/2021.1/ScriptReference/index.html">https://docs.unity3d.com/cn/2021.1/ScriptReference/index.html</a></p>
<p>​    <a target="_blank" rel="noopener" href="https://docs.unity3d.com/cn/2019.3/ScriptReference/Quaternion.Euler.html">https://docs.unity3d.com/cn/2019.3/ScriptReference/Quaternion.Euler.html</a></p>
<p>Unity asset store：<a target="_blank" rel="noopener" href="https://assetstore.unity.com/?q=low-poly%20simple%20nature&amp;orderBy=1">https://assetstore.unity.com/?q=low-poly%20simple%20nature&amp;orderBy=1</a></p>
<p>Blend Swap: <a target="_blank" rel="noopener" href="https://blendswap.com/blend/26019#">https://blendswap.com/blend/26019#</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/10/29/Unity-FPS%E6%8E%A7%E5%88%B6/" data-id="ckvxh4902000grccf3uwtbsfk" data-title="Unity1-FPS控制" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Unity/" rel="tag">Unity</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Proustian-Effect" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/10/27/Proustian-Effect/" class="article-date">
  <time class="dt-published" datetime="2021-10-27T02:09:39.000Z" itemprop="datePublished">2021-10-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/10/27/Proustian-Effect/">Proustian Effect 「普鲁斯特效应」</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>“20世纪法国最伟大的小说家之一，马塞尔·普鲁斯特(1871-1922，Marcel Proust)，在其作品中写到这样一段轶事：</p>
<blockquote>
<p><em>And soon, mechanically, weary after a dull day with the prospect of a depressing morrow, I raised to my lips a spoonful of the tea in which I had soaked a morsel of the cake. No sooner had the warm liquid, and the crumbs with it, touched my palate than a shudder ran through my whole body, and I stopped, intent upon the extraordinary changes that were taking place. . . . I was conscious that it was connected with the taste of tea and cake, but that it infinitely transcended those savours, could not, indeed, be of the same nature as theirs.   <strong>Marcel Proust, “In Search of Lost Time”</strong></em></p>
</blockquote>
<p>被茶浸泡的糕点的气味使作者想起了童年的经历。这段被糕点气味唤醒的记忆，既生动，又包含情感。”</p>
<p>普特鲁斯效应 指当你闻到一种特定气味时，就会忽然想起已经遗忘了的回忆，这种效应发生时回忆起的场景往往极其生动形象，而且饱含情感。</p>
<p>不只是气味，气温、光照、天气、声音、味道、特殊的滤镜都能唤起记忆中的往事以及当时伴随着的情绪。但似乎气味是最容易被记住，也是最容易让我们唤起过往的记忆的。</p>
<p>“秋季充满了普鲁斯特效应~”  （奇特的是我并没有感受到秋天</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/10/27/Proustian-Effect/" data-id="ckvxh48zu0002rccf1hp8el8g" data-title="Proustian Effect 「普鲁斯特效应」" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%9A%8F%E8%AE%B0/" rel="tag">随记</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-MY-FIRST-BLOG" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/10/26/MY-FIRST-BLOG/" class="article-date">
  <time class="dt-published" datetime="2021-10-26T11:53:15.000Z" itemprop="datePublished">2021-10-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/10/26/MY-FIRST-BLOG/">MY FIRST BLOG!</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>行吧 辛苦了一阵子 可能总算是把这个破博客弄好了~<br>有缘更新！</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/10/26/MY-FIRST-BLOG/" data-id="ckvxh48zp0000rccf858r7r8a" data-title="MY FIRST BLOG!" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/OpenGL/" rel="tag">OpenGL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Unity/" rel="tag">Unity</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%9A%8F%E8%AE%B0/" rel="tag">随记</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/OpenGL/" style="font-size: 15px;">OpenGL</a> <a href="/tags/Unity/" style="font-size: 20px;">Unity</a> <a href="/tags/%E9%9A%8F%E8%AE%B0/" style="font-size: 10px;">随记</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/11/">November 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/10/">October 2021</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/11/12/OpenGL-%E4%B8%B4%E6%97%B6%E7%AC%94-%E9%94%AE%E7%9B%98-%E8%AE%B0/">OpenGL-临时笔(键盘)记</a>
          </li>
        
          <li>
            <a href="/2021/11/12/OpenGL-1/">OpenGL_1</a>
          </li>
        
          <li>
            <a href="/2021/11/07/%E5%B8%83%E6%96%99%E6%A8%A1%E6%8B%9F/">布料模拟</a>
          </li>
        
          <li>
            <a href="/2021/11/03/Unity%E6%9D%82%E8%AE%B0/">Unity杂记</a>
          </li>
        
          <li>
            <a href="/2021/11/02/Unity-IntermediateScript/">Unity-IntermediateScript</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2021 Zhairest<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>