<!DOCTYPE html>
<html lang=zh>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5" />
    <meta name="description" content="C++基础C++ STL标准库基础 vector 详解 string详解 queue详解 unordered_map      unordered_map4种遍历方式 int转为string：string src &#x3D; to_string(num); c++unordered_map中的find()查找函数: ​    在容器中搜索键值等于 k 的元素，如果找到，则返回一个指向该元素的迭代器，否则返">
<meta property="og:type" content="article">
<meta property="og:title" content="算法合集 C++ 剑指Offer">
<meta property="og:url" content="http://example.com/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/index.html">
<meta property="og:site_name" content="旋转公寓的阁楼">
<meta property="og:description" content="C++基础C++ STL标准库基础 vector 详解 string详解 queue详解 unordered_map      unordered_map4种遍历方式 int转为string：string src &#x3D; to_string(num); c++unordered_map中的find()查找函数: ​    在容器中搜索键值等于 k 的元素，如果找到，则返回一个指向该元素的迭代器，否则返">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/image-20230310110433552.png">
<meta property="og:image" content="http://example.com/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/image-20230310110545093.png">
<meta property="og:image" content="http://example.com/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/image-20230310110623326.png">
<meta property="og:image" content="http://example.com/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/image-20230310110703417.png">
<meta property="og:image" content="http://example.com/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/image-20230310111801195.png">
<meta property="og:image" content="http://example.com/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/image-20230310124214167.png">
<meta property="og:image" content="http://example.com/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/image-20230310130259308.png">
<meta property="og:image" content="http://example.com/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/image-20230310130539704.png">
<meta property="og:image" content="http://example.com/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/image-20230310131649500.png">
<meta property="og:image" content="http://example.com/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/image-20230310133610109.png">
<meta property="og:image" content="http://example.com/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/v2-17700257363921acdbd5718beaed8266_720w.webp">
<meta property="og:image" content="http://example.com/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/image-20230311135947556.png">
<meta property="og:image" content="http://example.com/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/image-20230310132214593.png">
<meta property="og:image" content="http://example.com/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/image-20230310134237927.png">
<meta property="og:image" content="http://example.com/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/image-20230310134247523.png">
<meta property="og:image" content="http://example.com/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/image-20230310141619639.png">
<meta property="og:image" content="http://example.com/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/image-20230310142321486.png">
<meta property="og:image" content="http://example.com/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/image-20230310142419564.png">
<meta property="og:image" content="http://example.com/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/image-20230310142505665.png">
<meta property="og:image" content="http://example.com/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/image-20230310150347481.png">
<meta property="og:image" content="http://example.com/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/image-20230310150402602.png">
<meta property="og:image" content="http://example.com/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/image-20230310155856278.png">
<meta property="og:image" content="http://example.com/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/image-20230310160043917.png">
<meta property="og:image" content="http://example.com/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/image-20230311130018890.png">
<meta property="og:image" content="http://example.com/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/image-20230311133455387.png">
<meta property="og:image" content="http://example.com/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/image-20230311134340534-1678513421403-1.png">
<meta property="og:image" content="http://example.com/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/image-20230311134432069.png">
<meta property="og:image" content="http://example.com/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/image-20230311140828931.png">
<meta property="og:image" content="http://example.com/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/image-20230311143745545.png">
<meta property="og:image" content="http://example.com/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/image-20230311144142877.png">
<meta property="og:image" content="http://example.com/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/image-20230311144218175.png">
<meta property="og:image" content="http://example.com/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/image-20230311144640021.png">
<meta property="og:image" content="http://example.com/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/image-20230311145643385.png">
<meta property="og:image" content="http://example.com/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/image-20230311151330683.png">
<meta property="og:image" content="http://example.com/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/image-20230311152006923.png">
<meta property="og:image" content="http://example.com/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/image-20230311152054563.png">
<meta property="og:image" content="http://example.com/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/image-20230311152124613.png">
<meta property="og:image" content="http://example.com/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/image-20230311153002478.png">
<meta property="og:image" content="http://example.com/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/image-20230311162128491.png">
<meta property="og:image" content="http://example.com/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/image-20230312160400179.png">
<meta property="og:image" content="http://example.com/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/image-20230312162453617.png">
<meta property="og:image" content="http://example.com/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/image-20230312162837680.png">
<meta property="og:image" content="http://example.com/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/image-20230312165703584.png">
<meta property="og:image" content="http://example.com/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/image-20230312165756171.png">
<meta property="og:image" content="http://example.com/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/image-20230312170001133.png">
<meta property="og:image" content="http://example.com/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/image-20230312170011685.png">
<meta property="og:image" content="http://example.com/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/image-20230312172947289.png">
<meta property="og:image" content="http://example.com/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/image-20230312173126674.png">
<meta property="article:published_time" content="2023-03-10T03:03:42.000Z">
<meta property="article:modified_time" content="2023-03-12T09:31:28.879Z">
<meta property="article:author" content="Frostsea">
<meta property="article:tag" content="算法">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/image-20230310110433552.png">
    
    
      
        
          <link rel="shortcut icon" href="/images/favicon.ico">
        
      
      
        
          <link rel="icon" type="image/png" href="/images/favicon-192x192.png" sizes="192x192">
        
      
      
        
          <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
        
      
    
    <!-- title -->
    <title>算法合集 C++ 剑指Offer</title>
    <!-- styles -->
    
<link rel="stylesheet" href="/css/style.css">

    <!-- persian styles -->
    
    <!-- rss -->
    
    
	<!-- mathjax -->
	
<meta name="generator" content="Hexo 5.4.0"></head>

<body class="max-width mx-auto px3 ltr">
    
      <div id="header-post">
  <a id="menu-icon" href="#" aria-label="目录"><i class="fas fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#" aria-label="目录"><i class="fas fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" aria-label="顶部" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fas fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
        <!--
       --><li><a href="/">首页</a></li><!--
     --><!--
       --><li><a href="/about/">关于</a></li><!--
     --><!--
       --><li><a href="/archives/">归档</a></li><!--
     -->
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        <li><a class="icon" aria-label="上一篇" href="/2023/03/10/Unity%E5%9F%BA%E7%A1%80/"><i class="fas fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" aria-label="下一篇" href="/2023/03/08/Csharp_%E5%9F%BA%E7%A1%80/"><i class="fas fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" aria-label="返回顶部" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" aria-label="分享文章" href="#"><i class="fas fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">上一篇</span>
      <span id="i-next" class="info" style="display:none;">下一篇</span>
      <span id="i-top" class="info" style="display:none;">返回顶部</span>
      <span id="i-share" class="info" style="display:none;">分享文章</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=http://example.com/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=http://example.com/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/&text=算法合集 C++ 剑指Offer"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=http://example.com/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/&title=算法合集 C++ 剑指Offer"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=http://example.com/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/&is_video=false&description=算法合集 C++ 剑指Offer"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=算法合集 C++ 剑指Offer&body=Check out this article: http://example.com/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/"><i class="fas fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=http://example.com/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/&title=算法合集 C++ 剑指Offer"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=http://example.com/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/&title=算法合集 C++ 剑指Offer"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=http://example.com/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/&title=算法合集 C++ 剑指Offer"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=http://example.com/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/&title=算法合集 C++ 剑指Offer"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=http://example.com/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/&name=算法合集 C++ 剑指Offer&description="><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=http://example.com/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/&t=算法合集 C++ 剑指Offer"><i class="fab fa-hacker-news " aria-hidden="true"></i></a></li>
</ul>

    </div>
    <div id="toc">
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#C-%E5%9F%BA%E7%A1%80"><span class="toc-number">1.</span> <span class="toc-text">C++基础</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%80%92%E5%BD%92%E4%B8%8E%E5%88%86%E6%B2%BB%EF%BC%8C%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%8C%E8%B4%AA%E5%BF%83%EF%BC%8C%E5%9B%9E%E6%BA%AF%EF%BC%8C%E5%88%86%E6%94%AF%E7%95%8C%E9%99%90%E6%B3%95"><span class="toc-number">2.</span> <span class="toc-text">递归与分治，动态规划，贪心，回溯，分支界限法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%90%9C%E7%B4%A2%E4%B8%8E%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9B%B8%E5%85%B3"><span class="toc-number">3.</span> <span class="toc-text">搜索与回溯算法 二叉树相关</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#32-%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E5%87%BA%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%AF%8F%E4%B8%AA%E8%8A%82%E7%82%B9%EF%BC%8C%E5%90%8C%E4%B8%80%E5%B1%82%E7%9A%84%E8%8A%82%E7%82%B9%E6%8C%89%E7%85%A7%E4%BB%8E%E5%B7%A6%E5%88%B0%E5%8F%B3%E7%9A%84%E9%A1%BA%E5%BA%8F%E6%89%93%E5%8D%B0%E3%80%82"><span class="toc-number">3.0.1.</span> <span class="toc-text">32.从上到下打印出二叉树的每个节点，同一层的节点按照从左到右的顺序打印。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#32-%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%8C%89%E5%B1%82%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%8C%E5%90%8C%E4%B8%80%E5%B1%82%E7%9A%84%E8%8A%82%E7%82%B9%E6%8C%89%E4%BB%8E%E5%B7%A6%E5%88%B0%E5%8F%B3%E7%9A%84%E9%A1%BA%E5%BA%8F%E6%89%93%E5%8D%B0%EF%BC%8C%E6%AF%8F%E4%B8%80%E5%B1%82%E6%89%93%E5%8D%B0%E5%88%B0%E4%B8%80%E8%A1%8C%E3%80%82"><span class="toc-number">3.0.2.</span> <span class="toc-text">32.从上到下按层打印二叉树，同一层的节点按从左到右的顺序打印，每一层打印到一行。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#32-%E8%AF%B7%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%87%BD%E6%95%B0%E6%8C%89%E7%85%A7%E4%B9%8B%E5%AD%97%E5%BD%A2%E9%A1%BA%E5%BA%8F%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%8C%E5%8D%B3%E7%AC%AC%E4%B8%80%E8%A1%8C%E6%8C%89%E7%85%A7%E4%BB%8E%E5%B7%A6%E5%88%B0%E5%8F%B3%E7%9A%84%E9%A1%BA%E5%BA%8F%E6%89%93%E5%8D%B0%EF%BC%8C%E7%AC%AC%E4%BA%8C%E5%B1%82%E6%8C%89%E7%85%A7%E4%BB%8E%E5%8F%B3%E5%88%B0%E5%B7%A6%E7%9A%84%E9%A1%BA%E5%BA%8F%E6%89%93%E5%8D%B0%EF%BC%8C%E7%AC%AC%E4%B8%89%E8%A1%8C%E5%86%8D%E6%8C%89%E7%85%A7%E4%BB%8E%E5%B7%A6%E5%88%B0%E5%8F%B3%E7%9A%84%E9%A1%BA%E5%BA%8F%E6%89%93%E5%8D%B0%EF%BC%8C%E5%85%B6%E4%BB%96%E8%A1%8C%E4%BB%A5%E6%AD%A4%E7%B1%BB%E6%8E%A8%E3%80%82"><span class="toc-number">3.0.3.</span> <span class="toc-text">32.请实现一个函数按照之字形顺序打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右到左的顺序打印，第三行再按照从左到右的顺序打印，其他行以此类推。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#33-%E8%BE%93%E5%85%A5%E4%B8%80%E4%B8%AA%E6%95%B4%E6%95%B0%E6%95%B0%E7%BB%84%EF%BC%8C%E5%88%A4%E6%96%AD%E8%AF%A5%E6%95%B0%E7%BB%84%E6%98%AF%E4%B8%8D%E6%98%AF%E6%9F%90%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E7%BB%93%E6%9E%9C%E3%80%82%E5%A6%82%E6%9E%9C%E6%98%AF%E5%88%99%E8%BF%94%E5%9B%9E-true%EF%BC%8C%E5%90%A6%E5%88%99%E8%BF%94%E5%9B%9E-false%E3%80%82%E5%81%87%E8%AE%BE%E8%BE%93%E5%85%A5%E7%9A%84%E6%95%B0%E7%BB%84%E7%9A%84%E4%BB%BB%E6%84%8F%E4%B8%A4%E4%B8%AA%E6%95%B0%E5%AD%97%E9%83%BD%E4%BA%92%E4%B8%8D%E7%9B%B8%E5%90%8C%E3%80%82"><span class="toc-number">3.0.4.</span> <span class="toc-text">33.输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历结果。如果是则返回 true，否则返回 false。假设输入的数组的任意两个数字都互不相同。</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%EF%BC%9A"><span class="toc-number">3.0.4.1.</span> <span class="toc-text">解题思路：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B7%E4%BD%93%E5%9C%B0%EF%BC%8C%E6%88%91%E4%BB%AC%E5%8F%AF%E4%BB%A5%E9%A6%96%E5%85%88%E6%89%BE%E5%88%B0%E6%A0%B9%E8%8A%82%E7%82%B9%E7%9A%84%E4%BD%8D%E7%BD%AE%EF%BC%8C%E7%84%B6%E5%90%8E%E5%88%86%E5%88%AB%E9%80%92%E5%BD%92%E5%88%A4%E6%96%AD%E5%B7%A6%E5%AD%90%E6%A0%91%E5%92%8C%E5%8F%B3%E5%AD%90%E6%A0%91%E6%98%AF%E5%90%A6%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E3%80%82"><span class="toc-number">3.0.4.2.</span> <span class="toc-text">具体地，我们可以首先找到根节点的位置，然后分别递归判断左子树和右子树是否为二叉搜索树。</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%90%9C%E7%B4%A2%E4%B8%8E%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95-%E6%A0%91%E7%9B%B8%E5%85%B3"><span class="toc-number">4.</span> <span class="toc-text">搜索与回溯算法 树相关</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#26-%E8%BE%93%E5%85%A5%E4%B8%A4%E6%A3%B5%E4%BA%8C%E5%8F%89%E6%A0%91A%E5%92%8CB%EF%BC%8C%E5%88%A4%E6%96%ADB%E6%98%AF%E4%B8%8D%E6%98%AFA%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84%E3%80%82-%E7%BA%A6%E5%AE%9A%E7%A9%BA%E6%A0%91%E4%B8%8D%E6%98%AF%E4%BB%BB%E6%84%8F%E4%B8%80%E4%B8%AA%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84"><span class="toc-number">4.0.1.</span> <span class="toc-text">26.输入两棵二叉树A和B，判断B是不是A的子结构。(约定空树不是任意一个树的子结构)</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%A7%E5%AE%B6%E6%95%B4%E4%BD%93%E9%80%BB%E8%BE%91%E4%B8%80%E8%87%B4%EF%BC%8C%E9%83%BD%E6%98%AF%EF%BC%9A"><span class="toc-number">4.0.1.0.1.</span> <span class="toc-text">大家整体逻辑一致，都是：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AD%90%E5%87%BD%E6%95%B0iscontain%E7%94%A8%E6%9D%A5%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E8%A2%AB%E5%8C%85%E5%90%AB%EF%BC%8C%E9%80%BB%E8%BE%91%E4%B9%9F%E5%BE%88%E7%AE%80%E5%8D%95%EF%BC%9A%E5%A6%82%E6%9E%9CAB%E8%8A%82%E7%82%B9%E7%9B%B8%E7%AD%89%E5%B0%B1%E5%8E%BB%E5%88%A4%E6%96%AD%E5%90%84%E5%AD%90%E6%A0%91%EF%BC%8C%E5%A6%82%E6%9E%9C%E4%B8%8D%E6%83%B3%E7%AD%89%E7%9B%B4%E6%8E%A5%E8%BF%94%E5%9B%9E%E5%81%87%E3%80%82"><span class="toc-number">4.0.1.0.2.</span> <span class="toc-text">子函数iscontain用来判断是否被包含，逻辑也很简单：如果AB节点相等就去判断各子树，如果不想等直接返回假。</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#27-%E8%AF%B7%E5%AE%8C%E6%88%90%E4%B8%80%E4%B8%AA%E5%87%BD%E6%95%B0%EF%BC%8C%E8%BE%93%E5%85%A5%E4%B8%80%E4%B8%AA%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%8C%E8%AF%A5%E5%87%BD%E6%95%B0%E8%BE%93%E5%87%BA%E5%AE%83%E7%9A%84%E9%95%9C%E5%83%8F%E3%80%82"><span class="toc-number">4.0.2.</span> <span class="toc-text">27.请完成一个函数，输入一个二叉树，该函数输出它的镜像。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#28-%E8%AF%B7%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%87%BD%E6%95%B0%EF%BC%8C%E7%94%A8%E6%9D%A5%E5%88%A4%E6%96%AD%E4%B8%80%E6%A3%B5%E4%BA%8C%E5%8F%89%E6%A0%91%E6%98%AF%E4%B8%8D%E6%98%AF%E5%AF%B9%E7%A7%B0%E7%9A%84%E3%80%82%E5%A6%82%E6%9E%9C%E4%B8%80%E6%A3%B5%E4%BA%8C%E5%8F%89%E6%A0%91%E5%92%8C%E5%AE%83%E7%9A%84%E9%95%9C%E5%83%8F%E4%B8%80%E6%A0%B7%EF%BC%8C%E9%82%A3%E4%B9%88%E5%AE%83%E6%98%AF%E5%AF%B9%E7%A7%B0%E7%9A%84%E3%80%82"><span class="toc-number">4.0.3.</span> <span class="toc-text">28.请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92Dynamic-programming-DP"><span class="toc-number">5.</span> <span class="toc-text">动态规划Dynamic programming(DP)</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">5.1.</span> <span class="toc-text">基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%A0%B7%E7%9A%84%E9%97%AE%E9%A2%98%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="toc-number">5.1.1.</span> <span class="toc-text">什么样的问题可以使用动态规划</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%9A%84%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF"><span class="toc-number">5.1.2.</span> <span class="toc-text">动态规划的解题思路</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E7%A9%B7%E4%B8%BE%E5%88%86%E6%9E%90"><span class="toc-number">5.1.2.1.</span> <span class="toc-text">1. 穷举分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E7%A1%AE%E5%AE%9A%E8%BE%B9%E7%95%8C"><span class="toc-number">5.1.2.2.</span> <span class="toc-text">2. 确定边界</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E6%89%BE%E8%A7%84%E5%BE%8B%EF%BC%8C%E7%A1%AE%E5%AE%9A%E6%9C%80%E4%BC%98%E5%AD%90%E7%BB%93%E6%9E%84"><span class="toc-number">5.1.2.3.</span> <span class="toc-text">3. 找规律，确定最优子结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E5%86%99%E5%87%BA%E7%8A%B6%E6%80%81%E8%BD%AC%E7%A7%BB%E6%96%B9%E7%A8%8B"><span class="toc-number">5.1.2.4.</span> <span class="toc-text">4.写出状态转移方程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-number">5.1.2.5.</span> <span class="toc-text">5. 代码实现</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E4%BF%97%E7%9A%84%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E8%A7%A3%E9%A2%98%E6%AD%A5%E9%AA%A4"><span class="toc-number">5.1.3.</span> <span class="toc-text">通俗的动态规划解题步骤</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%84%E9%80%A0dp%E6%95%B0%E7%BB%84"><span class="toc-number">5.1.3.1.</span> <span class="toc-text">构造dp数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B4%E8%A7%82%E4%B8%8A%E7%9A%84%E7%8A%B6%E6%80%81%E8%BD%AC%E7%A7%BB"><span class="toc-number">5.1.3.2.</span> <span class="toc-text">直观上的状态转移</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%BE%E8%A7%84%E5%BE%8B"><span class="toc-number">5.1.3.3.</span> <span class="toc-text">找规律</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%9A%84%E6%9D%A5%E8%AF%B4%EF%BC%8C%E6%8B%BF%E5%88%B0%E4%B8%80%E9%81%93%E9%A2%98%E7%9B%AE%E5%90%8E%EF%BC%8C%E6%88%91%E4%BB%AC%E5%8F%AF%E4%BB%A5%E6%8C%89%E7%85%A7%E4%B8%8B%E9%9D%A2%E7%9A%84%E6%AD%A5%E9%AA%A4%E8%BF%9B%E8%A1%8C%E5%88%86%E6%9E%90%E3%80%81%E5%B0%9D%E8%AF%95%EF%BC%9A"><span class="toc-number">5.1.3.4.</span> <span class="toc-text">总的来说，拿到一道题目后，我们可以按照下面的步骤进行分析、尝试：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%EF%BC%88Fibonacci%EF%BC%89"><span class="toc-number">5.2.</span> <span class="toc-text">斐波那契（Fibonacci）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BE%88%E6%98%8E%E6%98%BE%EF%BC%8C%E7%94%A8%E9%80%92%E5%BD%92%E7%9B%B4%E6%8E%A5%E8%B6%85%E6%97%B6%EF%BC%8C%E8%BF%98%E5%BE%97%E6%98%AF%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%81"><span class="toc-number">5.2.1.</span> <span class="toc-text">很明显，用递归直接超时，还得是动态规划！</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%88%96%E8%80%85%E7%94%A8%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2-%E9%99%8D%E4%BD%8E%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="toc-number">5.2.2.</span> <span class="toc-text">或者用记忆化搜索 降低复杂度</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%92%E8%9B%99%E8%B7%B3%E5%8F%B0%E9%98%B6"><span class="toc-number">5.3.</span> <span class="toc-text">青蛙跳台阶</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E6%9C%89%E5%87%A0%E4%B8%AA%E5%85%B8%E5%9E%8B%E7%89%B9%E5%BE%81%EF%BC%8C%E6%9C%80%E4%BC%98%E5%AD%90%E7%BB%93%E6%9E%84%E3%80%81%E7%8A%B6%E6%80%81%E8%BD%AC%E7%A7%BB%E6%96%B9%E7%A8%8B%E3%80%81%E8%BE%B9%E7%95%8C%E3%80%81%E9%87%8D%E5%8F%A0%E5%AD%90%E9%97%AE%E9%A2%98%E3%80%82%E5%9C%A8%E9%9D%92%E8%9B%99%E8%B7%B3%E9%98%B6%E9%97%AE%E9%A2%98%E4%B8%AD%EF%BC%9A"><span class="toc-number">5.3.1.</span> <span class="toc-text">动态规划有几个典型特征，最优子结构、状态转移方程、边界、重叠子问题。在青蛙跳阶问题中：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E4%BC%98%E5%AD%90%E7%BB%93%E6%9E%84"><span class="toc-number">5.3.2.</span> <span class="toc-text">最优子结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E5%8F%A0%E5%AD%90%E9%97%AE%E9%A2%98"><span class="toc-number">5.3.3.</span> <span class="toc-text">重叠子问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E5%A4%A7%E5%88%A9%E6%B6%A6"><span class="toc-number">5.4.</span> <span class="toc-text">股票的最大利润</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C"><span class="toc-number">5.5.</span> <span class="toc-text">连续子数组的最大和</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF%E4%B8%80"><span class="toc-number">5.5.0.1.</span> <span class="toc-text">思路一</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF%E4%BA%8C"><span class="toc-number">5.5.0.2.</span> <span class="toc-text">思路二</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E4%BA%8E%E5%9B%9E%E6%BA%AF%E6%B3%95%E4%B8%8EDP"><span class="toc-number">5.5.0.3.</span> <span class="toc-text">关于回溯法与DP</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BC%E7%89%A9%E7%9A%84%E6%9C%80%E5%A4%A7%E4%BB%B7%E5%80%BC"><span class="toc-number">5.6.</span> <span class="toc-text">礼物的最大价值</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%92%E5%BD%92%EF%BC%88%E5%9B%9E%E6%BA%AF%E6%B3%95%EF%BC%89%E6%96%B9%E6%B3%95"><span class="toc-number">5.6.1.</span> <span class="toc-text">递归（回溯法）方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2%EF%BC%88%E5%9B%9E%E6%BA%AF%E6%B3%95%EF%BC%89%EF%BC%88%E5%8D%B3%E8%AE%B0%E5%BD%95%E4%B9%8B%E5%89%8D%E7%9A%84%E5%80%BC%EF%BC%89"><span class="toc-number">5.6.2.</span> <span class="toc-text">记忆化搜索（回溯法）（即记录之前的值）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E6%96%B9%E6%B3%95"><span class="toc-number">5.6.3.</span> <span class="toc-text">动态规划方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E5%AD%97%E7%BF%BB%E8%AF%91%E6%88%90%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">5.7.</span> <span class="toc-text">数字翻译成字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BB%E8%A6%81%E6%80%9D%E8%B7%AF"><span class="toc-number">5.7.1.</span> <span class="toc-text">主要思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0"><span class="toc-number">5.7.2.</span> <span class="toc-text">具体实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E9%95%BF%E4%B8%8D%E5%90%AB%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">5.8.</span> <span class="toc-text"> 最长不含重复字符的子字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9A%E5%BC%80%E5%A7%8B%E6%80%9D%E8%B7%AF"><span class="toc-number">5.8.1.</span> <span class="toc-text">刚开始思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BD%A2%EF%BC%8C%E7%9C%8B%E5%AE%98%E6%96%B9%E9%A2%98%E8%A7%A3"><span class="toc-number">5.8.2.</span> <span class="toc-text">罢，看官方题解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8C%E6%8C%87%E9%92%88%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0"><span class="toc-number">5.8.3.</span> <span class="toc-text">双指针具体实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0"><span class="toc-number">5.8.4.</span> <span class="toc-text">动态规划具体实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%A0%E4%B8%BA%E6%AF%8F%E6%AC%A1dp%E7%BB%93%E6%9E%9C%E5%8F%AA%E4%B8%8E%E4%B8%8A%E4%B8%80%E6%AC%A1dp%E7%9A%84%E7%BB%93%E6%9E%9C%E6%9C%89%E5%85%B3%EF%BC%8C%E5%B0%86%E4%B8%8A%E8%BF%B0%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%BE%97%E5%88%B0"><span class="toc-number">5.8.4.1.</span> <span class="toc-text">因为每次dp结果只与上一次dp的结果有关，将上述代码优化空间复杂度得到</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%98-%E5%AD%97%E6%AF%8D%E4%B8%8E%E6%95%B0%E5%AD%97"><span class="toc-number">5.9.</span> <span class="toc-text">面试题 字母与数字</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%8C%E6%8C%87%E9%92%88"><span class="toc-number">6.</span> <span class="toc-text">双指针</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%91%E6%8C%87-Offer-18-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E8%8A%82%E7%82%B9"><span class="toc-number">6.1.</span> <span class="toc-text">剑指 Offer 18. 删除链表的节点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%91%E6%8C%87-Offer-22-%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E8%8A%82%E7%82%B9"><span class="toc-number">6.2.</span> <span class="toc-text">剑指 Offer 22. 链表中倒数第k个节点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%91%E6%8C%87-Offer-25-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%8E%92%E5%BA%8F%E7%9A%84%E9%93%BE%E8%A1%A8"><span class="toc-number">6.3.</span> <span class="toc-text">剑指 Offer 25. 合并两个排序的链表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%91%E6%8C%87-Offer-52-%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%AC%E5%85%B1%E8%8A%82%E7%82%B9"><span class="toc-number">6.4.</span> <span class="toc-text">剑指 Offer 52. 两个链表的第一个公共节点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%91%E6%8C%87-Offer-21-%E8%B0%83%E6%95%B4%E6%95%B0%E7%BB%84%E9%A1%BA%E5%BA%8F%E4%BD%BF%E5%A5%87%E6%95%B0%E4%BD%8D%E4%BA%8E%E5%81%B6%E6%95%B0%E5%89%8D%E9%9D%A2"><span class="toc-number">6.5.</span> <span class="toc-text">剑指 Offer 21. 调整数组顺序使奇数位于偶数前面</span></a></li></ol></li></ol>
    </div>
  </span>
</div>

    
    <div class="content index py4">
        
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle" itemprop="name headline">
        算法合集 C++ 剑指Offer
    </h1>



    <div class="meta">
      <span class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span itemprop="name">Frostsea</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2023-03-10T03:03:42.000Z" itemprop="datePublished">2023-03-10</time>
        
      
    </div>


      

      
    <div class="article-tag">
        <i class="fas fa-tag"></i>
        <a class="tag-link-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a>
    </div>


    </div>
  </header>
  

  <div class="content" itemprop="articleBody">
    <h1 id="C-基础"><a href="#C-基础" class="headerlink" title="C++基础"></a>C++基础</h1><p><a target="_blank" rel="noopener" href="http://m.biancheng.net/stl/stl_basic/">C++ STL标准库基础</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qiancm/article/details/119611928">vector 详解</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/acc_hoyh/article/details/122974190">string详解</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_42185999/article/details/115331051">queue详解</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/langyao/p/8823092.html">unordered_map</a>      <a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_21539375/article/details/122003559">unordered_map4种遍历方式</a></p>
<p>int转为string：string src = to_string(num);</p>
<p>c++unordered_map中的find()查找函数:</p>
<p>​    在容器中搜索键值等于 k 的元素，如果找到，则返回一个指向该元素的迭代器，否则返回一个指向<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=unordered_map&spm=1001.2101.3001.7020">unordered_map</a> :: end的迭代器。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 找到了，则返回对应的数字</span></span><br><span class="line">     <span class="keyword">if</span>(tags_map.<span class="built_in">find</span>(hand[i]) != tags_map.<span class="built_in">end</span>())</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_42604176/article/details/108984456">什么时候用 “.” 什么时候用“-＞”</a></p>
<h1 id="递归与分治，动态规划，贪心，回溯，分支界限法"><a href="#递归与分治，动态规划，贪心，回溯，分支界限法" class="headerlink" title="递归与分治，动态规划，贪心，回溯，分支界限法"></a>递归与分治，动态规划，贪心，回溯，分支界限法</h1><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_37995835/article/details/117667634">五大类常见算法 （递归与分治，动态规划，贪心，回溯，分支界限法）</a></p>
<h1 id="搜索与回溯算法-二叉树相关"><a href="#搜索与回溯算法-二叉树相关" class="headerlink" title="搜索与回溯算法 二叉树相关"></a>搜索与回溯算法 二叉树相关</h1><p>剑指Offer题目</p>
<h3 id="32-从上到下打印出二叉树的每个节点，同一层的节点按照从左到右的顺序打印。"><a href="#32-从上到下打印出二叉树的每个节点，同一层的节点按照从左到右的顺序打印。" class="headerlink" title="32.从上到下打印出二叉树的每个节点，同一层的节点按照从左到右的顺序打印。"></a>32.从上到下打印出二叉树的每个节点，同一层的节点按照从左到右的顺序打印。</h3><img src="/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/image-20230310110433552.png" class title="image-20230310110433552">

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">levelOrder</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//二叉树的层序遍历</span></span><br><span class="line">        <span class="comment">//利用队列先进先出的特性</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        queue&lt;TreeNode*&gt; q;</span><br><span class="line">        q.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            TreeNode* node =q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            ans.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">            <span class="keyword">if</span>(node-&gt;left) q.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">            <span class="keyword">if</span>(node-&gt;right) q.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="32-从上到下按层打印二叉树，同一层的节点按从左到右的顺序打印，每一层打印到一行。"><a href="#32-从上到下按层打印二叉树，同一层的节点按从左到右的顺序打印，每一层打印到一行。" class="headerlink" title="32.从上到下按层打印二叉树，同一层的节点按从左到右的顺序打印，每一层打印到一行。"></a>32.从上到下按层打印二叉树，同一层的节点按从左到右的顺序打印，每一层打印到一行。</h3><img src="/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/image-20230310110545093.png" class title="image-20230310110545093">

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">levelOrder</span>(TreeNode* root) &#123;</span><br><span class="line">                </span><br><span class="line">        <span class="comment">/* 根据函数返回值定义存储结果的变量 */</span></span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; result;</span><br><span class="line">        <span class="comment">/* 定义一个队列用于存储节点的数据 */</span></span><br><span class="line">        queue&lt;TreeNode*&gt; que;</span><br><span class="line">        <span class="comment">/* 判空 */</span></span><br><span class="line">        <span class="keyword">if</span>(root != <span class="literal">NULL</span>) que.<span class="built_in">push</span>(root);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 开始层序遍历 */</span></span><br><span class="line">        <span class="keyword">while</span>(!que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="comment">/* 计算队列的大小也即有多少个孩子 */</span></span><br><span class="line">            <span class="keyword">int</span> size = que.<span class="built_in">size</span>();</span><br><span class="line">            <span class="comment">/* 定义一个临时vector 存储每一层 */</span></span><br><span class="line">            vector&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line">            <span class="comment">/* 层序遍历 */</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                <span class="comment">/* 获取第一个节点数据 */</span></span><br><span class="line">                TreeNode* node = que.<span class="built_in">front</span>();</span><br><span class="line">                que.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">                vec.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">                <span class="keyword">if</span>(node-&gt;left != <span class="literal">NULL</span>) que.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">                <span class="keyword">if</span>(node-&gt;right != <span class="literal">NULL</span>) que.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/* 将一层的数据保存 */</span></span><br><span class="line">            result.<span class="built_in">push_back</span>(vec);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="32-请实现一个函数按照之字形顺序打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右到左的顺序打印，第三行再按照从左到右的顺序打印，其他行以此类推。"><a href="#32-请实现一个函数按照之字形顺序打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右到左的顺序打印，第三行再按照从左到右的顺序打印，其他行以此类推。" class="headerlink" title="32.请实现一个函数按照之字形顺序打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右到左的顺序打印，第三行再按照从左到右的顺序打印，其他行以此类推。"></a>32.请实现一个函数按照之字形顺序打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右到左的顺序打印，第三行再按照从左到右的顺序打印，其他行以此类推。</h3><img src="/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/image-20230310110623326.png" class title="image-20230310110623326">

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">levelOrder</span>(TreeNode* root) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;res;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>) <span class="keyword">return</span> res;</span><br><span class="line">       </span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> flag=<span class="number">-1</span>;</span><br><span class="line">        queue&lt;TreeNode*&gt;q;</span><br><span class="line">        q.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="keyword">int</span> q_size=q.<span class="built_in">size</span>();</span><br><span class="line">            res.<span class="built_in">push_back</span>(vector&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">            flag=-flag;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;q_size;i++)&#123;</span><br><span class="line">                <span class="keyword">auto</span> s=q.<span class="built_in">front</span>();</span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line">                res.<span class="built_in">back</span>().<span class="built_in">push_back</span>(s-&gt;val);</span><br><span class="line">                <span class="keyword">if</span>(s-&gt;left)&#123;q.<span class="built_in">push</span>(s-&gt;left);&#125;</span><br><span class="line">                <span class="keyword">if</span>(s-&gt;right)&#123;q.<span class="built_in">push</span>(s-&gt;right);&#125;</span><br><span class="line">            &#125;</span><br><span class="line">                <span class="keyword">if</span>(flag==<span class="number">-1</span>)&#123;<span class="built_in">reverse</span>(res.<span class="built_in">back</span>().<span class="built_in">begin</span>(),res.<span class="built_in">back</span>().<span class="built_in">end</span>());&#125;<span class="comment">//翻转输出</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<h3 id="33-输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历结果。如果是则返回-true，否则返回-false。假设输入的数组的任意两个数字都互不相同。"><a href="#33-输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历结果。如果是则返回-true，否则返回-false。假设输入的数组的任意两个数字都互不相同。" class="headerlink" title="33.输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历结果。如果是则返回 true，否则返回 false。假设输入的数组的任意两个数字都互不相同。"></a>33.输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历结果。如果是则返回 <code>true</code>，否则返回 <code>false</code>。假设输入的数组的任意两个数字都互不相同。</h3><img src="/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/image-20230310110703417.png" class title="image-20230310110703417">

<h4 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h4><p><strong>二叉搜索树（BST）</strong>的定义是：对于任意一个节点，它的左子树的所有节点的值都小于该节点的值，而它的右子树的所有节点的值都大于该节点的值。</p>
<p>二叉搜索树的后序遍历序列中，最后一个数字是树的根节点的值，而前面的数字可以分为两部分：</p>
<ol>
<li><strong>第一部分是左子树节点的值，它们都小于根节点的值；</strong></li>
<li><strong>第二部分是右子树节点的值，它们都大于根节点的值。</strong></li>
</ol>
<p>我们可以根据这个特点，递归地判断每个子树是否符合二叉搜索树的定义。</p>
<h4 id="具体地，我们可以首先找到根节点的位置，然后分别递归判断左子树和右子树是否为二叉搜索树。"><a href="#具体地，我们可以首先找到根节点的位置，然后分别递归判断左子树和右子树是否为二叉搜索树。" class="headerlink" title="具体地，我们可以首先找到根节点的位置，然后分别递归判断左子树和右子树是否为二叉搜索树。"></a>具体地，我们可以首先找到根节点的位置，然后分别递归判断左子树和右子树是否为二叉搜索树。</h4><p>​    递归的过程中，需要注意以下几点：</p>
<ol>
<li>对于左子树和右子树，需要分别处理前半部分和后半部分的数组；</li>
<li>对于空子树，直接返回 true；</li>
<li>对于只有一个节点的子树，也认为它是二叉搜索树。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">verifyPostorder</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; sequence)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(sequence.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">int</span> n = sequence.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> root = sequence[n - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; n - <span class="number">1</span> &amp;&amp; sequence[i] &lt; root) &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> j = i;</span><br><span class="line">        <span class="keyword">while</span> (j &lt; n - <span class="number">1</span> &amp;&amp; sequence[j] &gt; root) &#123;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (j != n - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">left</span><span class="params">(sequence.begin(), sequence.begin() + i)</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">right</span><span class="params">(sequence.begin() + i, sequence.end() - <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">return</span> (left.<span class="built_in">empty</span>() || <span class="built_in">verifyPostorder</span>(left)) &amp;&amp; (right.<span class="built_in">empty</span>() || <span class="built_in">verifyPostorder</span>(right));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>









<h1 id="搜索与回溯算法-树相关"><a href="#搜索与回溯算法-树相关" class="headerlink" title="搜索与回溯算法 树相关"></a>搜索与回溯算法 树相关</h1><h3 id="26-输入两棵二叉树A和B，判断B是不是A的子结构。-约定空树不是任意一个树的子结构"><a href="#26-输入两棵二叉树A和B，判断B是不是A的子结构。-约定空树不是任意一个树的子结构" class="headerlink" title="26.输入两棵二叉树A和B，判断B是不是A的子结构。(约定空树不是任意一个树的子结构)"></a>26.输入两棵二叉树A和B，判断B是不是A的子结构。(约定空树不是任意一个树的子结构)</h3><p>B是A的子结构， 即 A中有出现和B相同的结构和节点值。</p>
<img src="/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/image-20230310111801195.png" class title="image-20230310111801195">

<p>​    刚开始的思路就是对俩颗树进行先序遍历，若A遍历结果包含了B，则输出true</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">Cclass Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">     <span class="function"><span class="keyword">bool</span> <span class="title">isSubStructure</span><span class="params">(TreeNode* A, TreeNode* B)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//可以改写为判断 二者的先序遍历中有无相同部分</span></span><br><span class="line">        string a1=<span class="built_in">XianXu</span>(A);</span><br><span class="line">        string a2=<span class="built_in">XianXu</span>(B);</span><br><span class="line">        <span class="keyword">if</span>(a2==<span class="string">&quot;&quot;</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> a1.<span class="built_in">find</span>(a2);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">string <span class="title">XianXu</span><span class="params">(TreeNode* node)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        string ans;</span><br><span class="line">        <span class="keyword">if</span>(node==<span class="literal">NULL</span>) <span class="keyword">return</span> ans;</span><br><span class="line">        </span><br><span class="line">        TreeNode* temp=node;</span><br><span class="line">        ans+=(temp-&gt;val);</span><br><span class="line">        queue&lt;TreeNode*&gt; q;</span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            q.<span class="built_in">push</span>(temp);</span><br><span class="line">            <span class="keyword">if</span>(temp-&gt;left) &#123;q.<span class="built_in">push</span>(temp-&gt;left);</span><br><span class="line">                ans+=(temp-&gt;left-&gt;val);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(temp-&gt;right) &#123;q.<span class="built_in">push</span>(temp-&gt;right);ans+=(temp-&gt;left-&gt;val);&#125;</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            temp=q.<span class="built_in">front</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但很明显，用string返回，一旦出现负数或俩位数，就寄！wssb</p>
<p>直到我看见下面这种，哈哈哈</p>
<h5 id="大家整体逻辑一致，都是："><a href="#大家整体逻辑一致，都是：" class="headerlink" title="大家整体逻辑一致，都是："></a>大家整体逻辑一致，都是：</h5><p>如果AB相等就去判断AB是否为同一棵树，如果为真就返回真，如果为假，<br>就先让B和A的左子树进行对比，如果为真就返回真，如果为假，<br>再让B和A的右子树进行对比，如果为真就返回真，如果为假，那就返回。</p>
<h5 id="子函数iscontain用来判断是否被包含，逻辑也很简单：如果AB节点相等就去判断各子树，如果不想等直接返回假。"><a href="#子函数iscontain用来判断是否被包含，逻辑也很简单：如果AB节点相等就去判断各子树，如果不想等直接返回假。" class="headerlink" title="子函数iscontain用来判断是否被包含，逻辑也很简单：如果AB节点相等就去判断各子树，如果不想等直接返回假。"></a>子函数iscontain用来判断是否被包含，逻辑也很简单：如果AB节点相等就去判断各子树，如果不想等直接返回假。</h5><p>个人认为其中的一个小点也是要点是前两个if判断。</p>
<p>因为我们认为B是A的子结构，递归判断过程中</p>
<p>如果B为空说明已经判断完毕，可以返回真了，<br>如果B没完A却完了说明，不是子结构直接返回假。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">//输入两棵二叉树，判断B是不是A的子结构</span></span><br><span class="line">        <span class="comment">//思路：DFS，即先序遍历，然后判断A的每个节点都作为根节点是否可以跟B相匹配</span></span><br><span class="line">        <span class="comment">//匹配成功则返回true，匹配到空节点都还未成功则返回false</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//树A是否是树B的子结构</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSubStructure</span><span class="params">(TreeNode* A, TreeNode* B)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(B == <span class="literal">NULL</span> || A == <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//遍历A中的每一个节点，若是包含B则返回true</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">isContain</span>(A, B) || <span class="built_in">isSubStructure</span>(A-&gt;left, B) || <span class="built_in">isSubStructure</span>(A-&gt;right, B);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//以A为根节点的树是否包含B</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isContain</span><span class="params">(TreeNode* A, TreeNode* B)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(B == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(A == <span class="literal">NULL</span> || A-&gt;val != B-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">isContain</span>(A-&gt;left, B-&gt;left) &amp;&amp; <span class="built_in">isContain</span>(A-&gt;right, B-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<h3 id="27-请完成一个函数，输入一个二叉树，该函数输出它的镜像。"><a href="#27-请完成一个函数，输入一个二叉树，该函数输出它的镜像。" class="headerlink" title="27.请完成一个函数，输入一个二叉树，该函数输出它的镜像。"></a>27.请完成一个函数，输入一个二叉树，该函数输出它的镜像。</h3><img src="/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/image-20230310124214167.png" class title="image-20230310124214167">

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">mirrorTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>) <span class="keyword">return</span> root;</span><br><span class="line">        <span class="keyword">bool</span> leftEmpty=<span class="literal">false</span>, rightEmpty=<span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left ==<span class="literal">NULL</span>)   leftEmpty=<span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right ==<span class="literal">NULL</span>)   rightEmpty=<span class="literal">true</span>;</span><br><span class="line">        TreeNode* temp;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(leftEmpty&amp;&amp; rightEmpty)&#123; <span class="comment">//若左右子皆空，则直接返回</span></span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(leftEmpty &amp;&amp; !rightEmpty)  <span class="comment">//若左子空，右子不空</span></span><br><span class="line">        &#123;</span><br><span class="line">            root-&gt;left=root-&gt;right;</span><br><span class="line">            root-&gt;right=<span class="literal">NULL</span>;</span><br><span class="line">            <span class="built_in">mirrorTree</span>(root-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(!leftEmpty &amp;&amp; rightEmpty)  <span class="comment">//若左子不空，右子空</span></span><br><span class="line">        &#123;</span><br><span class="line">            root-&gt;right=root-&gt;left;</span><br><span class="line">            root-&gt;left=<span class="literal">NULL</span>;</span><br><span class="line">            <span class="built_in">mirrorTree</span>(root-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            temp=root-&gt;left;</span><br><span class="line">            root-&gt;left=root-&gt;right;</span><br><span class="line">            root-&gt;right=temp;</span><br><span class="line">            <span class="built_in">mirrorTree</span>(root-&gt;left);</span><br><span class="line">            <span class="built_in">mirrorTree</span>(root-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<img src="/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/image-20230310130259308.png" class title="image-20230310130259308">

<p>太简单了没意思</p>
<h3 id="28-请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。"><a href="#28-请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。" class="headerlink" title="28.请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。"></a>28.请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。</h3><img src="/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/image-20230310130539704.png" class title="image-20230310130539704">

<p>​    第一思路：可知对称的二叉树，其中序遍历应该也是对称的。所以我想去把其中序遍历输出出来。太复杂PASS，以下指针思路必须学习！！</p>
<img src="/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/image-20230310131649500.png" class title="image-20230310131649500">

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">isTrue</span>(root -&gt; left, root -&gt; right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isTrue</span><span class="params">(TreeNode* A, TreeNode* B)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(A == <span class="literal">nullptr</span> &amp;&amp; B == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(A == <span class="literal">nullptr</span> || B == <span class="literal">nullptr</span> || A -&gt; val != B -&gt; val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">isTrue</span>(A -&gt; left, B -&gt; right) &amp;&amp; <span class="built_in">isTrue</span>(A -&gt; right, B -&gt; left);       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<h1 id="动态规划Dynamic-programming-DP"><a href="#动态规划Dynamic-programming-DP" class="headerlink" title="动态规划Dynamic programming(DP)"></a>动态规划Dynamic programming(DP)</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><img src="/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/image-20230310133610109.png" class title="image-20230310133610109">

<h3 id="什么样的问题可以使用动态规划"><a href="#什么样的问题可以使用动态规划" class="headerlink" title="什么样的问题可以使用动态规划"></a>什么样的问题可以使用动态规划</h3><p>​    如果一个问题，可以把所有可能的答案穷举出来，并且穷举出来后，发现存在**<a target="_blank" rel="noopener" href="https://blog.csdn.net/vangoudan/article/details/106577901">重叠子问题</a>**，就可以考虑使用动态规划。</p>
<h3 id="动态规划的解题思路"><a href="#动态规划的解题思路" class="headerlink" title="动态规划的解题思路"></a>动态规划的解题思路</h3><p>​    动态规划的重点在于定义状态和状态转移方程</p>
<p>​    动态规划的核心思想就是<strong>拆分子问题，记住过往，减少重复计算。</strong> 并且动态规划一般都是自底向上的，因此到这里，基于<strong>青蛙跳阶</strong>问题，<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/365698607">我总结了一下我做动态规划的思路</a>：</p>
<ul>
<li><h4 id="1-穷举分析"><a href="#1-穷举分析" class="headerlink" title="1. 穷举分析"></a><strong>1. 穷举分析</strong></h4><ul>
<li>当台阶数是1的时候，有一种跳法，f（1） =1</li>
<li>当只有2级台阶时，有两种跳法，第一种是直接跳两级，第二种是先跳一级，然后再跳一级。即f(2) = 2;</li>
<li>当台阶是3级时，想跳到第3级台阶，要么是先跳到第2级，然后再跳1级台阶上去，要么是先跳到第 1级，然后一次迈 2 级台阶上去。所以f(3) = f(2) + f(1) =3</li>
</ul>
</li>
<li><h4 id="2-确定边界"><a href="#2-确定边界" class="headerlink" title="2. 确定边界"></a>2. 确定边界</h4><ul>
<li>通过穷举分析，我们发现，当台阶数是1的时候或者2的时候，可以明确知道青蛙跳法。f（1） =1，f(2) = 2，当台阶n&gt;=3时，已经呈现出规律f(3) = f(2) + f(1) =3，因此f（1） =1，f(2) = 2就是青蛙跳阶的边界。</li>
</ul>
</li>
<li><h4 id="3-找规律，确定最优子结构"><a href="#3-找规律，确定最优子结构" class="headerlink" title="3. 找规律，确定最优子结构"></a>3. 找规律，确定最优子结构</h4><ul>
<li>n&gt;=3时，已经呈现出规律 f(n) = f(n-1) + f(n-2) ，因此，f(n-1)和f(n-2) 称为 f(n) 的最优子结构。什么是最优子结构？有这么一个解释：</li>
</ul>
<blockquote>
<p>★ 一道动态规划问题，其实就是一个递推问题。假设当前决策结果是f(n),则最优子结构就是要让 f(n-k) 最优,最优子结构性质就是能让转移到n的状态是最优的,并且与后面的决策没有关系,即让后面的决策安心地使用前面的局部最优解的一种性质</p>
</blockquote>
</li>
<li><h4 id="4-写出状态转移方程"><a href="#4-写出状态转移方程" class="headerlink" title="4.写出状态转移方程"></a>4.写出状态转移方程</h4><ul>
<li>通过前面3步，穷举分析，确定边界，最优子结构，我们就可以得出状态转移方程啦：</li>
</ul>
<img src="/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/v2-17700257363921acdbd5718beaed8266_720w.webp" class title="img"></li>
<li><h4 id="5-代码实现"><a href="#5-代码实现" class="headerlink" title="5. 代码实现"></a>5. 代码实现</h4><ul>
<li>动态规划实现框架</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">dp[<span class="number">0</span>][<span class="number">0</span>][...] = 边界值</span><br><span class="line"><span class="keyword">for</span>(状态<span class="number">1</span> ：所有状态<span class="number">1</span>的值)&#123;</span><br><span class="line">    <span class="keyword">for</span>(状态<span class="number">2</span> ：所有状态<span class="number">2</span>的值)&#123;</span><br><span class="line">        <span class="keyword">for</span>(...)&#123;</span><br><span class="line">          <span class="comment">//状态转移方程</span></span><br><span class="line">          dp[状态<span class="number">1</span>][状态<span class="number">2</span>][...] = 求最值</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/u010365819/article/details/121000532">https://blog.csdn.net/u010365819/article/details/121000532</a></p>
<h3 id="通俗的动态规划解题步骤"><a href="#通俗的动态规划解题步骤" class="headerlink" title="通俗的动态规划解题步骤"></a>通俗的动态规划解题步骤</h3><img src="/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/image-20230311135947556.png" class title="image-20230311135947556"></li>
</ul>
<h4 id="构造dp数组"><a href="#构造dp数组" class="headerlink" title="构造dp数组"></a>构造dp数组</h4><p>​    构造<code>dp</code>数组，这是动规问题最基本的求解思路。和上述基于字符串类型的动规问题一样，基于数组类型的动规问题同样可以根据题目来决定：是要构造一维的<code>dp</code>数组、还是二维的<code>dp</code>数组？</p>
<h4 id="直观上的状态转移"><a href="#直观上的状态转移" class="headerlink" title="直观上的状态转移"></a>直观上的状态转移</h4><p>​    有些题目可以直接直观的由题目得出有哪几种状态转移方式，这类题目的状态一般是有限个的、且相互之间可以进行转化。典型例题则是 leetcode 中的股票买卖问题。</p>
<h4 id="找规律"><a href="#找规律" class="headerlink" title="找规律"></a>找规律</h4><h4 id="总的来说，拿到一道题目后，我们可以按照下面的步骤进行分析、尝试："><a href="#总的来说，拿到一道题目后，我们可以按照下面的步骤进行分析、尝试：" class="headerlink" title="总的来说，拿到一道题目后，我们可以按照下面的步骤进行分析、尝试："></a>总的来说，拿到一道题目后，我们可以按照下面的步骤进行分析、尝试：</h4><p>​    该问题能否拆分为小问题，是否可以构造dp数组来解决，dp数组中的每一个元素的含义是什么（很重要，不同的定义方式直接影响解决问题的难易程度，甚至有的定义方式根本无法解决问题）<br>​    定义完dp数组后，画图分析，这是得到状态转移方程很重要的一步！有的状态转移不是很直观，但是我们可以通过画图分析，找到规律。</p>
<h2 id="斐波那契（Fibonacci）"><a href="#斐波那契（Fibonacci）" class="headerlink" title="斐波那契（Fibonacci）"></a>斐波那契（Fibonacci）</h2><p>写一个函数，输入 <code>n</code> ，求斐波那契（Fibonacci）数列的第 <code>n</code> 项（即 <code>F(N)</code>）。斐波那契数列的定义如下：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">F</span>(<span class="number">0</span>) = <span class="number">0</span>,   F(<span class="number">1</span>) = <span class="number">1</span></span><br><span class="line"><span class="attribute">F</span>(N) = F(N - <span class="number">1</span>) + F(N - <span class="number">2</span>), 其中 N &gt; <span class="number">1</span>.</span><br></pre></td></tr></table></figure>

<p>斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。</p>
<p>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</p>
<img src="/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/image-20230310132214593.png" class title="image-20230310132214593">

<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/fei-bo-na-qi-shu-lie-lcof/solution/mian-shi-ti-10-i-fei-bo-na-qi-shu-lie-dong-tai-gui/">斐波那契数列 动态规划题解</a></p>
<h3 id="很明显，用递归直接超时，还得是动态规划！"><a href="#很明显，用递归直接超时，还得是动态规划！" class="headerlink" title="很明显，用递归直接超时，还得是动态规划！"></a>很明显，用递归直接超时，还得是动态规划！</h3><img src="/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/image-20230310134237927.png" class title="image-20230310134237927">

<img src="/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/image-20230310134247523.png" class title="image-20230310134247523">

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a=<span class="number">0</span>, b=<span class="number">1</span>,sum=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 当n&gt;1时才会进入循环，所以for循环算的是n从2到n+1的值</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>; i&lt;=n+<span class="number">1</span>; i++)&#123;</span><br><span class="line">            sum=(a+b) % <span class="number">1000000007</span>;        </span><br><span class="line">            a=b;</span><br><span class="line">            b=sum;  </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 由于多算一次，所以返回的是a，不是b</span></span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="或者用记忆化搜索-降低复杂度"><a href="#或者用记忆化搜索-降低复杂度" class="headerlink" title="或者用记忆化搜索 降低复杂度"></a>或者用记忆化搜索 降低复杂度</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1000000007</span>;</span><br><span class="line">    <span class="keyword">int</span> dp[<span class="number">101</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(dp[n]) <span class="keyword">return</span> dp[n];</span><br><span class="line">        <span class="keyword">if</span>(n &lt; <span class="number">2</span>) <span class="keyword">return</span> n;</span><br><span class="line">        dp[n] = (<span class="built_in">fib</span>(n<span class="number">-1</span>)+<span class="built_in">fib</span>(n<span class="number">-2</span>)) % mod;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>结果也不错。</p>
<h2 id="青蛙跳台阶"><a href="#青蛙跳台阶" class="headerlink" title="青蛙跳台阶"></a>青蛙跳台阶</h2><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 <code>n</code> 级的台阶总共有多少种跳法。</p>
<p> 其实也是斐波那契数列的问题，看<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/climbing-stairs/solution/yuan-lai-hui-pa-lou-ti-de-zheng-que-zi-s-pjez/">这个链接！</a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> dp[<span class="number">101</span>]=&#123;<span class="number">0</span>&#125;; </span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1000000007</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numWays</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//很不明显，可以将爬上n级台阶的问题，分成【先跳1步，然后爬n-1级楼梯】与【先跳2步，然后爬n-2级楼梯】之和</span></span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">1</span> || n==<span class="number">2</span>)<span class="keyword">return</span> n;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(dp[n]) <span class="keyword">return</span> dp[n];</span><br><span class="line">        dp[n] = (<span class="built_in">numWays</span>(n<span class="number">-1</span>)+<span class="built_in">numWays</span>(n<span class="number">-2</span>)) % mod;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/95525781">一只青蛙跳出来的分治法、回溯法与动态规划</a></p>
<h3 id="动态规划有几个典型特征，最优子结构、状态转移方程、边界、重叠子问题。在青蛙跳阶问题中："><a href="#动态规划有几个典型特征，最优子结构、状态转移方程、边界、重叠子问题。在青蛙跳阶问题中：" class="headerlink" title="动态规划有几个典型特征，最优子结构、状态转移方程、边界、重叠子问题。在青蛙跳阶问题中："></a>动态规划有几个典型特征，<strong>最优子结构、状态转移方程、边界、重叠子问题</strong>。在青蛙跳阶问题中：</h3><ul>
<li><p>f(n-1)和f(n-2) 称为 f(n) 的最优子结构</p>
</li>
<li><p>f(n)= f（n-1）+f（n-2）就称为状态转移方程</p>
</li>
<li><p>f(1) = 1, f(2) = 2 就是边界啦</p>
</li>
<li><p>比如f(10)= f(9)+f(8),f(9) = f(8) + f(7) ,f(8)就是重叠子问题。</p>
<h3 id="最优子结构"><a href="#最优子结构" class="headerlink" title="最优子结构"></a>最优子结构</h3><p>​    如果一个问题的最优解包含了其中子问题的最优解，那么称其具有最优子结构的性质。</p>
<p>​    什么意思？青蛙在面对 n 台阶时的解决方案数是 f(n)，那么我们知道 f(n) = f(n-1) + f(n-2)。其中的 f(n-1) 与 f(n-2) 就是两个子问题的最优解，此时我们可以理解成一个问题的最优解包含了其子问题的最优解，那么这个时候这种问题具有了最优子结构性质。</p>
<h3 id="重叠子问题"><a href="#重叠子问题" class="headerlink" title="重叠子问题"></a>重叠子问题</h3><p>​    这个性质，在我理解是对于上文提到的子问题的补充说明。当解决一个问题时，往往需要依赖于其更小规模的子问题的解，甚至是同时依赖于若干个规模更小的子问题的解，即子问题是被（重复）包含于比其更大的问题中的，所以他是具有重叠子问题的性质。</p>
</li>
</ul>
<h2 id="股票的最大利润"><a href="#股票的最大利润" class="headerlink" title="股票的最大利润"></a>股票的最大利润</h2><p>假设把某股票的价格按照时间先后顺序存储在数组中，请问买卖该股票一次可能获得的最大利润是多少？</p>
<img src="/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/image-20230310141619639.png" class title="image-20230310141619639">

<img src="/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/image-20230310142321486.png" class title="image-20230310142321486">

<img src="/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/image-20230310142419564.png" class title="image-20230310142419564">

<img src="/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/image-20230310142505665.png" class title="image-20230310142505665">

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(prices.<span class="built_in">size</span>()==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> minValue = prices[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (prices[i] &lt; minValue) &#123;</span><br><span class="line">                minValue = prices[i];   <span class="comment">//有更低的价格，则以后的价格可以基于这个更低的价格去算</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            res = <span class="built_in">max</span>(res, prices[i] - minValue);<span class="comment">//但是也要和之前的res比较以下</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>







<h2 id="连续子数组的最大和"><a href="#连续子数组的最大和" class="headerlink" title="连续子数组的最大和"></a>连续子数组的最大和</h2><img src="/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/image-20230310150347481.png" class title="image-20230310150347481">

<img src="/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/image-20230310150402602.png" class title="image-20230310150402602">

<p>​    我觉得关键就在于，对于每一个数是否加入数列，或者自己新开一个数列，就取决与该数本身与其之前连续子数列和大小的比较。</p>
<p>​    我开始还纠结，如果i前面的子数列和为2，然后i为-1，然后i+1为4，那要如何才能不断地组合。后来我发现，并不用组合，后面的4不就是最大的吗。嗯，所以我的思路没想到上面去，那要如何避免产生这种错误的思路呢？1是以后可以大胆假设，小心求证；2是多看多做题。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">         <span class="comment">//我们[]第n位数字为尾巴的最大值]就是其[前n-1位数字的最大值加上它本身]与[其自身]相比较，谁大就是谁，如果一样那就继续;</span></span><br><span class="line">         <span class="comment">//如果该数字加上去比原来更小，那就重开一段计算咯</span></span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>()==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> max1 = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> max_final=max1;    <span class="comment">//当前最优解，因为可能后面那段比前面好，所以要比较；</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            max1=<span class="built_in">max</span>(max1+nums[i],nums[i]);</span><br><span class="line">            max_final=<span class="built_in">max</span>(max1,max_final);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max_final;</span><br><span class="line">                   <span class="comment">//关于动态规划的思想可以看首页Krahets的讲解。这里给出C++的简单实现。</span></span><br><span class="line">                    <span class="comment">//算法精髓在于每个子数组必须要考虑最后一个数，但是最终结果只要最优解</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h4><img src="/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/image-20230310155856278.png" class title="image-20230310155856278">





<h4 id="思路二"><a href="#思路二" class="headerlink" title="思路二"></a>思路二</h4><img src="/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/image-20230310160043917.png" class title="image-20230310160043917">



<h4 id="关于回溯法与DP"><a href="#关于回溯法与DP" class="headerlink" title="关于回溯法与DP"></a>关于回溯法与DP</h4><blockquote>
<p>​    教一个秘诀吧，关于什么时候用dp。首先你要了解回溯法，毕竟是dp的起源，在你熟悉回溯之后，你发现这道题它好像可以用回溯去做，或者发现你想遍历它来给出答案，但是答案要求的并不是把所有满足的解法都列出来，而是只需要给出一共有几种解法，这时候一般就考虑dp。比如这道题，求的是所有子数组的和，关键它不是让你求所有子数组，并不需要把子数组一个一个去完整拿出，所以你一个一个遍历的方法肯定要超时，只能是dp。</p>
</blockquote>
<p>作者：zhywanna<br>链接：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof/solution/by-zhywanna-7gcq">https://leetcode.cn/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof/solution/by-zhywanna-7gcq</a></p>
<h2 id="礼物的最大价值"><a href="#礼物的最大价值" class="headerlink" title="礼物的最大价值"></a>礼物的最大价值</h2><p>​    在一个 m*n 的棋盘的每一格都放有一个礼物，每个礼物都有一定的价值（价值大于 0）。你可以从棋盘的左上角开始拿格子里的礼物，并每次向右或者向下移动一格、直到到达棋盘的右下角。给定一个棋盘及其上面的礼物的价值，请计算你最多能拿到多少价值的礼物？<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/li-wu-de-zui-da-jie-zhi-lcof/solution/mian-shi-ti-47-li-wu-de-zui-da-jie-zhi-dong-tai-gu/">动态规划解答</a></p>
<img src="/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/image-20230311130018890.png" class title="image-20230311130018890">

<h3 id="递归（回溯法）方法"><a href="#递归（回溯法）方法" class="headerlink" title="递归（回溯法）方法"></a>递归（回溯法）方法</h3><p>​    由题意得，一个格子只能由其上方或者左方的格子移动得到，所以<strong>该格子的最大值Max(i,j)即为max(Max(i-1.j),Max(i,j-1))</strong>,于是思路一就是开始递归并记录每个格子的最大值。后来发现，其实我们不用记录最大值，只要我们不断循环直到计算出最右下角的值即可。但是很明显，这样会超时。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; &amp;grid, <span class="keyword">int</span> row, <span class="keyword">int</span> col)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (row &lt; <span class="number">0</span> || row &gt;= grid.<span class="built_in">size</span>() || col &lt; <span class="number">0</span> || col &gt;= grid[<span class="number">0</span>].<span class="built_in">size</span>()) </span><br><span class="line">            <span class="keyword">return</span> INT_MIN;</span><br><span class="line">        <span class="keyword">if</span> (row == grid.<span class="built_in">size</span>() - <span class="number">1</span> &amp;&amp; col == grid[<span class="number">0</span>].<span class="built_in">size</span>() - <span class="number">1</span>)    <span class="comment">// 到达右下角之后，直接返回它的礼物价值即可</span></span><br><span class="line">            <span class="keyword">return</span> grid[row][col];</span><br><span class="line">        <span class="keyword">int</span> right = <span class="built_in">dfs</span>(grid, row, col + <span class="number">1</span>);        <span class="comment">// 向右移动一格</span></span><br><span class="line">        <span class="keyword">int</span> down = <span class="built_in">dfs</span>(grid, row + <span class="number">1</span>, col);         <span class="comment">// 向左移动一格</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(right, down) + grid[row][col];       <span class="comment">// 不管怎么移动都要加上自身的礼物价值</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxValue</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(grid, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<img src="/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/image-20230311133455387.png" class title="image-20230311133455387">

<h3 id="记忆化搜索（回溯法）（即记录之前的值）"><a href="#记忆化搜索（回溯法）（即记录之前的值）" class="headerlink" title="记忆化搜索（回溯法）（即记录之前的值）"></a>记忆化搜索（回溯法）（即记录之前的值）</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; &amp;grid, <span class="keyword">int</span> row, <span class="keyword">int</span> col, vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; &amp;cache)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (row &lt; <span class="number">0</span> || row &gt;= grid.<span class="built_in">size</span>() || col &lt; <span class="number">0</span> || col &gt;= grid[<span class="number">0</span>].<span class="built_in">size</span>()) </span><br><span class="line">            <span class="keyword">return</span> INT_MIN;</span><br><span class="line">        <span class="keyword">if</span> (row == grid.<span class="built_in">size</span>() - <span class="number">1</span> &amp;&amp; col == grid[<span class="number">0</span>].<span class="built_in">size</span>() - <span class="number">1</span>) </span><br><span class="line">            <span class="keyword">return</span> grid[row][col];</span><br><span class="line">        <span class="keyword">if</span> (cache[row][col] != <span class="number">-1</span>) <span class="keyword">return</span> cache[row][col];      <span class="comment">// 当前状态被计算过了，直接使用答案</span></span><br><span class="line">        <span class="keyword">int</span> right = <span class="built_in">dfs</span>(grid, row, col + <span class="number">1</span>, cache);</span><br><span class="line">        <span class="keyword">int</span> down = <span class="built_in">dfs</span>(grid, row + <span class="number">1</span>, col, cache);</span><br><span class="line">        cache[row][col] = <span class="built_in">max</span>(right, down) + grid[row][col];    <span class="comment">// 当前状态没有被计算过，就把计算结果保存到 cache 中</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(right, down) + grid[row][col];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxValue</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建二维数组 cache，初始化 -1，表示每个位置都没被计算</span></span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">cache</span>(grid.<span class="built_in">size</span>(), vector&lt;<span class="keyword">int</span>&gt;(grid[<span class="number">0</span>].<span class="built_in">size</span>(), <span class="number">-1</span>));</span><br><span class="line">        <span class="comment">//初始化时要赋值</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(grid, <span class="number">0</span>, <span class="number">0</span>, cache);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<img src="/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/image-20230311134340534-1678513421403-1.png" class title="image-20230311134340534">

<h3 id="动态规划方法"><a href="#动态规划方法" class="headerlink" title="动态规划方法"></a>动态规划方法</h3><p>​                                                                                                <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/li-wu-de-zui-da-jie-zhi-lcof/solution/mian-shi-ti-47-li-wu-de-zui-da-jie-zhi-dong-tai-gu/">动态规划解答</a></p>
<img src="/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/image-20230311134432069.png" class title="image-20230311134432069">

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxValue</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rowSize = grid.<span class="built_in">size</span>(), colSize = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> dp[rowSize + <span class="number">1</span>][colSize + <span class="number">1</span>];       <span class="comment">// 数组长度开大一个，这样可以根据 dfs 的递归出口初始化 dp 数组</span></span><br><span class="line">        dp[rowSize - <span class="number">1</span>][colSize - <span class="number">1</span>] = grid[rowSize - <span class="number">1</span>][colSize - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; colSize; i++) dp[rowSize][i] = INT_MIN;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rowSize; i++) dp[i][colSize] = INT_MIN;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> row = rowSize - <span class="number">1</span>; row &gt;= <span class="number">0</span>; row--) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> col = colSize - <span class="number">1</span>; col &gt;= <span class="number">0</span>; col--) &#123;</span><br><span class="line">                <span class="keyword">if</span> (row == rowSize - <span class="number">1</span> &amp;&amp; col == colSize - <span class="number">1</span>) <span class="keyword">continue</span>;     <span class="comment">// 右下角已被初始化，所以直接跳过</span></span><br><span class="line">                dp[row][col] = <span class="built_in">max</span>(dp[row + <span class="number">1</span>][col], dp[row][col + <span class="number">1</span>]) + grid[row][col];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxValue</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>,j=<span class="number">1</span>; j &lt; grid[<span class="number">0</span>].<span class="built_in">size</span>(); j++)	<span class="comment">//处理第一行</span></span><br><span class="line">        &#123;</span><br><span class="line">            grid[i][j] += grid[i][j - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>,j=<span class="number">0</span>; i &lt; grid.<span class="built_in">size</span>(); i++)		<span class="comment">//处理第一列</span></span><br><span class="line">        &#123;</span><br><span class="line">            grid[i][j] += grid[i<span class="number">-1</span>][j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; grid.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; grid[<span class="number">0</span>].<span class="built_in">size</span>(); j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i - <span class="number">1</span>][j] &gt;= grid[i][j - <span class="number">1</span>])	grid[i][j] += grid[i - <span class="number">1</span>][j];</span><br><span class="line">                <span class="keyword">else</span> grid[i][j] += grid[i][j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> grid[grid.<span class="built_in">size</span>()<span class="number">-1</span>][grid[<span class="number">0</span>].<span class="built_in">size</span>()<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>







<h2 id="数字翻译成字符串"><a href="#数字翻译成字符串" class="headerlink" title="数字翻译成字符串"></a>数字翻译成字符串</h2><img src="/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/image-20230311140828931.png" class title="image-20230311140828931">

<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/ba-shu-zi-fan-yi-cheng-zi-fu-chuan-lcof/">题目链接</a></p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/ba-shu-zi-fan-yi-cheng-zi-fu-chuan-lcof/solution/by-zhywanna-tkwb/">我是如何5分钟做出这道DP并且Beats100%的</a></p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1K341117Pm">剑指 Offer 46. 把数字翻译成字符串</a></p>
<h3 id="主要思路"><a href="#主要思路" class="headerlink" title="主要思路"></a>主要思路</h3><p>​    对于俩个数字，如果它们介于00-25之间，则对于他们来说，有俩种不同的翻译，即为俩个数字分别进行翻译+俩个数字合起来翻译。否则，他们只有一种翻译，即为俩个数字分别进行翻译。</p>
<p>​    我们用dp[i]表示这段数字前i位可以解码的总数。</p>
<img src="/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/image-20230311143745545.png" class title="image-20230311143745545">

<p>​    </p>
<img src="/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/image-20230311144142877.png" class title="image-20230311144142877">

<img src="/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/image-20230311144218175.png" class title="image-20230311144218175">

<img src="/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/image-20230311144640021.png" class title="image-20230311144640021">

<h3 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">translateNum</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        string str = <span class="built_in">to_string</span>(num);</span><br><span class="line">        <span class="keyword">int</span> len = str.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(len &lt; <span class="number">2</span>) <span class="keyword">return</span> len;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(len+<span class="number">1</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= len;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(str[i<span class="number">-2</span>] == <span class="string">&#x27;1&#x27;</span> || (str[i<span class="number">-2</span>] == <span class="string">&#x27;2&#x27;</span> &amp;&amp; str[i<span class="number">-1</span>] &lt;= <span class="string">&#x27;5&#x27;</span>)) dp[i] = dp[i<span class="number">-2</span>]+dp[i<span class="number">-1</span>];</span><br><span class="line">            <span class="keyword">else</span> dp[i] = dp[i<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[len];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>







<h2 id="最长不含重复字符的子字符串"><a href="#最长不含重复字符的子字符串" class="headerlink" title=" 最长不含重复字符的子字符串"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/zui-chang-bu-han-zhong-fu-zi-fu-de-zi-zi-fu-chuan-lcof/"> 最长不含重复字符的子字符串</a></h2><p>请从字符串中找出一个最长的不包含重复字符的子字符串，计算该最长子字符串的长度。</p>
<img src="/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/image-20230311145643385.png" alt="image-20230311145643385" style="zoom:67%;">

<h3 id="刚开始思路"><a href="#刚开始思路" class="headerlink" title="刚开始思路"></a>刚开始思路</h3><p>​    首先注意只需要输出其最长不重复的长度即可，所以用一个maxFinal去表示。可以用dp[i]表示对于以第i个字母为结尾的字符串来说，其不重复的字符串最长是多少。dp[0]为1，再之后每一个dp[i]，都去判断其字母与之前长度为dp[i]的字符串有没有重复：若有，则dp[i]=1；若无，则dp[i]=dp[i-1]+1。所以现在的问题就到了如何快速进行某字符与字符串的一一比较。想到C++有一个string.find(string2)功能，好的，试一试。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len=s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(len&lt;<span class="number">2</span>)<span class="keyword">return</span> len;</span><br><span class="line">        <span class="keyword">int</span> dp[len];</span><br><span class="line">        <span class="keyword">int</span> maxFinal=<span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;len;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s.<span class="built_in">substr</span>(i-dp[i<span class="number">-1</span>],dp[i<span class="number">-1</span>]).<span class="built_in">find</span>(s.<span class="built_in">substr</span>(i,<span class="number">1</span>))== string::npos)</span><br><span class="line">            &#123; </span><br><span class="line">                dp[i]=dp[i<span class="number">-1</span>]+<span class="number">1</span>;</span><br><span class="line">                maxFinal=<span class="built_in">max</span>(maxFinal,dp[i]);  </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">               dp[i]=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxFinal;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<img src="/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/image-20230311151330683.png" class title="image-20230311151330683">

<p>​    很明显，我的思路有一个大漏洞，即上图中，dp[1]=2，那么dp[2]就会惯性思维去比较，然后设为dp[2]=1，但其实它应该是2，于是我们开始了循环遍历，但不用做就知道肯定会超时。</p>
<h3 id="罢，看官方题解"><a href="#罢，看官方题解" class="headerlink" title="罢，看官方题解"></a>罢，<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/zui-chang-bu-han-zhong-fu-zi-fu-de-zi-zi-fu-chuan-lcof/solution/zui-chang-bu-han-zhong-fu-zi-fu-de-zi-zi-l4yo/">看官方题解</a></h3><p>​    <img src="/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/image-20230311152006923.png" class title="image-20230311152006923"></p>
<p>hah很简单为什么我没想到？</p>
<img src="/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/image-20230311152054563.png" class title="image-20230311152054563">

<img src="/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/image-20230311152124613.png" class title="image-20230311152124613">

<h3 id="双指针具体实现"><a href="#双指针具体实现" class="headerlink" title="双指针具体实现"></a>双指针具体实现</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/zui-chang-bu-han-zhong-fu-zi-fu-de-zi-zi-fu-chuan-lcof/solution/cshi-xian-shi-yong-shuang-zhi-zhen-ji-ba-ywep/">C++实现，使用双指针，击败100%</a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>; </span><br><span class="line">        <span class="keyword">int</span> a[<span class="number">100010</span>] = &#123;<span class="number">0</span>&#125;;  <span class="comment">//用来保存每个字符出现的次数，初始化为0</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i ++)&#123;</span><br><span class="line">            a[s[i]]++;	<span class="comment">//我只能说这个太离谱了</span></span><br><span class="line">            <span class="keyword">while</span>(j &lt; i &amp;&amp; a[s[i]] &gt; <span class="number">1</span>)&#123;</span><br><span class="line">                a[s[j]]--;</span><br><span class="line">                j ++;</span><br><span class="line">            &#125;</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, i - j + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//总体思路和官方解答几乎差不多，很喜欢我只能说，原来这题不是用动态规划，我太套路了/</span></span><br></pre></td></tr></table></figure>

<h3 id="动态规划具体实现"><a href="#动态规划具体实现" class="headerlink" title="动态规划具体实现"></a>动态规划具体实现</h3><p>可以看见具体解法需要哈希表记录一下</p>
<img src="/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/image-20230311153002478.png" class title="image-20230311153002478">

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len=s.<span class="built_in">length</span>();</span><br><span class="line">    <span class="keyword">if</span>(len&lt;<span class="number">2</span>)   <span class="keyword">return</span> len;</span><br><span class="line"></span><br><span class="line">	unordered_map&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; position;</span><br><span class="line">	<span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(len, <span class="number">0</span>)</span></span>;</span><br><span class="line">	<span class="keyword">int</span> res = <span class="number">0</span>, count = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123; </span><br><span class="line">		<span class="keyword">if</span> (i != <span class="number">0</span> &amp;&amp; position.<span class="built_in">find</span>(s[i]) == position.<span class="built_in">end</span>()) &#123;<span class="comment">//当前字符首次出现</span></span><br><span class="line">			dp[i] = dp[i - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">			dp[i] = <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;	<span class="comment">//如果当前字符和哈希表记录的发生重复，计算当前字符位置与前面重复的字符位置的距离i - j</span></span><br><span class="line">			<span class="keyword">int</span> j = position[s[i]];</span><br><span class="line">			<span class="keyword">if</span> (i - j &lt;= dp[i - <span class="number">1</span>]) &#123;	<span class="comment">//即前面重复的那个字符包含在当前最长非重复子串里面了</span></span><br><span class="line">				dp[i] = i - j;		<span class="comment">//我们当前新的最长非重复子串长度应该为i - j</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;	<span class="comment">//即前面重复的那个字符已经不在当前最长非重复子串里面了</span></span><br><span class="line">				dp[i] = dp[i - <span class="number">1</span>] + <span class="number">1</span>;	<span class="comment">//我们直接将当前长度在前面的基础上加一即可</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		position[s[i]] = i;</span><br><span class="line">        res = <span class="built_in">max</span>(res, dp[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="因为每次dp结果只与上一次dp的结果有关，将上述代码优化空间复杂度得到"><a href="#因为每次dp结果只与上一次dp的结果有关，将上述代码优化空间复杂度得到" class="headerlink" title="因为每次dp结果只与上一次dp的结果有关，将上述代码优化空间复杂度得到"></a>因为每次dp结果只与上一次dp的结果有关，将上述代码优化空间复杂度得到</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>, tmp = <span class="number">0</span>;</span><br><span class="line">        unordered_map&lt;<span class="keyword">char</span> ,<span class="keyword">int</span>&gt; hash;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">length</span>(); i++)&#123;   </span><br><span class="line">            <span class="keyword">int</span> j = <span class="number">0</span>;    </span><br><span class="line">            <span class="keyword">if</span>(hash.<span class="built_in">count</span>(s[i]) != <span class="number">0</span>)</span><br><span class="line">                j = hash[s[i]];</span><br><span class="line">            <span class="keyword">else</span> j = <span class="number">-1</span>;   </span><br><span class="line">            hash[s[i]] = i;</span><br><span class="line">            tmp = tmp &lt; i - j ? tmp + <span class="number">1</span> : i - j;</span><br><span class="line">            </span><br><span class="line">            res = <span class="built_in">max</span>(res, tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<h2 id="面试题-字母与数字"><a href="#面试题-字母与数字" class="headerlink" title="面试题 字母与数字"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-longest-subarray-lcci/">面试题 字母与数字</a></h2><p>​    给定一个放有字母和数字的数组，找到最长的子数组，且包含的字母和数字的个数相同。</p>
<p>​    返回该子数组，若存在多个最长子数组，返回左端点下标值最小的子数组。若不存在这样的数组，返回一个空数组。</p>
<img src="/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/image-20230311162128491.png" class title="image-20230311162128491">

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一眼顶真 动态规划（或者双指针）</span></span><br><span class="line"><span class="comment">//我们可以先将string数组改成int数组，字母转为1，数字转为-1</span></span><br><span class="line"><span class="comment">//定义俩个指针i j ,i指针指向左侧，从0开始，j指针则从左侧开始往右走，若......然后发现问题很大，并不能用上题思路。卡壳，看题解找思路</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>为了在转换后的数组中寻找元素和为0的子数组，可以计算转换后的数组的前缀和，如果两个下标对应的前缀和相等，则这两个下标之间的子数组的元素和为0。</p>
</blockquote>
<p>​    哦，有一点思路了。但是还是遍历的思路。我可以设置一个二维数组，第一个下标表示左边的i在哪里，第二个下标表示右边的j在哪里，然后该二维数组的值，记录这一段ij之间的+1 -1之和。然后再找出所有值为0的，计算j-i的最大值即可……很显然，必超时。</p>
<blockquote>
<p>​    关键就是如何求出来目标值为0的最长子数组长度呢？首先我们可以想到一个O(n^2)的办法，也就是首先求出前缀和sum[i],sum[i]表示的是0<del>i的数组的元素和为多少。那么sum[i] - sum[j]表示的就是从j+1</del>i位置所有的元素的和。两层遍历就可以求出最长的子数组了。</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/Cooperia/article/details/118861303">算法笔记（五）：前缀和</a></p>
<blockquote>
<p>​    有没有更好的办法呢？实际上是有的，最终的算法复杂度是O(n)。假设我们考虑sum[i]的情况如下：</p>
<p>​    +1， +2，+3， +2， +2，+3，+2，+1， 0， -1，-2，-1, 0，+1，+2，+3，+2…</p>
<p>​    我们看加粗的+3，表示在这个位置sum[2] == sum[5] == sum[15] == +3. 假设我们遍历到第二个+3的位置也就是index = 5索引位置，这个时候，如果我们知道最左边索引2位置也有一个3，那么我们可以清楚地得知 从索引2后一位 到 索引5 的和是0. 我们在看索引15的sum[15] == 3, 当遍历到这一位的时候，我们如果知道最左边索引2的位置也有一个3，那么我们也可以清楚地得知送索引2后一位到索引15的和是0.</p>
<p>​    所以说，知道每一个前缀和在最左边第一次出现的位置是至关重要的，因为后面每当出现同样的前缀和，两次的索引相减+1之后得到的，就可能是目前已知的区间线段和为0的最长索引，而这两次相同前缀和之间和他们相同的前缀和的索引是多少，我们并不关心，就像我们现在有最左边的前缀和为3的索引是2，目前找到前缀和为3的索引是15，那么我们就不会关心中间前缀和为3的索引5了，因为无论如何他都不可能最长。</p>
<p>​    所以我们要建立一个结构去存储最左边第一次出现前缀和为sum[i]时候的索引。每次出现相同前缀和，我们就判断一下是不是可能为最长的。同时注意特殊情况，因为当前缀和为0的时候，假设sum[i]为0，那么一定有一种默认情况出现，也就是从0~i这些位置的和也是0，最长的子区间有可能是【0，i】.</p>
<p>作者：Wzing<br>链接：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-longest-subarray-lcci/solution/tong-guo-ji-lu-qian-zhui-he-di-yi-ci-chu-xian-wei-/">https://leetcode.cn/problems/find-longest-subarray-lcci/solution/tong-guo-ji-lu-qian-zhui-he-di-yi-ci-chu-xian-wei-/</a></p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//按照佬的思路加了一些注释</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function">vector&lt;string&gt; <span class="title">findLongestSubarray</span><span class="params">(vector&lt;string&gt;&amp; array)</span> </span>&#123;</span><br><span class="line">		 vector&lt;<span class="keyword">int</span>&gt; nums;</span><br><span class="line">         <span class="keyword">int</span> n = array.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;        <span class="comment">//转化为1与-1</span></span><br><span class="line">            nums.<span class="built_in">push_back</span>(array[i][<span class="number">0</span>] &lt;= <span class="string">&#x27;9&#x27;</span>? <span class="number">1</span>: <span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//sum[i]表示从0到i的前缀和</span></span><br><span class="line">		vector&lt;<span class="keyword">int</span>&gt; sum;</span><br><span class="line">		sum.<span class="built_in">push_back</span>(nums[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">int</span> sumTemp = nums[<span class="number">0</span>];  </span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">			sumTemp += nums[i];</span><br><span class="line">			sum.<span class="built_in">push_back</span>(sumTemp);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">int</span> start = <span class="number">-1</span>; <span class="comment">//用于记录那一段的开头和结尾，方便输出</span></span><br><span class="line">		<span class="keyword">int</span> end = <span class="number">-1</span>;</span><br><span class="line">		<span class="keyword">int</span> maxLength = <span class="number">0</span>;</span><br><span class="line">		unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; mp;             <span class="comment">//mp[k] = index表示出现和为k的最左边索引为index</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sum.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">			<span class="keyword">if</span> (mp.<span class="built_in">find</span>(sum[i]) != mp.<span class="built_in">end</span>())<span class="comment">//最左边出现过，即已经记录过了，按照思想就直接加就行了</span></span><br><span class="line">            &#123;   </span><br><span class="line">				<span class="keyword">if</span> (sum[i] == <span class="number">0</span>)</span><br><span class="line">                &#123;   <span class="comment">//和为0的情况特殊，因为当某一个index为i的时候，最长的子线段长度一定是0~i，也就是长度为i+1</span></span><br><span class="line">					<span class="keyword">if</span> (i + <span class="number">1</span> &gt; maxLength)</span><br><span class="line">                    &#123;</span><br><span class="line">						maxLength = i + <span class="number">1</span>;</span><br><span class="line">						start = <span class="number">0</span>;</span><br><span class="line">						end = i;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span>&#123;   <span class="comment">//否则就是普通的有前缀和，则直接相减即可</span></span><br><span class="line">					<span class="keyword">if</span> (i - mp[sum[i]] &gt; maxLength)</span><br><span class="line">                    &#123;</span><br><span class="line">						maxLength = i - mp[sum[i]];</span><br><span class="line">						start = mp[sum[i]] + <span class="number">1</span>;</span><br><span class="line">						end = i;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> </span><br><span class="line">            &#123; </span><br><span class="line">				<span class="comment">//前缀和为sum[i]第一次出现，记录下来</span></span><br><span class="line">				mp.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(sum[i], i));</span><br><span class="line">				<span class="comment">//这里需要注意哪怕是第一次出现0也需要比较，这和前缀和为其他的不一样</span></span><br><span class="line">				<span class="keyword">if</span> (sum[i] == <span class="number">0</span>)&#123;</span><br><span class="line">					<span class="keyword">if</span>(i + <span class="number">1</span> &gt; maxLength)&#123;</span><br><span class="line">						maxLength = i + <span class="number">1</span>;</span><br><span class="line">						start = <span class="number">0</span>;</span><br><span class="line">						end = i;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (start == <span class="number">-1</span>) <span class="keyword">return</span>&#123;&#125;;<span class="comment">//没有找到前缀和为0的</span></span><br><span class="line">		<span class="function">vector&lt;string&gt; <span class="title">ret</span><span class="params">(array.begin() + start, array.begin() + end + <span class="number">1</span>)</span></span>;</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<h1 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h1><h2 id="剑指-Offer-18-删除链表的节点"><a href="#剑指-Offer-18-删除链表的节点" class="headerlink" title="剑指 Offer 18. 删除链表的节点"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/shan-chu-lian-biao-de-jie-dian-lcof/">剑指 Offer 18. 删除链表的节点</a></h2><p>​    给定单向链表的头指针和一个要删除的节点的值，定义一个函数删除该节点。返回删除后的链表的头节点。</p>
<img src="/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/image-20230312160400179.png" class title="image-20230312160400179">

<p>初始思路就是定义一个t1指针指向开头head，另一个指向head-&gt;next；然后递归下去一个一个寻找。哈哈结果就是超时，我恨。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">deleteNode</span><span class="params">(ListNode* head, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        ListNode* p =head;</span><br><span class="line">        ListNode* q =head-&gt;next;</span><br><span class="line">        <span class="keyword">if</span>(!q) &#123;</span><br><span class="line">            <span class="keyword">if</span>(p-&gt;val == val) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(q)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(q-&gt;val==val)</span><br><span class="line">            &#123;</span><br><span class="line">                ListNode* t3=q-&gt;next;</span><br><span class="line">                <span class="keyword">if</span>(!t3) </span><br><span class="line">                &#123;</span><br><span class="line">                    p-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">                    <span class="keyword">return</span> head;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    p-&gt;next=t3;</span><br><span class="line">                    <span class="keyword">return</span> head;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>后来我发现我总是把问题复杂化，如果刚开始就是双指针不就很简单？</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">deleteNode</span><span class="params">(ListNode* head, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        ListNode* p =head;</span><br><span class="line">        ListNode* q =p-&gt;next;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;val==val) <span class="keyword">return</span> q;</span><br><span class="line">        <span class="keyword">while</span>(q)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(q-&gt;val==val) </span><br><span class="line">            &#123;</span><br><span class="line">                p-&gt;next=q-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            p=q;</span><br><span class="line">            q=q-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="剑指-Offer-22-链表中倒数第k个节点"><a href="#剑指-Offer-22-链表中倒数第k个节点" class="headerlink" title="剑指 Offer 22. 链表中倒数第k个节点"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/">剑指 Offer 22. 链表中倒数第k个节点</a></h2><p>输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点</p>
<img src="/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/image-20230312162453617.png" class title="image-20230312162453617">

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//很简单，408常见</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">getKthFromEnd</span><span class="params">(ListNode* head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        ListNode* p=head;</span><br><span class="line">        ListNode* q=p;</span><br><span class="line">        <span class="keyword">while</span>(k&gt;<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            q=q-&gt;next;</span><br><span class="line">            k--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(q)</span><br><span class="line">        &#123;</span><br><span class="line">            p=p-&gt;next;</span><br><span class="line">            q=q-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="剑指-Offer-25-合并两个排序的链表"><a href="#剑指-Offer-25-合并两个排序的链表" class="headerlink" title="剑指 Offer 25. 合并两个排序的链表"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/he-bing-liang-ge-pai-xu-de-lian-biao-lcof/">剑指 Offer 25. 合并两个排序的链表</a></h2><p>输入两个递增排序的链表，合并这两个链表并使新链表中的节点仍然是递增排序的。</p>
<img src="/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/image-20230312162837680.png" class title="image-20230312162837680">

<p> 主要思路就是新增指针pq指向俩条链表的头结点。</p>
<img src="/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/image-20230312165703584.png" class title="image-20230312165703584">

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        ListNode* p=l1;</span><br><span class="line">        ListNode* q=l2;</span><br><span class="line">        ListNode* ans = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">        ListNode* ap=ans;</span><br><span class="line">        <span class="keyword">while</span>(p &amp;&amp; q)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(p-&gt;val&lt;=q-&gt;val)</span><br><span class="line">            &#123;</span><br><span class="line">                ap-&gt;next=p;</span><br><span class="line">                l1=p-&gt;next;</span><br><span class="line">                p=l1;</span><br><span class="line">                ap= ap-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                ap-&gt;next=q;</span><br><span class="line">                l1=q-&gt;next;</span><br><span class="line">                q=l1;</span><br><span class="line">                ap= ap-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(p)ap-&gt;next=p;</span><br><span class="line">        <span class="keyword">else</span> ap-&gt;next=q;</span><br><span class="line">        <span class="keyword">return</span> ans-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<img src="/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/image-20230312165756171.png" class title="image-20230312165756171">

<h2 id="剑指-Offer-52-两个链表的第一个公共节点"><a href="#剑指-Offer-52-两个链表的第一个公共节点" class="headerlink" title="剑指 Offer 52. 两个链表的第一个公共节点"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof/">剑指 Offer 52. 两个链表的第一个公共节点</a></h2><p>输入两个链表，找出它们的第一个公共节点。</p>
<img src="/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/image-20230312170001133.png" class title="image-20230312170001133">

<img src="/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/image-20230312170011685.png" class title="image-20230312170011685">

<p>第一思路是直接算出俩链表的长度，然后长减短，得到差值。长的指针直接往后移动差值dif，然后二者一起移动，直到遇到完全相同就可以了。</p>
<p>第二思路就倒着来，很明显俩个链表最后一定是一样的，我们可以从后面开始移动，直到有不同的即可。</p>
<p>不过还是用思路一做出来了。不过这题很蠢的一点是，俩个结点的值val一样，却不是同一结点，如例一，绷不住了，不过还好只不过是改变了判断条件从val==val变到了ListNode==ListNode；</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Getlength</span><span class="params">(ListNode* a)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(a)</span><br><span class="line">        &#123;</span><br><span class="line">            a=a-&gt;next;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a=<span class="built_in">Getlength</span>(headA);</span><br><span class="line">        <span class="keyword">int</span> b=<span class="built_in">Getlength</span>(headB);</span><br><span class="line">        ListNode*p=headA;</span><br><span class="line">        ListNode*q=headB;</span><br><span class="line">        ListNode* ans=<span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span>(a&lt;=b)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> dif=b-a;</span><br><span class="line">            <span class="keyword">while</span>(dif&gt;<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                q=q-&gt;next;</span><br><span class="line">                dif--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> dif=a-b;</span><br><span class="line">            <span class="keyword">while</span>(dif&gt;<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                p=p-&gt;next;</span><br><span class="line">                dif--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">bool</span> isEnd=<span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">while</span>(p &amp;&amp; q)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(p == q &amp;&amp; isEnd==<span class="literal">false</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                ans=p;</span><br><span class="line">                isEnd=<span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(p != q)</span><br><span class="line">            &#123;</span><br><span class="line">                isEnd=<span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            p=p-&gt;next;</span><br><span class="line">            q=q-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(isEnd)<span class="keyword">return</span> ans;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<img src="/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/image-20230312172947289.png" class title="image-20230312172947289">



<h2 id="剑指-Offer-21-调整数组顺序使奇数位于偶数前面"><a href="#剑指-Offer-21-调整数组顺序使奇数位于偶数前面" class="headerlink" title="剑指 Offer 21. 调整数组顺序使奇数位于偶数前面"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/diao-zheng-shu-zu-shun-xu-shi-qi-shu-wei-yu-ou-shu-qian-mian-lcof/">剑指 Offer 21. 调整数组顺序使奇数位于偶数前面</a></h2><p>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有奇数在数组的前半部分，所有偶数在数组的后半部分。</p>
<img src="/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/image-20230312173126674.png" class title="image-20230312173126674">

  </div>
</article>



        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
         
          <li><a href="/">首页</a></li>
         
          <li><a href="/about/">关于</a></li>
         
          <li><a href="/archives/">归档</a></li>
        
      </ul>
    </div>

    <div id="toc-footer" style="display: none">
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#C-%E5%9F%BA%E7%A1%80"><span class="toc-number">1.</span> <span class="toc-text">C++基础</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%80%92%E5%BD%92%E4%B8%8E%E5%88%86%E6%B2%BB%EF%BC%8C%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%8C%E8%B4%AA%E5%BF%83%EF%BC%8C%E5%9B%9E%E6%BA%AF%EF%BC%8C%E5%88%86%E6%94%AF%E7%95%8C%E9%99%90%E6%B3%95"><span class="toc-number">2.</span> <span class="toc-text">递归与分治，动态规划，贪心，回溯，分支界限法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%90%9C%E7%B4%A2%E4%B8%8E%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9B%B8%E5%85%B3"><span class="toc-number">3.</span> <span class="toc-text">搜索与回溯算法 二叉树相关</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#32-%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E5%87%BA%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%AF%8F%E4%B8%AA%E8%8A%82%E7%82%B9%EF%BC%8C%E5%90%8C%E4%B8%80%E5%B1%82%E7%9A%84%E8%8A%82%E7%82%B9%E6%8C%89%E7%85%A7%E4%BB%8E%E5%B7%A6%E5%88%B0%E5%8F%B3%E7%9A%84%E9%A1%BA%E5%BA%8F%E6%89%93%E5%8D%B0%E3%80%82"><span class="toc-number">3.0.1.</span> <span class="toc-text">32.从上到下打印出二叉树的每个节点，同一层的节点按照从左到右的顺序打印。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#32-%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%8C%89%E5%B1%82%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%8C%E5%90%8C%E4%B8%80%E5%B1%82%E7%9A%84%E8%8A%82%E7%82%B9%E6%8C%89%E4%BB%8E%E5%B7%A6%E5%88%B0%E5%8F%B3%E7%9A%84%E9%A1%BA%E5%BA%8F%E6%89%93%E5%8D%B0%EF%BC%8C%E6%AF%8F%E4%B8%80%E5%B1%82%E6%89%93%E5%8D%B0%E5%88%B0%E4%B8%80%E8%A1%8C%E3%80%82"><span class="toc-number">3.0.2.</span> <span class="toc-text">32.从上到下按层打印二叉树，同一层的节点按从左到右的顺序打印，每一层打印到一行。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#32-%E8%AF%B7%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%87%BD%E6%95%B0%E6%8C%89%E7%85%A7%E4%B9%8B%E5%AD%97%E5%BD%A2%E9%A1%BA%E5%BA%8F%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%8C%E5%8D%B3%E7%AC%AC%E4%B8%80%E8%A1%8C%E6%8C%89%E7%85%A7%E4%BB%8E%E5%B7%A6%E5%88%B0%E5%8F%B3%E7%9A%84%E9%A1%BA%E5%BA%8F%E6%89%93%E5%8D%B0%EF%BC%8C%E7%AC%AC%E4%BA%8C%E5%B1%82%E6%8C%89%E7%85%A7%E4%BB%8E%E5%8F%B3%E5%88%B0%E5%B7%A6%E7%9A%84%E9%A1%BA%E5%BA%8F%E6%89%93%E5%8D%B0%EF%BC%8C%E7%AC%AC%E4%B8%89%E8%A1%8C%E5%86%8D%E6%8C%89%E7%85%A7%E4%BB%8E%E5%B7%A6%E5%88%B0%E5%8F%B3%E7%9A%84%E9%A1%BA%E5%BA%8F%E6%89%93%E5%8D%B0%EF%BC%8C%E5%85%B6%E4%BB%96%E8%A1%8C%E4%BB%A5%E6%AD%A4%E7%B1%BB%E6%8E%A8%E3%80%82"><span class="toc-number">3.0.3.</span> <span class="toc-text">32.请实现一个函数按照之字形顺序打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右到左的顺序打印，第三行再按照从左到右的顺序打印，其他行以此类推。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#33-%E8%BE%93%E5%85%A5%E4%B8%80%E4%B8%AA%E6%95%B4%E6%95%B0%E6%95%B0%E7%BB%84%EF%BC%8C%E5%88%A4%E6%96%AD%E8%AF%A5%E6%95%B0%E7%BB%84%E6%98%AF%E4%B8%8D%E6%98%AF%E6%9F%90%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E7%BB%93%E6%9E%9C%E3%80%82%E5%A6%82%E6%9E%9C%E6%98%AF%E5%88%99%E8%BF%94%E5%9B%9E-true%EF%BC%8C%E5%90%A6%E5%88%99%E8%BF%94%E5%9B%9E-false%E3%80%82%E5%81%87%E8%AE%BE%E8%BE%93%E5%85%A5%E7%9A%84%E6%95%B0%E7%BB%84%E7%9A%84%E4%BB%BB%E6%84%8F%E4%B8%A4%E4%B8%AA%E6%95%B0%E5%AD%97%E9%83%BD%E4%BA%92%E4%B8%8D%E7%9B%B8%E5%90%8C%E3%80%82"><span class="toc-number">3.0.4.</span> <span class="toc-text">33.输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历结果。如果是则返回 true，否则返回 false。假设输入的数组的任意两个数字都互不相同。</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%EF%BC%9A"><span class="toc-number">3.0.4.1.</span> <span class="toc-text">解题思路：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B7%E4%BD%93%E5%9C%B0%EF%BC%8C%E6%88%91%E4%BB%AC%E5%8F%AF%E4%BB%A5%E9%A6%96%E5%85%88%E6%89%BE%E5%88%B0%E6%A0%B9%E8%8A%82%E7%82%B9%E7%9A%84%E4%BD%8D%E7%BD%AE%EF%BC%8C%E7%84%B6%E5%90%8E%E5%88%86%E5%88%AB%E9%80%92%E5%BD%92%E5%88%A4%E6%96%AD%E5%B7%A6%E5%AD%90%E6%A0%91%E5%92%8C%E5%8F%B3%E5%AD%90%E6%A0%91%E6%98%AF%E5%90%A6%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E3%80%82"><span class="toc-number">3.0.4.2.</span> <span class="toc-text">具体地，我们可以首先找到根节点的位置，然后分别递归判断左子树和右子树是否为二叉搜索树。</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%90%9C%E7%B4%A2%E4%B8%8E%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95-%E6%A0%91%E7%9B%B8%E5%85%B3"><span class="toc-number">4.</span> <span class="toc-text">搜索与回溯算法 树相关</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#26-%E8%BE%93%E5%85%A5%E4%B8%A4%E6%A3%B5%E4%BA%8C%E5%8F%89%E6%A0%91A%E5%92%8CB%EF%BC%8C%E5%88%A4%E6%96%ADB%E6%98%AF%E4%B8%8D%E6%98%AFA%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84%E3%80%82-%E7%BA%A6%E5%AE%9A%E7%A9%BA%E6%A0%91%E4%B8%8D%E6%98%AF%E4%BB%BB%E6%84%8F%E4%B8%80%E4%B8%AA%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84"><span class="toc-number">4.0.1.</span> <span class="toc-text">26.输入两棵二叉树A和B，判断B是不是A的子结构。(约定空树不是任意一个树的子结构)</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%A7%E5%AE%B6%E6%95%B4%E4%BD%93%E9%80%BB%E8%BE%91%E4%B8%80%E8%87%B4%EF%BC%8C%E9%83%BD%E6%98%AF%EF%BC%9A"><span class="toc-number">4.0.1.0.1.</span> <span class="toc-text">大家整体逻辑一致，都是：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AD%90%E5%87%BD%E6%95%B0iscontain%E7%94%A8%E6%9D%A5%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E8%A2%AB%E5%8C%85%E5%90%AB%EF%BC%8C%E9%80%BB%E8%BE%91%E4%B9%9F%E5%BE%88%E7%AE%80%E5%8D%95%EF%BC%9A%E5%A6%82%E6%9E%9CAB%E8%8A%82%E7%82%B9%E7%9B%B8%E7%AD%89%E5%B0%B1%E5%8E%BB%E5%88%A4%E6%96%AD%E5%90%84%E5%AD%90%E6%A0%91%EF%BC%8C%E5%A6%82%E6%9E%9C%E4%B8%8D%E6%83%B3%E7%AD%89%E7%9B%B4%E6%8E%A5%E8%BF%94%E5%9B%9E%E5%81%87%E3%80%82"><span class="toc-number">4.0.1.0.2.</span> <span class="toc-text">子函数iscontain用来判断是否被包含，逻辑也很简单：如果AB节点相等就去判断各子树，如果不想等直接返回假。</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#27-%E8%AF%B7%E5%AE%8C%E6%88%90%E4%B8%80%E4%B8%AA%E5%87%BD%E6%95%B0%EF%BC%8C%E8%BE%93%E5%85%A5%E4%B8%80%E4%B8%AA%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%8C%E8%AF%A5%E5%87%BD%E6%95%B0%E8%BE%93%E5%87%BA%E5%AE%83%E7%9A%84%E9%95%9C%E5%83%8F%E3%80%82"><span class="toc-number">4.0.2.</span> <span class="toc-text">27.请完成一个函数，输入一个二叉树，该函数输出它的镜像。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#28-%E8%AF%B7%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%87%BD%E6%95%B0%EF%BC%8C%E7%94%A8%E6%9D%A5%E5%88%A4%E6%96%AD%E4%B8%80%E6%A3%B5%E4%BA%8C%E5%8F%89%E6%A0%91%E6%98%AF%E4%B8%8D%E6%98%AF%E5%AF%B9%E7%A7%B0%E7%9A%84%E3%80%82%E5%A6%82%E6%9E%9C%E4%B8%80%E6%A3%B5%E4%BA%8C%E5%8F%89%E6%A0%91%E5%92%8C%E5%AE%83%E7%9A%84%E9%95%9C%E5%83%8F%E4%B8%80%E6%A0%B7%EF%BC%8C%E9%82%A3%E4%B9%88%E5%AE%83%E6%98%AF%E5%AF%B9%E7%A7%B0%E7%9A%84%E3%80%82"><span class="toc-number">4.0.3.</span> <span class="toc-text">28.请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92Dynamic-programming-DP"><span class="toc-number">5.</span> <span class="toc-text">动态规划Dynamic programming(DP)</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">5.1.</span> <span class="toc-text">基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%A0%B7%E7%9A%84%E9%97%AE%E9%A2%98%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="toc-number">5.1.1.</span> <span class="toc-text">什么样的问题可以使用动态规划</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%9A%84%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF"><span class="toc-number">5.1.2.</span> <span class="toc-text">动态规划的解题思路</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E7%A9%B7%E4%B8%BE%E5%88%86%E6%9E%90"><span class="toc-number">5.1.2.1.</span> <span class="toc-text">1. 穷举分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E7%A1%AE%E5%AE%9A%E8%BE%B9%E7%95%8C"><span class="toc-number">5.1.2.2.</span> <span class="toc-text">2. 确定边界</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E6%89%BE%E8%A7%84%E5%BE%8B%EF%BC%8C%E7%A1%AE%E5%AE%9A%E6%9C%80%E4%BC%98%E5%AD%90%E7%BB%93%E6%9E%84"><span class="toc-number">5.1.2.3.</span> <span class="toc-text">3. 找规律，确定最优子结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E5%86%99%E5%87%BA%E7%8A%B6%E6%80%81%E8%BD%AC%E7%A7%BB%E6%96%B9%E7%A8%8B"><span class="toc-number">5.1.2.4.</span> <span class="toc-text">4.写出状态转移方程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-number">5.1.2.5.</span> <span class="toc-text">5. 代码实现</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E4%BF%97%E7%9A%84%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E8%A7%A3%E9%A2%98%E6%AD%A5%E9%AA%A4"><span class="toc-number">5.1.3.</span> <span class="toc-text">通俗的动态规划解题步骤</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%84%E9%80%A0dp%E6%95%B0%E7%BB%84"><span class="toc-number">5.1.3.1.</span> <span class="toc-text">构造dp数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B4%E8%A7%82%E4%B8%8A%E7%9A%84%E7%8A%B6%E6%80%81%E8%BD%AC%E7%A7%BB"><span class="toc-number">5.1.3.2.</span> <span class="toc-text">直观上的状态转移</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%BE%E8%A7%84%E5%BE%8B"><span class="toc-number">5.1.3.3.</span> <span class="toc-text">找规律</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%9A%84%E6%9D%A5%E8%AF%B4%EF%BC%8C%E6%8B%BF%E5%88%B0%E4%B8%80%E9%81%93%E9%A2%98%E7%9B%AE%E5%90%8E%EF%BC%8C%E6%88%91%E4%BB%AC%E5%8F%AF%E4%BB%A5%E6%8C%89%E7%85%A7%E4%B8%8B%E9%9D%A2%E7%9A%84%E6%AD%A5%E9%AA%A4%E8%BF%9B%E8%A1%8C%E5%88%86%E6%9E%90%E3%80%81%E5%B0%9D%E8%AF%95%EF%BC%9A"><span class="toc-number">5.1.3.4.</span> <span class="toc-text">总的来说，拿到一道题目后，我们可以按照下面的步骤进行分析、尝试：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%EF%BC%88Fibonacci%EF%BC%89"><span class="toc-number">5.2.</span> <span class="toc-text">斐波那契（Fibonacci）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BE%88%E6%98%8E%E6%98%BE%EF%BC%8C%E7%94%A8%E9%80%92%E5%BD%92%E7%9B%B4%E6%8E%A5%E8%B6%85%E6%97%B6%EF%BC%8C%E8%BF%98%E5%BE%97%E6%98%AF%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%81"><span class="toc-number">5.2.1.</span> <span class="toc-text">很明显，用递归直接超时，还得是动态规划！</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%88%96%E8%80%85%E7%94%A8%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2-%E9%99%8D%E4%BD%8E%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="toc-number">5.2.2.</span> <span class="toc-text">或者用记忆化搜索 降低复杂度</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%92%E8%9B%99%E8%B7%B3%E5%8F%B0%E9%98%B6"><span class="toc-number">5.3.</span> <span class="toc-text">青蛙跳台阶</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E6%9C%89%E5%87%A0%E4%B8%AA%E5%85%B8%E5%9E%8B%E7%89%B9%E5%BE%81%EF%BC%8C%E6%9C%80%E4%BC%98%E5%AD%90%E7%BB%93%E6%9E%84%E3%80%81%E7%8A%B6%E6%80%81%E8%BD%AC%E7%A7%BB%E6%96%B9%E7%A8%8B%E3%80%81%E8%BE%B9%E7%95%8C%E3%80%81%E9%87%8D%E5%8F%A0%E5%AD%90%E9%97%AE%E9%A2%98%E3%80%82%E5%9C%A8%E9%9D%92%E8%9B%99%E8%B7%B3%E9%98%B6%E9%97%AE%E9%A2%98%E4%B8%AD%EF%BC%9A"><span class="toc-number">5.3.1.</span> <span class="toc-text">动态规划有几个典型特征，最优子结构、状态转移方程、边界、重叠子问题。在青蛙跳阶问题中：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E4%BC%98%E5%AD%90%E7%BB%93%E6%9E%84"><span class="toc-number">5.3.2.</span> <span class="toc-text">最优子结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E5%8F%A0%E5%AD%90%E9%97%AE%E9%A2%98"><span class="toc-number">5.3.3.</span> <span class="toc-text">重叠子问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E5%A4%A7%E5%88%A9%E6%B6%A6"><span class="toc-number">5.4.</span> <span class="toc-text">股票的最大利润</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C"><span class="toc-number">5.5.</span> <span class="toc-text">连续子数组的最大和</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF%E4%B8%80"><span class="toc-number">5.5.0.1.</span> <span class="toc-text">思路一</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF%E4%BA%8C"><span class="toc-number">5.5.0.2.</span> <span class="toc-text">思路二</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E4%BA%8E%E5%9B%9E%E6%BA%AF%E6%B3%95%E4%B8%8EDP"><span class="toc-number">5.5.0.3.</span> <span class="toc-text">关于回溯法与DP</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BC%E7%89%A9%E7%9A%84%E6%9C%80%E5%A4%A7%E4%BB%B7%E5%80%BC"><span class="toc-number">5.6.</span> <span class="toc-text">礼物的最大价值</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%92%E5%BD%92%EF%BC%88%E5%9B%9E%E6%BA%AF%E6%B3%95%EF%BC%89%E6%96%B9%E6%B3%95"><span class="toc-number">5.6.1.</span> <span class="toc-text">递归（回溯法）方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2%EF%BC%88%E5%9B%9E%E6%BA%AF%E6%B3%95%EF%BC%89%EF%BC%88%E5%8D%B3%E8%AE%B0%E5%BD%95%E4%B9%8B%E5%89%8D%E7%9A%84%E5%80%BC%EF%BC%89"><span class="toc-number">5.6.2.</span> <span class="toc-text">记忆化搜索（回溯法）（即记录之前的值）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E6%96%B9%E6%B3%95"><span class="toc-number">5.6.3.</span> <span class="toc-text">动态规划方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E5%AD%97%E7%BF%BB%E8%AF%91%E6%88%90%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">5.7.</span> <span class="toc-text">数字翻译成字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BB%E8%A6%81%E6%80%9D%E8%B7%AF"><span class="toc-number">5.7.1.</span> <span class="toc-text">主要思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0"><span class="toc-number">5.7.2.</span> <span class="toc-text">具体实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E9%95%BF%E4%B8%8D%E5%90%AB%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">5.8.</span> <span class="toc-text"> 最长不含重复字符的子字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9A%E5%BC%80%E5%A7%8B%E6%80%9D%E8%B7%AF"><span class="toc-number">5.8.1.</span> <span class="toc-text">刚开始思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BD%A2%EF%BC%8C%E7%9C%8B%E5%AE%98%E6%96%B9%E9%A2%98%E8%A7%A3"><span class="toc-number">5.8.2.</span> <span class="toc-text">罢，看官方题解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8C%E6%8C%87%E9%92%88%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0"><span class="toc-number">5.8.3.</span> <span class="toc-text">双指针具体实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0"><span class="toc-number">5.8.4.</span> <span class="toc-text">动态规划具体实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%A0%E4%B8%BA%E6%AF%8F%E6%AC%A1dp%E7%BB%93%E6%9E%9C%E5%8F%AA%E4%B8%8E%E4%B8%8A%E4%B8%80%E6%AC%A1dp%E7%9A%84%E7%BB%93%E6%9E%9C%E6%9C%89%E5%85%B3%EF%BC%8C%E5%B0%86%E4%B8%8A%E8%BF%B0%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%BE%97%E5%88%B0"><span class="toc-number">5.8.4.1.</span> <span class="toc-text">因为每次dp结果只与上一次dp的结果有关，将上述代码优化空间复杂度得到</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%98-%E5%AD%97%E6%AF%8D%E4%B8%8E%E6%95%B0%E5%AD%97"><span class="toc-number">5.9.</span> <span class="toc-text">面试题 字母与数字</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%8C%E6%8C%87%E9%92%88"><span class="toc-number">6.</span> <span class="toc-text">双指针</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%91%E6%8C%87-Offer-18-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E8%8A%82%E7%82%B9"><span class="toc-number">6.1.</span> <span class="toc-text">剑指 Offer 18. 删除链表的节点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%91%E6%8C%87-Offer-22-%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E8%8A%82%E7%82%B9"><span class="toc-number">6.2.</span> <span class="toc-text">剑指 Offer 22. 链表中倒数第k个节点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%91%E6%8C%87-Offer-25-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%8E%92%E5%BA%8F%E7%9A%84%E9%93%BE%E8%A1%A8"><span class="toc-number">6.3.</span> <span class="toc-text">剑指 Offer 25. 合并两个排序的链表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%91%E6%8C%87-Offer-52-%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%AC%E5%85%B1%E8%8A%82%E7%82%B9"><span class="toc-number">6.4.</span> <span class="toc-text">剑指 Offer 52. 两个链表的第一个公共节点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%91%E6%8C%87-Offer-21-%E8%B0%83%E6%95%B4%E6%95%B0%E7%BB%84%E9%A1%BA%E5%BA%8F%E4%BD%BF%E5%A5%87%E6%95%B0%E4%BD%8D%E4%BA%8E%E5%81%B6%E6%95%B0%E5%89%8D%E9%9D%A2"><span class="toc-number">6.5.</span> <span class="toc-text">剑指 Offer 21. 调整数组顺序使奇数位于偶数前面</span></a></li></ol></li></ol>
    </div>

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=http://example.com/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=http://example.com/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/&text=算法合集 C++ 剑指Offer"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=http://example.com/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/&title=算法合集 C++ 剑指Offer"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=http://example.com/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/&is_video=false&description=算法合集 C++ 剑指Offer"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=算法合集 C++ 剑指Offer&body=Check out this article: http://example.com/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/"><i class="fas fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=http://example.com/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/&title=算法合集 C++ 剑指Offer"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=http://example.com/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/&title=算法合集 C++ 剑指Offer"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=http://example.com/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/&title=算法合集 C++ 剑指Offer"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=http://example.com/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/&title=算法合集 C++ 剑指Offer"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=http://example.com/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/&name=算法合集 C++ 剑指Offer&description="><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=http://example.com/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/&t=算法合集 C++ 剑指Offer"><i class="fab fa-hacker-news fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fas fa-bars fa-lg" aria-hidden="true"></i> 菜单</a>
        <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fas fa-list fa-lg" aria-hidden="true"></i> 目录</a>
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fas fa-share-alt fa-lg" aria-hidden="true"></i> 分享</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up fa-lg" aria-hidden="true"></i> 返回顶部</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy;
    
    
    2021-2023
    Frostsea
  </div>
  <div class="footer-right">
    <nav>
      <ul>
        <!--
       --><li><a href="/">首页</a></li><!--
     --><!--
       --><li><a href="/about/">关于</a></li><!--
     --><!--
       --><li><a href="/archives/">归档</a></li><!--
     -->


     <!--这一段是不蒜子的访问量统计代码-->
<!-- <script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<span id="busuanzi_container_site_pv">本站总访问量<span id="busuanzi_value_site_pv"></span>次 &nbsp;   </span>
<span id="busuanzi_container_site_uv">访客数<span id="busuanzi_value_site_uv"></span>人次</span> -->

      </ul>
    </nav>
  </div>
</footer>

    </div>
    <!-- styles -->



  <link rel="preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.2/css/all.min.css" crossorigin="anonymous" onload="this.onload=null;this.rel='stylesheet'"/>


    <!-- jquery -->
 
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js" crossorigin="anonymous"></script> 




<!-- clipboard -->

  
    <script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.7/clipboard.min.js" crossorigin="anonymous"></script> 
  
  <script type="text/javascript">
  $(function() {
    // copy-btn HTML
    var btn = "<span class=\"btn-copy tooltipped tooltipped-sw\" aria-label=\"复制到粘贴板！\">";
    btn += '<i class="far fa-clone"></i>';
    btn += '</span>'; 
    // mount it!
    $(".highlight table").before(btn);
    var clip = new ClipboardJS('.btn-copy', {
      text: function(trigger) {
        return Array.from(trigger.nextElementSibling.querySelectorAll('.code')).reduce((str,it)=>str+it.innerText+'\n','')
      }
    });
    clip.on('success', function(e) {
      e.trigger.setAttribute('aria-label', "复制成功！");
      e.clearSelection();
    })
  })
  </script>


<script src="/js/main.js"></script>

<!-- search -->

<!-- Google Analytics -->

<!-- Baidu Analytics -->

<!-- Cloudflare Analytics -->

<!-- Umami Analytics -->

<!-- Disqus Comments -->

<!-- utterances Comments -->

</body>
</html>
