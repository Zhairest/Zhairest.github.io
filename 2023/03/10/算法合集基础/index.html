<!DOCTYPE html>
<html lang=zh>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5" />
    <meta name="description" content="冷知识，笔试一般用的是ACM模式，而不是力扣的核心模式，这意味着你要熟悉写完整的代码，同时包括输入输出！ 【C++&#x2F;笔试】传统OJ &#x2F; ACM模式 读取输入总结 C++基础C++ STL标准库基础  vector 详解 string详解 queue详解 unordered_map      unordered_map4种遍历方式   int转为string：string src &#x3D; to_stri">
<meta property="og:type" content="article">
<meta property="og:title" content="算法合集 C++ 剑指Offer">
<meta property="og:url" content="http://example.com/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/index.html">
<meta property="og:site_name" content="旋转公寓的阁楼">
<meta property="og:description" content="冷知识，笔试一般用的是ACM模式，而不是力扣的核心模式，这意味着你要熟悉写完整的代码，同时包括输入输出！ 【C++&#x2F;笔试】传统OJ &#x2F; ACM模式 读取输入总结 C++基础C++ STL标准库基础  vector 详解 string详解 queue详解 unordered_map      unordered_map4种遍历方式   int转为string：string src &#x3D; to_stri">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/image-20230315205820587.png">
<meta property="og:image" content="http://example.com/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/9ce26a709147ad9ce6152d604efc1cc19a33dc5d467ed2aae5bc68463fdd2888.gif">
<meta property="og:image" content="http://example.com/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/1c8927d9ff605502793d81ab344dbc17e16d6db2d8dd789045f56af432079519.gif">
<meta property="og:image" content="http://example.com/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/8951bc3b8b7eb4da2a46063c1bb96932e7a69910c0a93d973bd8aa5517e59fc8.gif">
<meta property="og:image" content="http://example.com/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/image-20230310110433552.png">
<meta property="og:image" content="http://example.com/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/image-20230310110545093.png">
<meta property="og:image" content="http://example.com/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/image-20230310110623326.png">
<meta property="og:image" content="http://example.com/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/image-20230310110703417.png">
<meta property="og:image" content="http://example.com/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/image-20230310111801195.png">
<meta property="og:image" content="http://example.com/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/image-20230310124214167.png">
<meta property="og:image" content="http://example.com/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/image-20230310130259308.png">
<meta property="og:image" content="http://example.com/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/image-20230310130539704.png">
<meta property="og:image" content="http://example.com/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/image-20230310131649500.png">
<meta property="og:image" content="http://example.com/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/image-20230310133610109.png">
<meta property="og:image" content="http://example.com/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/v2-17700257363921acdbd5718beaed8266_720w.webp">
<meta property="og:image" content="http://example.com/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/image-20230311135947556.png">
<meta property="og:image" content="http://example.com/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/image-20230310132214593.png">
<meta property="og:image" content="http://example.com/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/image-20230310134237927.png">
<meta property="og:image" content="http://example.com/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/image-20230310134247523.png">
<meta property="og:image" content="http://example.com/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/image-20230310141619639.png">
<meta property="og:image" content="http://example.com/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/image-20230310142321486.png">
<meta property="og:image" content="http://example.com/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/image-20230310142419564.png">
<meta property="og:image" content="http://example.com/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/image-20230310142505665.png">
<meta property="og:image" content="http://example.com/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/image-20230310150347481.png">
<meta property="og:image" content="http://example.com/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/image-20230310150402602.png">
<meta property="og:image" content="http://example.com/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/image-20230310155856278.png">
<meta property="og:image" content="http://example.com/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/image-20230310160043917.png">
<meta property="og:image" content="http://example.com/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/image-20230311130018890.png">
<meta property="og:image" content="http://example.com/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/image-20230311133455387.png">
<meta property="og:image" content="http://example.com/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/image-20230311134340534-1678513421403-1.png">
<meta property="og:image" content="http://example.com/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/image-20230311134432069.png">
<meta property="og:image" content="http://example.com/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/image-20230311140828931.png">
<meta property="og:image" content="http://example.com/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/image-20230311143745545.png">
<meta property="og:image" content="http://example.com/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/image-20230311144142877.png">
<meta property="og:image" content="http://example.com/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/image-20230311144218175.png">
<meta property="og:image" content="http://example.com/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/image-20230311144640021.png">
<meta property="og:image" content="http://example.com/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/image-20230311145643385.png">
<meta property="og:image" content="http://example.com/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/image-20230311151330683.png">
<meta property="og:image" content="http://example.com/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/image-20230311152006923.png">
<meta property="og:image" content="http://example.com/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/image-20230311152054563.png">
<meta property="og:image" content="http://example.com/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/image-20230311152124613.png">
<meta property="og:image" content="http://example.com/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/image-20230311153002478.png">
<meta property="og:image" content="http://example.com/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/image-20230311162128491.png">
<meta property="og:image" content="http://example.com/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/image-20230312160400179.png">
<meta property="og:image" content="http://example.com/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/image-20230312162453617.png">
<meta property="og:image" content="http://example.com/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/image-20230312162837680.png">
<meta property="og:image" content="http://example.com/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/image-20230312165703584.png">
<meta property="og:image" content="http://example.com/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/image-20230312165756171.png">
<meta property="og:image" content="http://example.com/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/image-20230312170001133.png">
<meta property="og:image" content="http://example.com/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/image-20230312170011685.png">
<meta property="og:image" content="http://example.com/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/image-20230312172947289.png">
<meta property="og:image" content="http://example.com/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/image-20230312173126674.png">
<meta property="og:image" content="http://example.com/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/image-20230312225116562.png">
<meta property="og:image" content="http://example.com/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/image-20230312232307537.png">
<meta property="og:image" content="http://example.com/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/image-20230314110235880.png">
<meta property="og:image" content="http://example.com/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/image-20230314140832599.png">
<meta property="og:image" content="http://example.com/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/image-20230314151016772.png">
<meta property="og:image" content="http://example.com/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/image-20230314152817092.png">
<meta property="og:image" content="http://example.com/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/image-20230314220219943.png">
<meta property="og:image" content="http://example.com/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/image-20230314222155432.png">
<meta property="og:image" content="http://example.com/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/image-20230315150429812.png">
<meta property="og:image" content="http://example.com/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/image-20230315151218721.png">
<meta property="og:image" content="http://example.com/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/image-20230315155201561.png">
<meta property="og:image" content="http://example.com/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/image-20230315155852457.png">
<meta property="og:image" content="http://example.com/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/image-20230315163121407.png">
<meta property="og:image" content="http://example.com/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/image-20230314222636257.png">
<meta property="og:image" content="http://example.com/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/image-20230314223602255.png">
<meta property="og:image" content="http://example.com/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/image-20230314224229457.png">
<meta property="og:image" content="http://example.com/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/image-20230314233851767.png">
<meta property="og:image" content="http://example.com/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/image-20230315141505487.png">
<meta property="og:image" content="http://example.com/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/image-20230315202307896.png">
<meta property="og:image" content="http://example.com/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/image-20230315202313658.png">
<meta property="og:image" content="http://example.com/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/image-20230315221004093.png">
<meta property="og:image" content="http://example.com/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/image-20230315222115601.png">
<meta property="og:image" content="http://example.com/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/image-20230316130707921.png">
<meta property="og:image" content="http://example.com/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/image-20230315215918667.png">
<meta property="og:image" content="http://example.com/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/image-20230316131104437.png">
<meta property="og:image" content="http://example.com/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/image-20230316142542879.png">
<meta property="og:image" content="http://example.com/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/image-20230316143306919.png">
<meta property="og:image" content="http://example.com/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/image-20230316144946171.png">
<meta property="article:published_time" content="2023-03-10T03:03:42.000Z">
<meta property="article:modified_time" content="2023-03-16T08:16:07.734Z">
<meta property="article:author" content="Frostsea">
<meta property="article:tag" content="算法">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/image-20230315205820587.png">
    
    
      
        
          <link rel="shortcut icon" href="/images/favicon.ico">
        
      
      
        
          <link rel="icon" type="image/png" href="/images/favicon-192x192.png" sizes="192x192">
        
      
      
        
          <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
        
      
    
    <!-- title -->
    <title>算法合集 C++ 剑指Offer</title>
    <!-- styles -->
    
<link rel="stylesheet" href="/css/style.css">

    <!-- persian styles -->
    
    <!-- rss -->
    
    
	<!-- mathjax -->
	
<meta name="generator" content="Hexo 5.4.0"></head>

<body class="max-width mx-auto px3 ltr">
    
      <div id="header-post">
  <a id="menu-icon" href="#" aria-label="目录"><i class="fas fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#" aria-label="目录"><i class="fas fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" aria-label="顶部" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fas fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
        <!--
       --><li><a href="/">首页</a></li><!--
     --><!--
       --><li><a href="/about/">关于</a></li><!--
     --><!--
       --><li><a href="/archives/">归档</a></li><!--
     -->
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        <li><a class="icon" aria-label="上一篇" href="/2023/03/10/Unity%E5%9F%BA%E7%A1%80/"><i class="fas fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" aria-label="下一篇" href="/2023/03/08/Csharp_%E5%9F%BA%E7%A1%80/"><i class="fas fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" aria-label="返回顶部" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" aria-label="分享文章" href="#"><i class="fas fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">上一篇</span>
      <span id="i-next" class="info" style="display:none;">下一篇</span>
      <span id="i-top" class="info" style="display:none;">返回顶部</span>
      <span id="i-share" class="info" style="display:none;">分享文章</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=http://example.com/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=http://example.com/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/&text=算法合集 C++ 剑指Offer"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=http://example.com/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/&title=算法合集 C++ 剑指Offer"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=http://example.com/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/&is_video=false&description=算法合集 C++ 剑指Offer"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=算法合集 C++ 剑指Offer&body=Check out this article: http://example.com/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/"><i class="fas fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=http://example.com/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/&title=算法合集 C++ 剑指Offer"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=http://example.com/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/&title=算法合集 C++ 剑指Offer"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=http://example.com/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/&title=算法合集 C++ 剑指Offer"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=http://example.com/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/&title=算法合集 C++ 剑指Offer"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=http://example.com/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/&name=算法合集 C++ 剑指Offer&description="><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=http://example.com/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/&t=算法合集 C++ 剑指Offer"><i class="fab fa-hacker-news " aria-hidden="true"></i></a></li>
</ul>

    </div>
    <div id="toc">
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#C-%E5%9F%BA%E7%A1%80"><span class="toc-number">1.</span> <span class="toc-text">C++基础</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%80%92%E5%BD%92%E4%B8%8E%E5%88%86%E6%B2%BB%EF%BC%8C%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%8C%E8%B4%AA%E5%BF%83%EF%BC%8C%E5%9B%9E%E6%BA%AF%EF%BC%8C%E5%88%86%E6%94%AF%E7%95%8C%E9%99%90%E6%B3%95"><span class="toc-number">2.</span> <span class="toc-text">递归与分治，动态规划，贪心，回溯，分支界限法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%93%BE%E8%A1%A8"><span class="toc-number">3.</span> <span class="toc-text">链表</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#NC78-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8"><span class="toc-number">3.1.</span> <span class="toc-text">NC78 反转链表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9C%8B%E4%B8%8D%E6%87%82%E9%80%92%E5%BD%92%E7%9A%84%E7%9C%8B%E8%BF%87%E6%9D%A5%EF%BC%8C%E5%B8%8C%E6%9C%9B%E8%83%BD%E5%B8%AE%E5%88%B0%E4%BD%A0%EF%BC%81"><span class="toc-number">3.1.1.</span> <span class="toc-text">看不懂递归的看过来，希望能帮到你！</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8%E3%80%91%EF%BC%9A%E5%8F%8C%E6%8C%87%E9%92%88%EF%BC%8C%E9%80%92%E5%BD%92%EF%BC%8C%E5%A6%96%E9%AD%94%E5%8C%96%E7%9A%84%E5%8F%8C%E6%8C%87%E9%92%88"><span class="toc-number">3.1.2.</span> <span class="toc-text">【反转链表】：双指针，递归，妖魔化的双指针</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BD%BB%E6%9D%BE%E7%89%88%E5%8F%8C%E6%8C%87%E9%92%88"><span class="toc-number">3.1.2.1.</span> <span class="toc-text">轻松版双指针</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%96%E9%AD%94%E5%8C%96%E5%8F%8C%E6%8C%87%E9%92%88"><span class="toc-number">3.1.2.2.</span> <span class="toc-text">妖魔化双指针</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%80%E6%B4%81%E7%9A%84%E9%80%92%E5%BD%92"><span class="toc-number">3.1.2.3.</span> <span class="toc-text">简洁的递归</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%90%9C%E7%B4%A2%E4%B8%8E%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9B%B8%E5%85%B3"><span class="toc-number">4.</span> <span class="toc-text">搜索与回溯算法 二叉树相关</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#32-%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E5%87%BA%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%AF%8F%E4%B8%AA%E8%8A%82%E7%82%B9%EF%BC%8C%E5%90%8C%E4%B8%80%E5%B1%82%E7%9A%84%E8%8A%82%E7%82%B9%E6%8C%89%E7%85%A7%E4%BB%8E%E5%B7%A6%E5%88%B0%E5%8F%B3%E7%9A%84%E9%A1%BA%E5%BA%8F%E6%89%93%E5%8D%B0%E3%80%82"><span class="toc-number">4.0.1.</span> <span class="toc-text">32.从上到下打印出二叉树的每个节点，同一层的节点按照从左到右的顺序打印。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#32-%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%8C%89%E5%B1%82%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%8C%E5%90%8C%E4%B8%80%E5%B1%82%E7%9A%84%E8%8A%82%E7%82%B9%E6%8C%89%E4%BB%8E%E5%B7%A6%E5%88%B0%E5%8F%B3%E7%9A%84%E9%A1%BA%E5%BA%8F%E6%89%93%E5%8D%B0%EF%BC%8C%E6%AF%8F%E4%B8%80%E5%B1%82%E6%89%93%E5%8D%B0%E5%88%B0%E4%B8%80%E8%A1%8C%E3%80%82"><span class="toc-number">4.0.2.</span> <span class="toc-text">32.从上到下按层打印二叉树，同一层的节点按从左到右的顺序打印，每一层打印到一行。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#32-%E8%AF%B7%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%87%BD%E6%95%B0%E6%8C%89%E7%85%A7%E4%B9%8B%E5%AD%97%E5%BD%A2%E9%A1%BA%E5%BA%8F%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%8C%E5%8D%B3%E7%AC%AC%E4%B8%80%E8%A1%8C%E6%8C%89%E7%85%A7%E4%BB%8E%E5%B7%A6%E5%88%B0%E5%8F%B3%E7%9A%84%E9%A1%BA%E5%BA%8F%E6%89%93%E5%8D%B0%EF%BC%8C%E7%AC%AC%E4%BA%8C%E5%B1%82%E6%8C%89%E7%85%A7%E4%BB%8E%E5%8F%B3%E5%88%B0%E5%B7%A6%E7%9A%84%E9%A1%BA%E5%BA%8F%E6%89%93%E5%8D%B0%EF%BC%8C%E7%AC%AC%E4%B8%89%E8%A1%8C%E5%86%8D%E6%8C%89%E7%85%A7%E4%BB%8E%E5%B7%A6%E5%88%B0%E5%8F%B3%E7%9A%84%E9%A1%BA%E5%BA%8F%E6%89%93%E5%8D%B0%EF%BC%8C%E5%85%B6%E4%BB%96%E8%A1%8C%E4%BB%A5%E6%AD%A4%E7%B1%BB%E6%8E%A8%E3%80%82"><span class="toc-number">4.0.3.</span> <span class="toc-text">32.请实现一个函数按照之字形顺序打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右到左的顺序打印，第三行再按照从左到右的顺序打印，其他行以此类推。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#33-%E8%BE%93%E5%85%A5%E4%B8%80%E4%B8%AA%E6%95%B4%E6%95%B0%E6%95%B0%E7%BB%84%EF%BC%8C%E5%88%A4%E6%96%AD%E8%AF%A5%E6%95%B0%E7%BB%84%E6%98%AF%E4%B8%8D%E6%98%AF%E6%9F%90%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E7%BB%93%E6%9E%9C%E3%80%82%E5%A6%82%E6%9E%9C%E6%98%AF%E5%88%99%E8%BF%94%E5%9B%9E-true%EF%BC%8C%E5%90%A6%E5%88%99%E8%BF%94%E5%9B%9E-false%E3%80%82%E5%81%87%E8%AE%BE%E8%BE%93%E5%85%A5%E7%9A%84%E6%95%B0%E7%BB%84%E7%9A%84%E4%BB%BB%E6%84%8F%E4%B8%A4%E4%B8%AA%E6%95%B0%E5%AD%97%E9%83%BD%E4%BA%92%E4%B8%8D%E7%9B%B8%E5%90%8C%E3%80%82"><span class="toc-number">4.0.4.</span> <span class="toc-text">33.输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历结果。如果是则返回 true，否则返回 false。假设输入的数组的任意两个数字都互不相同。</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%EF%BC%9A"><span class="toc-number">4.0.4.1.</span> <span class="toc-text">解题思路：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B7%E4%BD%93%E5%9C%B0%EF%BC%8C%E6%88%91%E4%BB%AC%E5%8F%AF%E4%BB%A5%E9%A6%96%E5%85%88%E6%89%BE%E5%88%B0%E6%A0%B9%E8%8A%82%E7%82%B9%E7%9A%84%E4%BD%8D%E7%BD%AE%EF%BC%8C%E7%84%B6%E5%90%8E%E5%88%86%E5%88%AB%E9%80%92%E5%BD%92%E5%88%A4%E6%96%AD%E5%B7%A6%E5%AD%90%E6%A0%91%E5%92%8C%E5%8F%B3%E5%AD%90%E6%A0%91%E6%98%AF%E5%90%A6%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E3%80%82"><span class="toc-number">4.0.4.2.</span> <span class="toc-text">具体地，我们可以首先找到根节点的位置，然后分别递归判断左子树和右子树是否为二叉搜索树。</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%90%9C%E7%B4%A2%E4%B8%8E%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95-%E6%A0%91%E7%9B%B8%E5%85%B3"><span class="toc-number">5.</span> <span class="toc-text">搜索与回溯算法 树相关</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#26-%E8%BE%93%E5%85%A5%E4%B8%A4%E6%A3%B5%E4%BA%8C%E5%8F%89%E6%A0%91A%E5%92%8CB%EF%BC%8C%E5%88%A4%E6%96%ADB%E6%98%AF%E4%B8%8D%E6%98%AFA%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84%E3%80%82-%E7%BA%A6%E5%AE%9A%E7%A9%BA%E6%A0%91%E4%B8%8D%E6%98%AF%E4%BB%BB%E6%84%8F%E4%B8%80%E4%B8%AA%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84"><span class="toc-number">5.0.1.</span> <span class="toc-text">26.输入两棵二叉树A和B，判断B是不是A的子结构。(约定空树不是任意一个树的子结构)</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%A7%E5%AE%B6%E6%95%B4%E4%BD%93%E9%80%BB%E8%BE%91%E4%B8%80%E8%87%B4%EF%BC%8C%E9%83%BD%E6%98%AF%EF%BC%9A"><span class="toc-number">5.0.1.0.1.</span> <span class="toc-text">大家整体逻辑一致，都是：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AD%90%E5%87%BD%E6%95%B0iscontain%E7%94%A8%E6%9D%A5%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E8%A2%AB%E5%8C%85%E5%90%AB%EF%BC%8C%E9%80%BB%E8%BE%91%E4%B9%9F%E5%BE%88%E7%AE%80%E5%8D%95%EF%BC%9A%E5%A6%82%E6%9E%9CAB%E8%8A%82%E7%82%B9%E7%9B%B8%E7%AD%89%E5%B0%B1%E5%8E%BB%E5%88%A4%E6%96%AD%E5%90%84%E5%AD%90%E6%A0%91%EF%BC%8C%E5%A6%82%E6%9E%9C%E4%B8%8D%E6%83%B3%E7%AD%89%E7%9B%B4%E6%8E%A5%E8%BF%94%E5%9B%9E%E5%81%87%E3%80%82"><span class="toc-number">5.0.1.0.2.</span> <span class="toc-text">子函数iscontain用来判断是否被包含，逻辑也很简单：如果AB节点相等就去判断各子树，如果不想等直接返回假。</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#27-%E8%AF%B7%E5%AE%8C%E6%88%90%E4%B8%80%E4%B8%AA%E5%87%BD%E6%95%B0%EF%BC%8C%E8%BE%93%E5%85%A5%E4%B8%80%E4%B8%AA%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%8C%E8%AF%A5%E5%87%BD%E6%95%B0%E8%BE%93%E5%87%BA%E5%AE%83%E7%9A%84%E9%95%9C%E5%83%8F%E3%80%82"><span class="toc-number">5.0.2.</span> <span class="toc-text">27.请完成一个函数，输入一个二叉树，该函数输出它的镜像。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#28-%E8%AF%B7%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%87%BD%E6%95%B0%EF%BC%8C%E7%94%A8%E6%9D%A5%E5%88%A4%E6%96%AD%E4%B8%80%E6%A3%B5%E4%BA%8C%E5%8F%89%E6%A0%91%E6%98%AF%E4%B8%8D%E6%98%AF%E5%AF%B9%E7%A7%B0%E7%9A%84%E3%80%82%E5%A6%82%E6%9E%9C%E4%B8%80%E6%A3%B5%E4%BA%8C%E5%8F%89%E6%A0%91%E5%92%8C%E5%AE%83%E7%9A%84%E9%95%9C%E5%83%8F%E4%B8%80%E6%A0%B7%EF%BC%8C%E9%82%A3%E4%B9%88%E5%AE%83%E6%98%AF%E5%AF%B9%E7%A7%B0%E7%9A%84%E3%80%82"><span class="toc-number">5.0.3.</span> <span class="toc-text">28.请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92Dynamic-programming-DP"><span class="toc-number">6.</span> <span class="toc-text">动态规划Dynamic programming(DP)</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">6.1.</span> <span class="toc-text">基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%A0%B7%E7%9A%84%E9%97%AE%E9%A2%98%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="toc-number">6.1.1.</span> <span class="toc-text">什么样的问题可以使用动态规划</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%9A%84%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF"><span class="toc-number">6.1.2.</span> <span class="toc-text">动态规划的解题思路</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E7%A9%B7%E4%B8%BE%E5%88%86%E6%9E%90"><span class="toc-number">6.1.2.1.</span> <span class="toc-text">1. 穷举分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E7%A1%AE%E5%AE%9A%E8%BE%B9%E7%95%8C"><span class="toc-number">6.1.2.2.</span> <span class="toc-text">2. 确定边界</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E6%89%BE%E8%A7%84%E5%BE%8B%EF%BC%8C%E7%A1%AE%E5%AE%9A%E6%9C%80%E4%BC%98%E5%AD%90%E7%BB%93%E6%9E%84"><span class="toc-number">6.1.2.3.</span> <span class="toc-text">3. 找规律，确定最优子结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E5%86%99%E5%87%BA%E7%8A%B6%E6%80%81%E8%BD%AC%E7%A7%BB%E6%96%B9%E7%A8%8B"><span class="toc-number">6.1.2.4.</span> <span class="toc-text">4.写出状态转移方程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-number">6.1.2.5.</span> <span class="toc-text">5. 代码实现</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E4%BF%97%E7%9A%84%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E8%A7%A3%E9%A2%98%E6%AD%A5%E9%AA%A4"><span class="toc-number">6.1.3.</span> <span class="toc-text">通俗的动态规划解题步骤</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%84%E9%80%A0dp%E6%95%B0%E7%BB%84"><span class="toc-number">6.1.3.1.</span> <span class="toc-text">构造dp数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B4%E8%A7%82%E4%B8%8A%E7%9A%84%E7%8A%B6%E6%80%81%E8%BD%AC%E7%A7%BB"><span class="toc-number">6.1.3.2.</span> <span class="toc-text">直观上的状态转移</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%BE%E8%A7%84%E5%BE%8B"><span class="toc-number">6.1.3.3.</span> <span class="toc-text">找规律</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%9A%84%E6%9D%A5%E8%AF%B4%EF%BC%8C%E6%8B%BF%E5%88%B0%E4%B8%80%E9%81%93%E9%A2%98%E7%9B%AE%E5%90%8E%EF%BC%8C%E6%88%91%E4%BB%AC%E5%8F%AF%E4%BB%A5%E6%8C%89%E7%85%A7%E4%B8%8B%E9%9D%A2%E7%9A%84%E6%AD%A5%E9%AA%A4%E8%BF%9B%E8%A1%8C%E5%88%86%E6%9E%90%E3%80%81%E5%B0%9D%E8%AF%95%EF%BC%9A"><span class="toc-number">6.1.3.4.</span> <span class="toc-text">总的来说，拿到一道题目后，我们可以按照下面的步骤进行分析、尝试：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%EF%BC%88Fibonacci%EF%BC%89"><span class="toc-number">6.2.</span> <span class="toc-text">斐波那契（Fibonacci）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BE%88%E6%98%8E%E6%98%BE%EF%BC%8C%E7%94%A8%E9%80%92%E5%BD%92%E7%9B%B4%E6%8E%A5%E8%B6%85%E6%97%B6%EF%BC%8C%E8%BF%98%E5%BE%97%E6%98%AF%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%81"><span class="toc-number">6.2.1.</span> <span class="toc-text">很明显，用递归直接超时，还得是动态规划！</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%88%96%E8%80%85%E7%94%A8%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2-%E9%99%8D%E4%BD%8E%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="toc-number">6.2.2.</span> <span class="toc-text">或者用记忆化搜索 降低复杂度</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%92%E8%9B%99%E8%B7%B3%E5%8F%B0%E9%98%B6"><span class="toc-number">6.3.</span> <span class="toc-text">青蛙跳台阶</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E6%9C%89%E5%87%A0%E4%B8%AA%E5%85%B8%E5%9E%8B%E7%89%B9%E5%BE%81%EF%BC%8C%E6%9C%80%E4%BC%98%E5%AD%90%E7%BB%93%E6%9E%84%E3%80%81%E7%8A%B6%E6%80%81%E8%BD%AC%E7%A7%BB%E6%96%B9%E7%A8%8B%E3%80%81%E8%BE%B9%E7%95%8C%E3%80%81%E9%87%8D%E5%8F%A0%E5%AD%90%E9%97%AE%E9%A2%98%E3%80%82%E5%9C%A8%E9%9D%92%E8%9B%99%E8%B7%B3%E9%98%B6%E9%97%AE%E9%A2%98%E4%B8%AD%EF%BC%9A"><span class="toc-number">6.3.1.</span> <span class="toc-text">动态规划有几个典型特征，最优子结构、状态转移方程、边界、重叠子问题。在青蛙跳阶问题中：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E4%BC%98%E5%AD%90%E7%BB%93%E6%9E%84"><span class="toc-number">6.3.2.</span> <span class="toc-text">最优子结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E5%8F%A0%E5%AD%90%E9%97%AE%E9%A2%98"><span class="toc-number">6.3.3.</span> <span class="toc-text">重叠子问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E5%A4%A7%E5%88%A9%E6%B6%A6"><span class="toc-number">6.4.</span> <span class="toc-text">股票的最大利润</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C"><span class="toc-number">6.5.</span> <span class="toc-text">连续子数组的最大和</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF%E4%B8%80"><span class="toc-number">6.5.0.1.</span> <span class="toc-text">思路一</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF%E4%BA%8C"><span class="toc-number">6.5.0.2.</span> <span class="toc-text">思路二</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E4%BA%8E%E5%9B%9E%E6%BA%AF%E6%B3%95%E4%B8%8EDP"><span class="toc-number">6.5.0.3.</span> <span class="toc-text">关于回溯法与DP</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BC%E7%89%A9%E7%9A%84%E6%9C%80%E5%A4%A7%E4%BB%B7%E5%80%BC"><span class="toc-number">6.6.</span> <span class="toc-text">礼物的最大价值</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%92%E5%BD%92%EF%BC%88%E5%9B%9E%E6%BA%AF%E6%B3%95%EF%BC%89%E6%96%B9%E6%B3%95"><span class="toc-number">6.6.1.</span> <span class="toc-text">递归（回溯法）方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2%EF%BC%88%E5%9B%9E%E6%BA%AF%E6%B3%95%EF%BC%89%EF%BC%88%E5%8D%B3%E8%AE%B0%E5%BD%95%E4%B9%8B%E5%89%8D%E7%9A%84%E5%80%BC%EF%BC%89"><span class="toc-number">6.6.2.</span> <span class="toc-text">记忆化搜索（回溯法）（即记录之前的值）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E6%96%B9%E6%B3%95"><span class="toc-number">6.6.3.</span> <span class="toc-text">动态规划方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E5%AD%97%E7%BF%BB%E8%AF%91%E6%88%90%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">6.7.</span> <span class="toc-text">数字翻译成字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BB%E8%A6%81%E6%80%9D%E8%B7%AF"><span class="toc-number">6.7.1.</span> <span class="toc-text">主要思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0"><span class="toc-number">6.7.2.</span> <span class="toc-text">具体实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%AD%90-%E6%9C%80%E9%95%BF%E4%B8%8D%E5%90%AB%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">6.8.</span> <span class="toc-text">⭐ 最长不含重复字符的子字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9A%E5%BC%80%E5%A7%8B%E6%80%9D%E8%B7%AF"><span class="toc-number">6.8.1.</span> <span class="toc-text">刚开始思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BD%A2%EF%BC%8C%E7%9C%8B%E5%AE%98%E6%96%B9%E9%A2%98%E8%A7%A3"><span class="toc-number">6.8.2.</span> <span class="toc-text">罢，看官方题解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8C%E6%8C%87%E9%92%88%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0"><span class="toc-number">6.8.3.</span> <span class="toc-text">双指针具体实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0"><span class="toc-number">6.8.4.</span> <span class="toc-text">动态规划具体实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%A0%E4%B8%BA%E6%AF%8F%E6%AC%A1dp%E7%BB%93%E6%9E%9C%E5%8F%AA%E4%B8%8E%E4%B8%8A%E4%B8%80%E6%AC%A1dp%E7%9A%84%E7%BB%93%E6%9E%9C%E6%9C%89%E5%85%B3%EF%BC%8C%E5%B0%86%E4%B8%8A%E8%BF%B0%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%BE%97%E5%88%B0"><span class="toc-number">6.8.4.1.</span> <span class="toc-text">因为每次dp结果只与上一次dp的结果有关，将上述代码优化空间复杂度得到</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%AD%90%E9%9D%A2%E8%AF%95%E9%A2%98-%E5%AD%97%E6%AF%8D%E4%B8%8E%E6%95%B0%E5%AD%97"><span class="toc-number">6.9.</span> <span class="toc-text">⭐面试题 字母与数字</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%8C%E6%8C%87%E9%92%88"><span class="toc-number">7.</span> <span class="toc-text">双指针</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%91%E6%8C%87-Offer-18-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E8%8A%82%E7%82%B9"><span class="toc-number">7.1.</span> <span class="toc-text">剑指 Offer 18. 删除链表的节点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%91%E6%8C%87-Offer-22-%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E8%8A%82%E7%82%B9"><span class="toc-number">7.2.</span> <span class="toc-text">剑指 Offer 22. 链表中倒数第k个节点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%91%E6%8C%87-Offer-25-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%8E%92%E5%BA%8F%E7%9A%84%E9%93%BE%E8%A1%A8"><span class="toc-number">7.3.</span> <span class="toc-text">剑指 Offer 25. 合并两个排序的链表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%91%E6%8C%87-Offer-52-%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%AC%E5%85%B1%E8%8A%82%E7%82%B9"><span class="toc-number">7.4.</span> <span class="toc-text">剑指 Offer 52. 两个链表的第一个公共节点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%91%E6%8C%87-Offer-21-%E8%B0%83%E6%95%B4%E6%95%B0%E7%BB%84%E9%A1%BA%E5%BA%8F%E4%BD%BF%E5%A5%87%E6%95%B0%E4%BD%8D%E4%BA%8E%E5%81%B6%E6%95%B0%E5%89%8D%E9%9D%A2"><span class="toc-number">7.5.</span> <span class="toc-text">剑指 Offer 21. 调整数组顺序使奇数位于偶数前面</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%91%E6%8C%87-Offer-57-%E5%92%8C%E4%B8%BAs%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%95%B0%E5%AD%97"><span class="toc-number">7.6.</span> <span class="toc-text">剑指 Offer 57. 和为s的两个数字</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%91%E6%8C%87-Offer-58-I-%E7%BF%BB%E8%BD%AC%E5%8D%95%E8%AF%8D%E9%A1%BA%E5%BA%8F"><span class="toc-number">7.7.</span> <span class="toc-text">剑指 Offer 58 - I. 翻转单词顺序</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%90%9C%E7%B4%A2%E4%B8%8E%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%AD%E7%AD%89%EF%BC%89"><span class="toc-number">8.</span> <span class="toc-text">搜索与回溯算法（中等）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%AD%90%E5%89%91%E6%8C%87-Offer-12-%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84"><span class="toc-number">8.1.</span> <span class="toc-text">⭐剑指 Offer 12. 矩阵中的路径</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%AD%90%E9%9D%A2%E8%AF%95%E9%A2%9813-%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E8%BF%90%E5%8A%A8%E8%8C%83%E5%9B%B4"><span class="toc-number">8.2.</span> <span class="toc-text">⭐面试题13. 机器人的运动范围</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B7%B1%E5%BA%A6%E9%81%8D%E5%8E%86-34-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%92%8C%E4%B8%BA%E6%9F%90%E4%B8%80%E5%80%BC%E7%9A%84%E8%B7%AF%E5%BE%84"><span class="toc-number">8.3.</span> <span class="toc-text">深度遍历 34. 二叉树中和为某一值的路径</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%AD%90%E5%89%91%E6%8C%87-Offer-36-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%8E%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8"><span class="toc-number">8.4.</span> <span class="toc-text">⭐剑指 Offer 36. 二叉搜索树与双向链表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%91%E6%8C%87-Offer-54-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E7%AC%ACk%E5%A4%A7%E8%8A%82%E7%82%B9"><span class="toc-number">8.5.</span> <span class="toc-text">剑指 Offer 54. 二叉搜索树的第k大节点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%AD%90%E5%89%91%E6%8C%87-Offer-55-I-%E6%B1%82%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6"><span class="toc-number">8.6.</span> <span class="toc-text">⭐剑指 Offer 55 - I.求二叉树的深度</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%AD%90%E5%89%91%E6%8C%87-Offer-55-II-%E5%88%A4%E6%96%AD%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">8.7.</span> <span class="toc-text">⭐剑指 Offer 55 - II. 判断平衡二叉树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E7%9F%AD%E8%B7%AF%E6%80%A7%E8%B4%A8-%E6%B1%821-2-%E2%80%A6-n"><span class="toc-number">8.8.</span> <span class="toc-text">逻辑运算符的短路性质. 求1+2+…+n</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E7%9F%AD%E8%B7%AF%E6%80%A7%E8%B4%A8"><span class="toc-number">8.8.1.</span> <span class="toc-text">逻辑运算符的短路性质</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%AD%90%E5%89%91%E6%8C%87-Offer-68-I-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88"><span class="toc-number">8.9.</span> <span class="toc-text">⭐剑指 Offer 68 - I. 二叉搜索树的最近公共祖先</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%AD%90%E2%AD%90%E5%89%91%E6%8C%87-Offer-68-II-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88"><span class="toc-number">8.10.</span> <span class="toc-text">⭐⭐剑指 Offer 68 - II. 二叉树的最近公共祖先</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F"><span class="toc-number">9.</span> <span class="toc-text">排序</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%AD%90%E9%9D%A2%E8%AF%95%E9%A2%9845-%E6%8A%8A%E6%95%B0%E7%BB%84%E6%8E%92%E6%88%90%E6%9C%80%E5%B0%8F%E7%9A%84%E6%95%B0"><span class="toc-number">9.1.</span> <span class="toc-text">⭐面试题45. 把数组排成最小的数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%9861-%E6%89%91%E5%85%8B%E7%89%8C%E4%B8%AD%E7%9A%84%E9%A1%BA%E5%AD%90"><span class="toc-number">9.2.</span> <span class="toc-text">面试题61. 扑克牌中的顺子</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%AD%90%E5%BF%AB%E6%8E%92%E5%AE%9E%E7%8E%B0-%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0"><span class="toc-number">9.3.</span> <span class="toc-text">⭐快排实现. 最小的k个数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%91%E6%8C%87-Offer-41-%E6%95%B0%E6%8D%AE%E6%B5%81%E4%B8%AD%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0"><span class="toc-number">9.4.</span> <span class="toc-text">剑指 Offer 41. 数据流中的中位数</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A0%88"><span class="toc-number">10.</span> <span class="toc-text">栈</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#150-%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC"><span class="toc-number">10.1.</span> <span class="toc-text">150. 逆波兰表达式求值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%AD%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%BD%AC%E5%8C%96%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">10.2.</span> <span class="toc-text">中缀表达式转化后缀表达式</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%9A%8F%E6%9C%BA%E7%BB%83%E4%B9%A0"><span class="toc-number">11.</span> <span class="toc-text">随机练习</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%AD%90%E2%AD%90-%E7%BB%99%E5%AE%9A%E6%95%B0%E5%AD%97%E8%83%BD%E7%BB%84%E6%88%90%E7%9A%84%E6%9C%80%E5%A4%A7%E6%97%B6%E9%97%B4"><span class="toc-number">11.1.</span> <span class="toc-text">⭐⭐ 给定数字能组成的最大时间</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%91%E7%8E%B0%EF%BC%8C%E5%8F%AA%E8%A6%81%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%97%B6%EF%BC%8C%E6%8C%89%E7%85%A7%E5%8D%87%E5%BA%8F%E6%8E%92%E5%88%97%EF%BC%8C%E5%8D%B3%E5%8F%AF%E8%BE%93%E5%87%BA%E7%AC%A6%E5%90%88%E8%A7%84%E5%88%99%E7%9A%84%E6%9C%80%E5%B0%8F%E6%97%B6%E9%97%B4"><span class="toc-number">11.1.0.1.</span> <span class="toc-text">发现，只要在排序时，按照升序排列，即可输出符合规则的最小时间</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6%E4%BD%8D%E6%95%B0%E8%83%BD%E6%8B%BC%E5%87%BA%E7%9A%84%E6%9C%80%E6%99%9A%E6%97%B6%E9%97%B4%E5%92%8C%E6%9C%80%E6%97%A9%E6%97%B6%E9%97%B4"><span class="toc-number">11.2.</span> <span class="toc-text">6位数能拼出的最晚时间和最早时间</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%88%86%E6%B2%BB%EF%BC%88%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%89"><span class="toc-number">12.</span> <span class="toc-text">分治（二叉树）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%AD%90%E2%AD%90%E5%89%91%E6%8C%87-Offer-07-%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">12.1.</span> <span class="toc-text">⭐⭐剑指 Offer 07. 重建二叉树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E5%B9%82%E2%AD%90-%E6%95%B0%E5%80%BC%E7%9A%84%E6%95%B4%E6%95%B0%E6%AC%A1%E6%96%B9"><span class="toc-number">12.2.</span> <span class="toc-text">快速幂⭐ 数值的整数次方</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E5%B9%82"><span class="toc-number">12.2.1.</span> <span class="toc-text">快速幂</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#GOOD-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97"><span class="toc-number">12.3.</span> <span class="toc-text">GOOD. 二叉搜索树的后序遍历序列</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BD%8D%E8%BF%90%E7%AE%97"><span class="toc-number">13.</span> <span class="toc-text">位运算</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%91%E6%8C%87-Offer-15-%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0"><span class="toc-number">13.1.</span> <span class="toc-text">剑指 Offer 15. 二进制中1的个数</span></a></li></ol></li></ol>
    </div>
  </span>
</div>

    
    <div class="content index py4">
        
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle" itemprop="name headline">
        算法合集 C++ 剑指Offer
    </h1>



    <div class="meta">
      <span class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span itemprop="name">Frostsea</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2023-03-10T03:03:42.000Z" itemprop="datePublished">2023-03-10</time>
        
      
    </div>


      

      
    <div class="article-tag">
        <i class="fas fa-tag"></i>
        <a class="tag-link-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a>
    </div>


    </div>
  </header>
  

  <div class="content" itemprop="articleBody">
    <p><strong>冷知识，笔试一般用的是ACM模式，而不是力扣的核心模式，这意味着你要熟悉写完整的代码，同时包括输入输出！</strong></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/ReRayda/article/details/126016647">【C++/笔试】传统OJ / ACM模式 读取输入总结</a></p>
<h1 id="C-基础"><a href="#C-基础" class="headerlink" title="C++基础"></a>C++基础</h1><p><a target="_blank" rel="noopener" href="http://m.biancheng.net/stl/stl_basic/">C++ STL标准库基础</a></p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qiancm/article/details/119611928">vector 详解</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/acc_hoyh/article/details/122974190">string详解</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_42185999/article/details/115331051">queue详解</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/langyao/p/8823092.html">unordered_map</a>      <a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_21539375/article/details/122003559">unordered_map4种遍历方式</a></p>
</blockquote>
<blockquote>
<p>int转为string：string src = to_string(num);</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/sinat_22510827/article/details/125758285">c++中的atoi()和stoi()函数的用法和区别</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_42366672/article/details/114146606">stol和stoll函数</a></p>
</blockquote>
<blockquote>
<p>c++unordered_map中的find()查找函数:</p>
<p>​    在容器中搜索键值等于 k 的元素，如果找到，则返回一个指向该元素的迭代器，否则返回一个指向<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=unordered_map&spm=1001.2101.3001.7020">unordered_map</a> :: end的迭代器。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 找到了，则返回对应的数字</span></span><br><span class="line">     <span class="keyword">if</span>(tags_map.<span class="built_in">find</span>(hand[i]) != tags_map.<span class="built_in">end</span>())</span><br></pre></td></tr></table></figure>

</blockquote>
<p> <a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_42604176/article/details/108984456">什么时候用 “.” 什么时候用“-＞”</a></p>
<h1 id="递归与分治，动态规划，贪心，回溯，分支界限法"><a href="#递归与分治，动态规划，贪心，回溯，分支界限法" class="headerlink" title="递归与分治，动态规划，贪心，回溯，分支界限法"></a>递归与分治，动态规划，贪心，回溯，分支界限法</h1><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_37995835/article/details/117667634">五大类常见算法 （递归与分治，动态规划，贪心，回溯，分支界限法）</a></p>
<h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><h2 id="NC78-反转链表"><a href="#NC78-反转链表" class="headerlink" title="NC78 反转链表"></a><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/75e878df47f24fdc9dc3e400ec6058ca">NC78 反转链表</a></h2><img src="/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/image-20230315205820587.png" class title="image-20230315205820587">

<h3 id="看不懂递归的看过来，希望能帮到你！"><a href="#看不懂递归的看过来，希望能帮到你！" class="headerlink" title="看不懂递归的看过来，希望能帮到你！"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/fan-zhuan-lian-biao-lcof/solution/kan-bu-dong-di-gui-de-kan-guo-lai-xi-wan-1akq/">看不懂递归的看过来，希望能帮到你！</a></h3><h3 id="【反转链表】：双指针，递归，妖魔化的双指针"><a href="#【反转链表】：双指针，递归，妖魔化的双指针" class="headerlink" title="【反转链表】：双指针，递归，妖魔化的双指针"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/fan-zhuan-lian-biao-lcof/solution/fan-zhuan-lian-biao-yi-dong-de-shuang-zhi-zhen-jia/">【反转链表】：双指针，递归，妖魔化的双指针</a></h3><p>说实话，我的第一思路就是妖魔化的双指针，绷不住了，结果没写出来。</p>
<h4 id="轻松版双指针"><a href="#轻松版双指针" class="headerlink" title="轻松版双指针"></a>轻松版双指针</h4><img src="/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/9ce26a709147ad9ce6152d604efc1cc19a33dc5d467ed2aae5bc68463fdd2888.gif" class title="img">

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode* p=head;</span><br><span class="line">        ListNode* q=head;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="literal">nullptr</span> || head-&gt;next==<span class="literal">nullptr</span>)    <span class="keyword">return</span> head;</span><br><span class="line">        q=head-&gt;next;</span><br><span class="line">        <span class="comment">//1. 轻松版双指针</span></span><br><span class="line">        ListNode* temp=<span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">while</span>(q)</span><br><span class="line">        &#123;</span><br><span class="line">            p-&gt;next=temp;</span><br><span class="line">            temp=p;</span><br><span class="line">            p=q;</span><br><span class="line">            q=q-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        p-&gt;next=temp;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="妖魔化双指针"><a href="#妖魔化双指针" class="headerlink" title="妖魔化双指针"></a>妖魔化双指针</h4><img src="/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/1c8927d9ff605502793d81ab344dbc17e16d6db2d8dd789045f56af432079519.gif" class title="img">

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//说实话，做不出来</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//2.妖魔化双指针</span></span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">NULL</span>) &#123; <span class="keyword">return</span> <span class="literal">NULL</span>; &#125;</span><br><span class="line">        ListNode* cur = head;</span><br><span class="line">        <span class="keyword">while</span> (head-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            ListNode* t = head-&gt;next-&gt;next;</span><br><span class="line">            head-&gt;next-&gt;next = cur;</span><br><span class="line">            cur = head-&gt;next;</span><br><span class="line">            head-&gt;next = t;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;；</span><br></pre></td></tr></table></figure>

<h4 id="简洁的递归"><a href="#简洁的递归" class="headerlink" title="简洁的递归"></a>简洁的递归</h4><img src="/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/8951bc3b8b7eb4da2a46063c1bb96932e7a69910c0a93d973bd8aa5517e59fc8.gif" class title="img">

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//3.递归</span></span><br><span class="line">        <span class="keyword">if</span>(head==<span class="literal">nullptr</span> || head-&gt;next==<span class="literal">nullptr</span>)    <span class="keyword">return</span> head;</span><br><span class="line">        ListNode* ret = <span class="built_in">reverseList</span>(head-&gt;next);</span><br><span class="line">        head-&gt;next-&gt;next = head;</span><br><span class="line">        head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;；</span><br></pre></td></tr></table></figure>



























<h1 id="搜索与回溯算法-二叉树相关"><a href="#搜索与回溯算法-二叉树相关" class="headerlink" title="搜索与回溯算法 二叉树相关"></a>搜索与回溯算法 二叉树相关</h1><p>剑指Offer题目</p>
<h3 id="32-从上到下打印出二叉树的每个节点，同一层的节点按照从左到右的顺序打印。"><a href="#32-从上到下打印出二叉树的每个节点，同一层的节点按照从左到右的顺序打印。" class="headerlink" title="32.从上到下打印出二叉树的每个节点，同一层的节点按照从左到右的顺序打印。"></a>32.从上到下打印出二叉树的每个节点，同一层的节点按照从左到右的顺序打印。</h3><img src="/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/image-20230310110433552.png" class title="image-20230310110433552">

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">levelOrder</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//二叉树的层序遍历</span></span><br><span class="line">        <span class="comment">//利用队列先进先出的特性</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        queue&lt;TreeNode*&gt; q;</span><br><span class="line">        q.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            TreeNode* node =q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            ans.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">            <span class="keyword">if</span>(node-&gt;left) q.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">            <span class="keyword">if</span>(node-&gt;right) q.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="32-从上到下按层打印二叉树，同一层的节点按从左到右的顺序打印，每一层打印到一行。"><a href="#32-从上到下按层打印二叉树，同一层的节点按从左到右的顺序打印，每一层打印到一行。" class="headerlink" title="32.从上到下按层打印二叉树，同一层的节点按从左到右的顺序打印，每一层打印到一行。"></a>32.从上到下按层打印二叉树，同一层的节点按从左到右的顺序打印，每一层打印到一行。</h3><img src="/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/image-20230310110545093.png" class title="image-20230310110545093">

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">levelOrder</span>(TreeNode* root) &#123;</span><br><span class="line">                </span><br><span class="line">        <span class="comment">/* 根据函数返回值定义存储结果的变量 */</span></span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; result;</span><br><span class="line">        <span class="comment">/* 定义一个队列用于存储节点的数据 */</span></span><br><span class="line">        queue&lt;TreeNode*&gt; que;</span><br><span class="line">        <span class="comment">/* 判空 */</span></span><br><span class="line">        <span class="keyword">if</span>(root != <span class="literal">NULL</span>) que.<span class="built_in">push</span>(root);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 开始层序遍历 */</span></span><br><span class="line">        <span class="keyword">while</span>(!que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="comment">/* 计算队列的大小也即有多少个孩子 */</span></span><br><span class="line">            <span class="keyword">int</span> size = que.<span class="built_in">size</span>();</span><br><span class="line">            <span class="comment">/* 定义一个临时vector 存储每一层 */</span></span><br><span class="line">            vector&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line">            <span class="comment">/* 层序遍历 */</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                <span class="comment">/* 获取第一个节点数据 */</span></span><br><span class="line">                TreeNode* node = que.<span class="built_in">front</span>();</span><br><span class="line">                que.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">                vec.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">                <span class="keyword">if</span>(node-&gt;left != <span class="literal">NULL</span>) que.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">                <span class="keyword">if</span>(node-&gt;right != <span class="literal">NULL</span>) que.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/* 将一层的数据保存 */</span></span><br><span class="line">            result.<span class="built_in">push_back</span>(vec);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="32-请实现一个函数按照之字形顺序打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右到左的顺序打印，第三行再按照从左到右的顺序打印，其他行以此类推。"><a href="#32-请实现一个函数按照之字形顺序打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右到左的顺序打印，第三行再按照从左到右的顺序打印，其他行以此类推。" class="headerlink" title="32.请实现一个函数按照之字形顺序打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右到左的顺序打印，第三行再按照从左到右的顺序打印，其他行以此类推。"></a>32.请实现一个函数按照之字形顺序打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右到左的顺序打印，第三行再按照从左到右的顺序打印，其他行以此类推。</h3><img src="/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/image-20230310110623326.png" class title="image-20230310110623326">

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">levelOrder</span>(TreeNode* root) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;res;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>) <span class="keyword">return</span> res;</span><br><span class="line">       </span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> flag=<span class="number">-1</span>;</span><br><span class="line">        queue&lt;TreeNode*&gt;q;</span><br><span class="line">        q.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="keyword">int</span> q_size=q.<span class="built_in">size</span>();</span><br><span class="line">            res.<span class="built_in">push_back</span>(vector&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">            flag=-flag;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;q_size;i++)&#123;</span><br><span class="line">                <span class="keyword">auto</span> s=q.<span class="built_in">front</span>();</span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line">                res.<span class="built_in">back</span>().<span class="built_in">push_back</span>(s-&gt;val);</span><br><span class="line">                <span class="keyword">if</span>(s-&gt;left)&#123;q.<span class="built_in">push</span>(s-&gt;left);&#125;</span><br><span class="line">                <span class="keyword">if</span>(s-&gt;right)&#123;q.<span class="built_in">push</span>(s-&gt;right);&#125;</span><br><span class="line">            &#125;</span><br><span class="line">                <span class="keyword">if</span>(flag==<span class="number">-1</span>)&#123;<span class="built_in">reverse</span>(res.<span class="built_in">back</span>().<span class="built_in">begin</span>(),res.<span class="built_in">back</span>().<span class="built_in">end</span>());&#125;<span class="comment">//翻转输出</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<h3 id="33-输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历结果。如果是则返回-true，否则返回-false。假设输入的数组的任意两个数字都互不相同。"><a href="#33-输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历结果。如果是则返回-true，否则返回-false。假设输入的数组的任意两个数字都互不相同。" class="headerlink" title="33.输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历结果。如果是则返回 true，否则返回 false。假设输入的数组的任意两个数字都互不相同。"></a>33.输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历结果。如果是则返回 <code>true</code>，否则返回 <code>false</code>。假设输入的数组的任意两个数字都互不相同。</h3><img src="/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/image-20230310110703417.png" class title="image-20230310110703417">

<h4 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h4><p><strong>二叉搜索树（BST）</strong>的定义是：对于任意一个节点，它的左子树的所有节点的值都小于该节点的值，而它的右子树的所有节点的值都大于该节点的值。</p>
<p>二叉搜索树的后序遍历序列中，最后一个数字是树的根节点的值，而前面的数字可以分为两部分：</p>
<ol>
<li><strong>第一部分是左子树节点的值，它们都小于根节点的值；</strong></li>
<li><strong>第二部分是右子树节点的值，它们都大于根节点的值。</strong></li>
</ol>
<p>我们可以根据这个特点，递归地判断每个子树是否符合二叉搜索树的定义。</p>
<h4 id="具体地，我们可以首先找到根节点的位置，然后分别递归判断左子树和右子树是否为二叉搜索树。"><a href="#具体地，我们可以首先找到根节点的位置，然后分别递归判断左子树和右子树是否为二叉搜索树。" class="headerlink" title="具体地，我们可以首先找到根节点的位置，然后分别递归判断左子树和右子树是否为二叉搜索树。"></a>具体地，我们可以首先找到根节点的位置，然后分别递归判断左子树和右子树是否为二叉搜索树。</h4><p>​    递归的过程中，需要注意以下几点：</p>
<ol>
<li>对于左子树和右子树，需要分别处理前半部分和后半部分的数组；</li>
<li>对于空子树，直接返回 true；</li>
<li>对于只有一个节点的子树，也认为它是二叉搜索树。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">verifyPostorder</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; sequence)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(sequence.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">int</span> n = sequence.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> root = sequence[n - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; n - <span class="number">1</span> &amp;&amp; sequence[i] &lt; root) &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> j = i;</span><br><span class="line">        <span class="keyword">while</span> (j &lt; n - <span class="number">1</span> &amp;&amp; sequence[j] &gt; root) &#123;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (j != n - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">left</span><span class="params">(sequence.begin(), sequence.begin() + i)</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">right</span><span class="params">(sequence.begin() + i, sequence.end() - <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">return</span> (left.<span class="built_in">empty</span>() || <span class="built_in">verifyPostorder</span>(left)) &amp;&amp; (right.<span class="built_in">empty</span>() || <span class="built_in">verifyPostorder</span>(right));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>









<h1 id="搜索与回溯算法-树相关"><a href="#搜索与回溯算法-树相关" class="headerlink" title="搜索与回溯算法 树相关"></a>搜索与回溯算法 树相关</h1><h3 id="26-输入两棵二叉树A和B，判断B是不是A的子结构。-约定空树不是任意一个树的子结构"><a href="#26-输入两棵二叉树A和B，判断B是不是A的子结构。-约定空树不是任意一个树的子结构" class="headerlink" title="26.输入两棵二叉树A和B，判断B是不是A的子结构。(约定空树不是任意一个树的子结构)"></a>26.输入两棵二叉树A和B，判断B是不是A的子结构。(约定空树不是任意一个树的子结构)</h3><p>B是A的子结构， 即 A中有出现和B相同的结构和节点值。</p>
<img src="/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/image-20230310111801195.png" class title="image-20230310111801195">

<p>​    刚开始的思路就是对俩颗树进行先序遍历，若A遍历结果包含了B，则输出true</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">Cclass Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">     <span class="function"><span class="keyword">bool</span> <span class="title">isSubStructure</span><span class="params">(TreeNode* A, TreeNode* B)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//可以改写为判断 二者的先序遍历中有无相同部分</span></span><br><span class="line">        string a1=<span class="built_in">XianXu</span>(A);</span><br><span class="line">        string a2=<span class="built_in">XianXu</span>(B);</span><br><span class="line">        <span class="keyword">if</span>(a2==<span class="string">&quot;&quot;</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> a1.<span class="built_in">find</span>(a2);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">string <span class="title">XianXu</span><span class="params">(TreeNode* node)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        string ans;</span><br><span class="line">        <span class="keyword">if</span>(node==<span class="literal">NULL</span>) <span class="keyword">return</span> ans;</span><br><span class="line">        </span><br><span class="line">        TreeNode* temp=node;</span><br><span class="line">        ans+=(temp-&gt;val);</span><br><span class="line">        queue&lt;TreeNode*&gt; q;</span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            q.<span class="built_in">push</span>(temp);</span><br><span class="line">            <span class="keyword">if</span>(temp-&gt;left) &#123;q.<span class="built_in">push</span>(temp-&gt;left);</span><br><span class="line">                ans+=(temp-&gt;left-&gt;val);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(temp-&gt;right) &#123;q.<span class="built_in">push</span>(temp-&gt;right);ans+=(temp-&gt;left-&gt;val);&#125;</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            temp=q.<span class="built_in">front</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但很明显，用string返回，一旦出现负数或俩位数，就寄！wssb</p>
<p>直到我看见下面这种，哈哈哈</p>
<h5 id="大家整体逻辑一致，都是："><a href="#大家整体逻辑一致，都是：" class="headerlink" title="大家整体逻辑一致，都是："></a>大家整体逻辑一致，都是：</h5><p>如果AB相等就去判断AB是否为同一棵树，如果为真就返回真，如果为假，<br>就先让B和A的左子树进行对比，如果为真就返回真，如果为假，<br>再让B和A的右子树进行对比，如果为真就返回真，如果为假，那就返回。</p>
<h5 id="子函数iscontain用来判断是否被包含，逻辑也很简单：如果AB节点相等就去判断各子树，如果不想等直接返回假。"><a href="#子函数iscontain用来判断是否被包含，逻辑也很简单：如果AB节点相等就去判断各子树，如果不想等直接返回假。" class="headerlink" title="子函数iscontain用来判断是否被包含，逻辑也很简单：如果AB节点相等就去判断各子树，如果不想等直接返回假。"></a>子函数iscontain用来判断是否被包含，逻辑也很简单：如果AB节点相等就去判断各子树，如果不想等直接返回假。</h5><p>个人认为其中的一个小点也是要点是前两个if判断。</p>
<p>因为我们认为B是A的子结构，递归判断过程中</p>
<p>如果B为空说明已经判断完毕，可以返回真了，<br>如果B没完A却完了说明，不是子结构直接返回假。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">//输入两棵二叉树，判断B是不是A的子结构</span></span><br><span class="line">        <span class="comment">//思路：DFS，即先序遍历，然后判断A的每个节点都作为根节点是否可以跟B相匹配</span></span><br><span class="line">        <span class="comment">//匹配成功则返回true，匹配到空节点都还未成功则返回false</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//树A是否是树B的子结构</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSubStructure</span><span class="params">(TreeNode* A, TreeNode* B)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(B == <span class="literal">NULL</span> || A == <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//遍历A中的每一个节点，若是包含B则返回true</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">isContain</span>(A, B) || <span class="built_in">isSubStructure</span>(A-&gt;left, B) || <span class="built_in">isSubStructure</span>(A-&gt;right, B);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//以A为根节点的树是否包含B</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isContain</span><span class="params">(TreeNode* A, TreeNode* B)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(B == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(A == <span class="literal">NULL</span> || A-&gt;val != B-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">isContain</span>(A-&gt;left, B-&gt;left) &amp;&amp; <span class="built_in">isContain</span>(A-&gt;right, B-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<h3 id="27-请完成一个函数，输入一个二叉树，该函数输出它的镜像。"><a href="#27-请完成一个函数，输入一个二叉树，该函数输出它的镜像。" class="headerlink" title="27.请完成一个函数，输入一个二叉树，该函数输出它的镜像。"></a>27.请完成一个函数，输入一个二叉树，该函数输出它的镜像。</h3><img src="/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/image-20230310124214167.png" class title="image-20230310124214167">

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">mirrorTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>) <span class="keyword">return</span> root;</span><br><span class="line">        <span class="keyword">bool</span> leftEmpty=<span class="literal">false</span>, rightEmpty=<span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left ==<span class="literal">NULL</span>)   leftEmpty=<span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right ==<span class="literal">NULL</span>)   rightEmpty=<span class="literal">true</span>;</span><br><span class="line">        TreeNode* temp;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(leftEmpty&amp;&amp; rightEmpty)&#123; <span class="comment">//若左右子皆空，则直接返回</span></span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(leftEmpty &amp;&amp; !rightEmpty)  <span class="comment">//若左子空，右子不空</span></span><br><span class="line">        &#123;</span><br><span class="line">            root-&gt;left=root-&gt;right;</span><br><span class="line">            root-&gt;right=<span class="literal">NULL</span>;</span><br><span class="line">            <span class="built_in">mirrorTree</span>(root-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(!leftEmpty &amp;&amp; rightEmpty)  <span class="comment">//若左子不空，右子空</span></span><br><span class="line">        &#123;</span><br><span class="line">            root-&gt;right=root-&gt;left;</span><br><span class="line">            root-&gt;left=<span class="literal">NULL</span>;</span><br><span class="line">            <span class="built_in">mirrorTree</span>(root-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            temp=root-&gt;left;</span><br><span class="line">            root-&gt;left=root-&gt;right;</span><br><span class="line">            root-&gt;right=temp;</span><br><span class="line">            <span class="built_in">mirrorTree</span>(root-&gt;left);</span><br><span class="line">            <span class="built_in">mirrorTree</span>(root-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<img src="/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/image-20230310130259308.png" class title="image-20230310130259308">

<p>太简单了没意思</p>
<h3 id="28-请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。"><a href="#28-请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。" class="headerlink" title="28.请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。"></a>28.请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。</h3><img src="/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/image-20230310130539704.png" class title="image-20230310130539704">

<p>​    第一思路：可知对称的二叉树，其中序遍历应该也是对称的。所以我想去把其中序遍历输出出来。太复杂PASS，以下指针思路必须学习！！</p>
<img src="/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/image-20230310131649500.png" class title="image-20230310131649500">

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">isTrue</span>(root -&gt; left, root -&gt; right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isTrue</span><span class="params">(TreeNode* A, TreeNode* B)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(A == <span class="literal">nullptr</span> &amp;&amp; B == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(A == <span class="literal">nullptr</span> || B == <span class="literal">nullptr</span> || A -&gt; val != B -&gt; val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">isTrue</span>(A -&gt; left, B -&gt; right) &amp;&amp; <span class="built_in">isTrue</span>(A -&gt; right, B -&gt; left);       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<h1 id="动态规划Dynamic-programming-DP"><a href="#动态规划Dynamic-programming-DP" class="headerlink" title="动态规划Dynamic programming(DP)"></a>动态规划Dynamic programming(DP)</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><img src="/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/image-20230310133610109.png" class title="image-20230310133610109">

<h3 id="什么样的问题可以使用动态规划"><a href="#什么样的问题可以使用动态规划" class="headerlink" title="什么样的问题可以使用动态规划"></a>什么样的问题可以使用动态规划</h3><p>​    如果一个问题，可以把所有可能的答案穷举出来，并且穷举出来后，发现存在**<a target="_blank" rel="noopener" href="https://blog.csdn.net/vangoudan/article/details/106577901">重叠子问题</a>**，就可以考虑使用动态规划。</p>
<h3 id="动态规划的解题思路"><a href="#动态规划的解题思路" class="headerlink" title="动态规划的解题思路"></a>动态规划的解题思路</h3><p>​    动态规划的重点在于定义状态和状态转移方程</p>
<p>​    动态规划的核心思想就是<strong>拆分子问题，记住过往，减少重复计算。</strong> 并且动态规划一般都是自底向上的，因此到这里，基于<strong>青蛙跳阶</strong>问题，<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/365698607">我总结了一下我做动态规划的思路</a>：</p>
<ul>
<li><h4 id="1-穷举分析"><a href="#1-穷举分析" class="headerlink" title="1. 穷举分析"></a><strong>1. 穷举分析</strong></h4><ul>
<li>当台阶数是1的时候，有一种跳法，f（1） =1</li>
<li>当只有2级台阶时，有两种跳法，第一种是直接跳两级，第二种是先跳一级，然后再跳一级。即f(2) = 2;</li>
<li>当台阶是3级时，想跳到第3级台阶，要么是先跳到第2级，然后再跳1级台阶上去，要么是先跳到第 1级，然后一次迈 2 级台阶上去。所以f(3) = f(2) + f(1) =3</li>
</ul>
</li>
<li><h4 id="2-确定边界"><a href="#2-确定边界" class="headerlink" title="2. 确定边界"></a>2. 确定边界</h4><ul>
<li>通过穷举分析，我们发现，当台阶数是1的时候或者2的时候，可以明确知道青蛙跳法。f（1） =1，f(2) = 2，当台阶n&gt;=3时，已经呈现出规律f(3) = f(2) + f(1) =3，因此f（1） =1，f(2) = 2就是青蛙跳阶的边界。</li>
</ul>
</li>
<li><h4 id="3-找规律，确定最优子结构"><a href="#3-找规律，确定最优子结构" class="headerlink" title="3. 找规律，确定最优子结构"></a>3. 找规律，确定最优子结构</h4><ul>
<li>n&gt;=3时，已经呈现出规律 f(n) = f(n-1) + f(n-2) ，因此，f(n-1)和f(n-2) 称为 f(n) 的最优子结构。什么是最优子结构？有这么一个解释：</li>
</ul>
<blockquote>
<p>★ 一道动态规划问题，其实就是一个递推问题。假设当前决策结果是f(n),则最优子结构就是要让 f(n-k) 最优,最优子结构性质就是能让转移到n的状态是最优的,并且与后面的决策没有关系,即让后面的决策安心地使用前面的局部最优解的一种性质</p>
</blockquote>
</li>
<li><h4 id="4-写出状态转移方程"><a href="#4-写出状态转移方程" class="headerlink" title="4.写出状态转移方程"></a>4.写出状态转移方程</h4><ul>
<li>通过前面3步，穷举分析，确定边界，最优子结构，我们就可以得出状态转移方程啦：</li>
</ul>
<img src="/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/v2-17700257363921acdbd5718beaed8266_720w.webp" class title="img"></li>
<li><h4 id="5-代码实现"><a href="#5-代码实现" class="headerlink" title="5. 代码实现"></a>5. 代码实现</h4><ul>
<li>动态规划实现框架</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">dp[<span class="number">0</span>][<span class="number">0</span>][...] = 边界值</span><br><span class="line"><span class="keyword">for</span>(状态<span class="number">1</span> ：所有状态<span class="number">1</span>的值)&#123;</span><br><span class="line">    <span class="keyword">for</span>(状态<span class="number">2</span> ：所有状态<span class="number">2</span>的值)&#123;</span><br><span class="line">        <span class="keyword">for</span>(...)&#123;</span><br><span class="line">          <span class="comment">//状态转移方程</span></span><br><span class="line">          dp[状态<span class="number">1</span>][状态<span class="number">2</span>][...] = 求最值</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/u010365819/article/details/121000532">https://blog.csdn.net/u010365819/article/details/121000532</a></p>
<h3 id="通俗的动态规划解题步骤"><a href="#通俗的动态规划解题步骤" class="headerlink" title="通俗的动态规划解题步骤"></a>通俗的动态规划解题步骤</h3><img src="/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/image-20230311135947556.png" class title="image-20230311135947556"></li>
</ul>
<h4 id="构造dp数组"><a href="#构造dp数组" class="headerlink" title="构造dp数组"></a>构造dp数组</h4><p>​    构造<code>dp</code>数组，这是动规问题最基本的求解思路。和上述基于字符串类型的动规问题一样，基于数组类型的动规问题同样可以根据题目来决定：是要构造一维的<code>dp</code>数组、还是二维的<code>dp</code>数组？</p>
<h4 id="直观上的状态转移"><a href="#直观上的状态转移" class="headerlink" title="直观上的状态转移"></a>直观上的状态转移</h4><p>​    有些题目可以直接直观的由题目得出有哪几种状态转移方式，这类题目的状态一般是有限个的、且相互之间可以进行转化。典型例题则是 leetcode 中的股票买卖问题。</p>
<h4 id="找规律"><a href="#找规律" class="headerlink" title="找规律"></a>找规律</h4><h4 id="总的来说，拿到一道题目后，我们可以按照下面的步骤进行分析、尝试："><a href="#总的来说，拿到一道题目后，我们可以按照下面的步骤进行分析、尝试：" class="headerlink" title="总的来说，拿到一道题目后，我们可以按照下面的步骤进行分析、尝试："></a>总的来说，拿到一道题目后，我们可以按照下面的步骤进行分析、尝试：</h4><p>​    该问题能否拆分为小问题，是否可以构造dp数组来解决，dp数组中的每一个元素的含义是什么（很重要，不同的定义方式直接影响解决问题的难易程度，甚至有的定义方式根本无法解决问题）<br>​    定义完dp数组后，画图分析，这是得到状态转移方程很重要的一步！有的状态转移不是很直观，但是我们可以通过画图分析，找到规律。</p>
<h2 id="斐波那契（Fibonacci）"><a href="#斐波那契（Fibonacci）" class="headerlink" title="斐波那契（Fibonacci）"></a>斐波那契（Fibonacci）</h2><p>写一个函数，输入 <code>n</code> ，求斐波那契（Fibonacci）数列的第 <code>n</code> 项（即 <code>F(N)</code>）。斐波那契数列的定义如下：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">F</span>(<span class="number">0</span>) = <span class="number">0</span>,   F(<span class="number">1</span>) = <span class="number">1</span></span><br><span class="line"><span class="attribute">F</span>(N) = F(N - <span class="number">1</span>) + F(N - <span class="number">2</span>), 其中 N &gt; <span class="number">1</span>.</span><br></pre></td></tr></table></figure>

<p>斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。</p>
<p>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</p>
<img src="/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/image-20230310132214593.png" class title="image-20230310132214593">

<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/fei-bo-na-qi-shu-lie-lcof/solution/mian-shi-ti-10-i-fei-bo-na-qi-shu-lie-dong-tai-gui/">斐波那契数列 动态规划题解</a></p>
<h3 id="很明显，用递归直接超时，还得是动态规划！"><a href="#很明显，用递归直接超时，还得是动态规划！" class="headerlink" title="很明显，用递归直接超时，还得是动态规划！"></a>很明显，用递归直接超时，还得是动态规划！</h3><img src="/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/image-20230310134237927.png" class title="image-20230310134237927">

<img src="/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/image-20230310134247523.png" class title="image-20230310134247523">

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a=<span class="number">0</span>, b=<span class="number">1</span>,sum=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 当n&gt;1时才会进入循环，所以for循环算的是n从2到n+1的值</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>; i&lt;=n+<span class="number">1</span>; i++)&#123;</span><br><span class="line">            sum=(a+b) % <span class="number">1000000007</span>;        </span><br><span class="line">            a=b;</span><br><span class="line">            b=sum;  </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 由于多算一次，所以返回的是a，不是b</span></span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="或者用记忆化搜索-降低复杂度"><a href="#或者用记忆化搜索-降低复杂度" class="headerlink" title="或者用记忆化搜索 降低复杂度"></a>或者用记忆化搜索 降低复杂度</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1000000007</span>;</span><br><span class="line">    <span class="keyword">int</span> dp[<span class="number">101</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(dp[n]) <span class="keyword">return</span> dp[n];</span><br><span class="line">        <span class="keyword">if</span>(n &lt; <span class="number">2</span>) <span class="keyword">return</span> n;</span><br><span class="line">        dp[n] = (<span class="built_in">fib</span>(n<span class="number">-1</span>)+<span class="built_in">fib</span>(n<span class="number">-2</span>)) % mod;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>结果也不错。</p>
<h2 id="青蛙跳台阶"><a href="#青蛙跳台阶" class="headerlink" title="青蛙跳台阶"></a>青蛙跳台阶</h2><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 <code>n</code> 级的台阶总共有多少种跳法。</p>
<p> 其实也是斐波那契数列的问题，看<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/climbing-stairs/solution/yuan-lai-hui-pa-lou-ti-de-zheng-que-zi-s-pjez/">这个链接！</a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> dp[<span class="number">101</span>]=&#123;<span class="number">0</span>&#125;; </span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1000000007</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numWays</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//很不明显，可以将爬上n级台阶的问题，分成【先跳1步，然后爬n-1级楼梯】与【先跳2步，然后爬n-2级楼梯】之和</span></span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">1</span> || n==<span class="number">2</span>)<span class="keyword">return</span> n;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(dp[n]) <span class="keyword">return</span> dp[n];</span><br><span class="line">        dp[n] = (<span class="built_in">numWays</span>(n<span class="number">-1</span>)+<span class="built_in">numWays</span>(n<span class="number">-2</span>)) % mod;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/95525781">一只青蛙跳出来的分治法、回溯法与动态规划</a></p>
<h3 id="动态规划有几个典型特征，最优子结构、状态转移方程、边界、重叠子问题。在青蛙跳阶问题中："><a href="#动态规划有几个典型特征，最优子结构、状态转移方程、边界、重叠子问题。在青蛙跳阶问题中：" class="headerlink" title="动态规划有几个典型特征，最优子结构、状态转移方程、边界、重叠子问题。在青蛙跳阶问题中："></a>动态规划有几个典型特征，<strong>最优子结构、状态转移方程、边界、重叠子问题</strong>。在青蛙跳阶问题中：</h3><ul>
<li><p>f(n-1)和f(n-2) 称为 f(n) 的最优子结构</p>
</li>
<li><p>f(n)= f（n-1）+f（n-2）就称为状态转移方程</p>
</li>
<li><p>f(1) = 1, f(2) = 2 就是边界啦</p>
</li>
<li><p>比如f(10)= f(9)+f(8),f(9) = f(8) + f(7) ,f(8)就是重叠子问题。</p>
<h3 id="最优子结构"><a href="#最优子结构" class="headerlink" title="最优子结构"></a>最优子结构</h3><p>​    如果一个问题的最优解包含了其中子问题的最优解，那么称其具有最优子结构的性质。</p>
<p>​    什么意思？青蛙在面对 n 台阶时的解决方案数是 f(n)，那么我们知道 f(n) = f(n-1) + f(n-2)。其中的 f(n-1) 与 f(n-2) 就是两个子问题的最优解，此时我们可以理解成一个问题的最优解包含了其子问题的最优解，那么这个时候这种问题具有了最优子结构性质。</p>
<h3 id="重叠子问题"><a href="#重叠子问题" class="headerlink" title="重叠子问题"></a>重叠子问题</h3><p>​    这个性质，在我理解是对于上文提到的子问题的补充说明。当解决一个问题时，往往需要依赖于其更小规模的子问题的解，甚至是同时依赖于若干个规模更小的子问题的解，即子问题是被（重复）包含于比其更大的问题中的，所以他是具有重叠子问题的性质。</p>
</li>
</ul>
<h2 id="股票的最大利润"><a href="#股票的最大利润" class="headerlink" title="股票的最大利润"></a>股票的最大利润</h2><p>假设把某股票的价格按照时间先后顺序存储在数组中，请问买卖该股票一次可能获得的最大利润是多少？</p>
<img src="/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/image-20230310141619639.png" class title="image-20230310141619639">

<img src="/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/image-20230310142321486.png" class title="image-20230310142321486">

<img src="/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/image-20230310142419564.png" class title="image-20230310142419564">

<img src="/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/image-20230310142505665.png" class title="image-20230310142505665">

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(prices.<span class="built_in">size</span>()==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> minValue = prices[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (prices[i] &lt; minValue) &#123;</span><br><span class="line">                minValue = prices[i];   <span class="comment">//有更低的价格，则以后的价格可以基于这个更低的价格去算</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            res = <span class="built_in">max</span>(res, prices[i] - minValue);<span class="comment">//但是也要和之前的res比较以下</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>







<h2 id="连续子数组的最大和"><a href="#连续子数组的最大和" class="headerlink" title="连续子数组的最大和"></a>连续子数组的最大和</h2><img src="/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/image-20230310150347481.png" class title="image-20230310150347481">

<img src="/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/image-20230310150402602.png" class title="image-20230310150402602">

<p>​    我觉得关键就在于，对于每一个数是否加入数列，或者自己新开一个数列，就取决与该数本身与其之前连续子数列和大小的比较。</p>
<p>​    我开始还纠结，如果i前面的子数列和为2，然后i为-1，然后i+1为4，那要如何才能不断地组合。后来我发现，并不用组合，后面的4不就是最大的吗。嗯，所以我的思路没想到上面去，那要如何避免产生这种错误的思路呢？1是以后可以大胆假设，小心求证；2是多看多做题。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">         <span class="comment">//我们[]第n位数字为尾巴的最大值]就是其[前n-1位数字的最大值加上它本身]与[其自身]相比较，谁大就是谁，如果一样那就继续;</span></span><br><span class="line">         <span class="comment">//如果该数字加上去比原来更小，那就重开一段计算咯</span></span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>()==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> max1 = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> max_final=max1;    <span class="comment">//当前最优解，因为可能后面那段比前面好，所以要比较；</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            max1=<span class="built_in">max</span>(max1+nums[i],nums[i]);</span><br><span class="line">            max_final=<span class="built_in">max</span>(max1,max_final);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max_final;</span><br><span class="line">                   <span class="comment">//关于动态规划的思想可以看首页Krahets的讲解。这里给出C++的简单实现。</span></span><br><span class="line">                    <span class="comment">//算法精髓在于每个子数组必须要考虑最后一个数，但是最终结果只要最优解</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h4><img src="/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/image-20230310155856278.png" class title="image-20230310155856278">





<h4 id="思路二"><a href="#思路二" class="headerlink" title="思路二"></a>思路二</h4><img src="/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/image-20230310160043917.png" class title="image-20230310160043917">



<h4 id="关于回溯法与DP"><a href="#关于回溯法与DP" class="headerlink" title="关于回溯法与DP"></a>关于回溯法与DP</h4><blockquote>
<p>​    教一个秘诀吧，关于什么时候用dp。首先你要了解回溯法，毕竟是dp的起源，在你熟悉回溯之后，你发现这道题它好像可以用回溯去做，或者发现你想遍历它来给出答案，但是答案要求的并不是把所有满足的解法都列出来，而是只需要给出一共有几种解法，这时候一般就考虑dp。比如这道题，求的是所有子数组的和，关键它不是让你求所有子数组，并不需要把子数组一个一个去完整拿出，所以你一个一个遍历的方法肯定要超时，只能是dp。</p>
</blockquote>
<p>作者：zhywanna<br>链接：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof/solution/by-zhywanna-7gcq">https://leetcode.cn/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof/solution/by-zhywanna-7gcq</a></p>
<h2 id="礼物的最大价值"><a href="#礼物的最大价值" class="headerlink" title="礼物的最大价值"></a>礼物的最大价值</h2><p>​    在一个 m*n 的棋盘的每一格都放有一个礼物，每个礼物都有一定的价值（价值大于 0）。你可以从棋盘的左上角开始拿格子里的礼物，并每次向右或者向下移动一格、直到到达棋盘的右下角。给定一个棋盘及其上面的礼物的价值，请计算你最多能拿到多少价值的礼物？<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/li-wu-de-zui-da-jie-zhi-lcof/solution/mian-shi-ti-47-li-wu-de-zui-da-jie-zhi-dong-tai-gu/">动态规划解答</a></p>
<img src="/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/image-20230311130018890.png" class title="image-20230311130018890">

<h3 id="递归（回溯法）方法"><a href="#递归（回溯法）方法" class="headerlink" title="递归（回溯法）方法"></a>递归（回溯法）方法</h3><p>​    由题意得，一个格子只能由其上方或者左方的格子移动得到，所以<strong>该格子的最大值Max(i,j)即为max(Max(i-1.j),Max(i,j-1))</strong>,于是思路一就是开始递归并记录每个格子的最大值。后来发现，其实我们不用记录最大值，只要我们不断循环直到计算出最右下角的值即可。但是很明显，这样会超时。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; &amp;grid, <span class="keyword">int</span> row, <span class="keyword">int</span> col)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (row &lt; <span class="number">0</span> || row &gt;= grid.<span class="built_in">size</span>() || col &lt; <span class="number">0</span> || col &gt;= grid[<span class="number">0</span>].<span class="built_in">size</span>()) </span><br><span class="line">            <span class="keyword">return</span> INT_MIN;</span><br><span class="line">        <span class="keyword">if</span> (row == grid.<span class="built_in">size</span>() - <span class="number">1</span> &amp;&amp; col == grid[<span class="number">0</span>].<span class="built_in">size</span>() - <span class="number">1</span>)    <span class="comment">// 到达右下角之后，直接返回它的礼物价值即可</span></span><br><span class="line">            <span class="keyword">return</span> grid[row][col];</span><br><span class="line">        <span class="keyword">int</span> right = <span class="built_in">dfs</span>(grid, row, col + <span class="number">1</span>);        <span class="comment">// 向右移动一格</span></span><br><span class="line">        <span class="keyword">int</span> down = <span class="built_in">dfs</span>(grid, row + <span class="number">1</span>, col);         <span class="comment">// 向左移动一格</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(right, down) + grid[row][col];       <span class="comment">// 不管怎么移动都要加上自身的礼物价值</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxValue</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(grid, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<img src="/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/image-20230311133455387.png" class title="image-20230311133455387">

<h3 id="记忆化搜索（回溯法）（即记录之前的值）"><a href="#记忆化搜索（回溯法）（即记录之前的值）" class="headerlink" title="记忆化搜索（回溯法）（即记录之前的值）"></a>记忆化搜索（回溯法）（即记录之前的值）</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; &amp;grid, <span class="keyword">int</span> row, <span class="keyword">int</span> col, vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; &amp;cache)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (row &lt; <span class="number">0</span> || row &gt;= grid.<span class="built_in">size</span>() || col &lt; <span class="number">0</span> || col &gt;= grid[<span class="number">0</span>].<span class="built_in">size</span>()) </span><br><span class="line">            <span class="keyword">return</span> INT_MIN;</span><br><span class="line">        <span class="keyword">if</span> (row == grid.<span class="built_in">size</span>() - <span class="number">1</span> &amp;&amp; col == grid[<span class="number">0</span>].<span class="built_in">size</span>() - <span class="number">1</span>) </span><br><span class="line">            <span class="keyword">return</span> grid[row][col];</span><br><span class="line">        <span class="keyword">if</span> (cache[row][col] != <span class="number">-1</span>) <span class="keyword">return</span> cache[row][col];      <span class="comment">// 当前状态被计算过了，直接使用答案</span></span><br><span class="line">        <span class="keyword">int</span> right = <span class="built_in">dfs</span>(grid, row, col + <span class="number">1</span>, cache);</span><br><span class="line">        <span class="keyword">int</span> down = <span class="built_in">dfs</span>(grid, row + <span class="number">1</span>, col, cache);</span><br><span class="line">        cache[row][col] = <span class="built_in">max</span>(right, down) + grid[row][col];    <span class="comment">// 当前状态没有被计算过，就把计算结果保存到 cache 中</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(right, down) + grid[row][col];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxValue</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建二维数组 cache，初始化 -1，表示每个位置都没被计算</span></span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">cache</span>(grid.<span class="built_in">size</span>(), vector&lt;<span class="keyword">int</span>&gt;(grid[<span class="number">0</span>].<span class="built_in">size</span>(), <span class="number">-1</span>));</span><br><span class="line">        <span class="comment">//初始化时要赋值</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(grid, <span class="number">0</span>, <span class="number">0</span>, cache);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<img src="/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/image-20230311134340534-1678513421403-1.png" class title="image-20230311134340534">

<h3 id="动态规划方法"><a href="#动态规划方法" class="headerlink" title="动态规划方法"></a>动态规划方法</h3><p>​                                                                                                <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/li-wu-de-zui-da-jie-zhi-lcof/solution/mian-shi-ti-47-li-wu-de-zui-da-jie-zhi-dong-tai-gu/">动态规划解答</a></p>
<img src="/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/image-20230311134432069.png" class title="image-20230311134432069">

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxValue</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rowSize = grid.<span class="built_in">size</span>(), colSize = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> dp[rowSize + <span class="number">1</span>][colSize + <span class="number">1</span>];       <span class="comment">// 数组长度开大一个，这样可以根据 dfs 的递归出口初始化 dp 数组</span></span><br><span class="line">        dp[rowSize - <span class="number">1</span>][colSize - <span class="number">1</span>] = grid[rowSize - <span class="number">1</span>][colSize - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; colSize; i++) dp[rowSize][i] = INT_MIN;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rowSize; i++) dp[i][colSize] = INT_MIN;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> row = rowSize - <span class="number">1</span>; row &gt;= <span class="number">0</span>; row--) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> col = colSize - <span class="number">1</span>; col &gt;= <span class="number">0</span>; col--) &#123;</span><br><span class="line">                <span class="keyword">if</span> (row == rowSize - <span class="number">1</span> &amp;&amp; col == colSize - <span class="number">1</span>) <span class="keyword">continue</span>;     <span class="comment">// 右下角已被初始化，所以直接跳过</span></span><br><span class="line">                dp[row][col] = <span class="built_in">max</span>(dp[row + <span class="number">1</span>][col], dp[row][col + <span class="number">1</span>]) + grid[row][col];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxValue</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>,j=<span class="number">1</span>; j &lt; grid[<span class="number">0</span>].<span class="built_in">size</span>(); j++)	<span class="comment">//处理第一行</span></span><br><span class="line">        &#123;</span><br><span class="line">            grid[i][j] += grid[i][j - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>,j=<span class="number">0</span>; i &lt; grid.<span class="built_in">size</span>(); i++)		<span class="comment">//处理第一列</span></span><br><span class="line">        &#123;</span><br><span class="line">            grid[i][j] += grid[i<span class="number">-1</span>][j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; grid.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; grid[<span class="number">0</span>].<span class="built_in">size</span>(); j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i - <span class="number">1</span>][j] &gt;= grid[i][j - <span class="number">1</span>])	grid[i][j] += grid[i - <span class="number">1</span>][j];</span><br><span class="line">                <span class="keyword">else</span> grid[i][j] += grid[i][j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> grid[grid.<span class="built_in">size</span>()<span class="number">-1</span>][grid[<span class="number">0</span>].<span class="built_in">size</span>()<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>







<h2 id="数字翻译成字符串"><a href="#数字翻译成字符串" class="headerlink" title="数字翻译成字符串"></a>数字翻译成字符串</h2><img src="/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/image-20230311140828931.png" class title="image-20230311140828931">

<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/ba-shu-zi-fan-yi-cheng-zi-fu-chuan-lcof/">题目链接</a></p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/ba-shu-zi-fan-yi-cheng-zi-fu-chuan-lcof/solution/by-zhywanna-tkwb/">我是如何5分钟做出这道DP并且Beats100%的</a></p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1K341117Pm">剑指 Offer 46. 把数字翻译成字符串</a></p>
<h3 id="主要思路"><a href="#主要思路" class="headerlink" title="主要思路"></a>主要思路</h3><p>​    对于俩个数字，如果它们介于00-25之间，则对于他们来说，有俩种不同的翻译，即为俩个数字分别进行翻译+俩个数字合起来翻译。否则，他们只有一种翻译，即为俩个数字分别进行翻译。</p>
<p>​    我们用dp[i]表示这段数字前i位可以解码的总数。</p>
<img src="/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/image-20230311143745545.png" class title="image-20230311143745545">

<p>​    </p>
<img src="/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/image-20230311144142877.png" class title="image-20230311144142877">

<img src="/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/image-20230311144218175.png" class title="image-20230311144218175">

<img src="/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/image-20230311144640021.png" class title="image-20230311144640021">

<h3 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">translateNum</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        string str = <span class="built_in">to_string</span>(num);</span><br><span class="line">        <span class="keyword">int</span> len = str.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(len &lt; <span class="number">2</span>) <span class="keyword">return</span> len;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(len+<span class="number">1</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= len;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(str[i<span class="number">-2</span>] == <span class="string">&#x27;1&#x27;</span> || (str[i<span class="number">-2</span>] == <span class="string">&#x27;2&#x27;</span> &amp;&amp; str[i<span class="number">-1</span>] &lt;= <span class="string">&#x27;5&#x27;</span>)) dp[i] = dp[i<span class="number">-2</span>]+dp[i<span class="number">-1</span>];</span><br><span class="line">            <span class="keyword">else</span> dp[i] = dp[i<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[len];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>







<h2 id="⭐-最长不含重复字符的子字符串"><a href="#⭐-最长不含重复字符的子字符串" class="headerlink" title="⭐ 最长不含重复字符的子字符串"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/zui-chang-bu-han-zhong-fu-zi-fu-de-zi-zi-fu-chuan-lcof/">⭐ 最长不含重复字符的子字符串</a></h2><p>请从字符串中找出一个最长的不包含重复字符的子字符串，计算该最长子字符串的长度。</p>
<img src="/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/image-20230311145643385.png" alt="image-20230311145643385" style="zoom: 67%;">

<h3 id="刚开始思路"><a href="#刚开始思路" class="headerlink" title="刚开始思路"></a>刚开始思路</h3><p>​    首先注意只需要输出其最长不重复的长度即可，所以用一个maxFinal去表示。可以用dp[i]表示对于以第i个字母为结尾的字符串来说，其不重复的字符串最长是多少。dp[0]为1，再之后每一个dp[i]，都去判断其字母与之前长度为dp[i]的字符串有没有重复：若有，则dp[i]=1；若无，则dp[i]=dp[i-1]+1。所以现在的问题就到了如何快速进行某字符与字符串的一一比较。想到C++有一个string.find(string2)功能，好的，试一试。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len=s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(len&lt;<span class="number">2</span>)<span class="keyword">return</span> len;</span><br><span class="line">        <span class="keyword">int</span> dp[len];</span><br><span class="line">        <span class="keyword">int</span> maxFinal=<span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;len;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s.<span class="built_in">substr</span>(i-dp[i<span class="number">-1</span>],dp[i<span class="number">-1</span>]).<span class="built_in">find</span>(s.<span class="built_in">substr</span>(i,<span class="number">1</span>))== string::npos)</span><br><span class="line">            &#123; </span><br><span class="line">                dp[i]=dp[i<span class="number">-1</span>]+<span class="number">1</span>;</span><br><span class="line">                maxFinal=<span class="built_in">max</span>(maxFinal,dp[i]);  </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">               dp[i]=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxFinal;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<img src="/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/image-20230311151330683.png" class title="image-20230311151330683">

<p>​    很明显，我的思路有一个大漏洞，即上图中，dp[1]=2，那么dp[2]就会惯性思维去比较，然后设为dp[2]=1，但其实它应该是2，于是我们开始了循环遍历，但不用做就知道肯定会超时。</p>
<h3 id="罢，看官方题解"><a href="#罢，看官方题解" class="headerlink" title="罢，看官方题解"></a>罢，<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/zui-chang-bu-han-zhong-fu-zi-fu-de-zi-zi-fu-chuan-lcof/solution/zui-chang-bu-han-zhong-fu-zi-fu-de-zi-zi-l4yo/">看官方题解</a></h3><p>​    <img src="/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/image-20230311152006923.png" class title="image-20230311152006923"></p>
<p>hah很简单为什么我没想到？</p>
<img src="/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/image-20230311152054563.png" class title="image-20230311152054563">

<img src="/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/image-20230311152124613.png" class title="image-20230311152124613">

<h3 id="双指针具体实现"><a href="#双指针具体实现" class="headerlink" title="双指针具体实现"></a>双指针具体实现</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/zui-chang-bu-han-zhong-fu-zi-fu-de-zi-zi-fu-chuan-lcof/solution/cshi-xian-shi-yong-shuang-zhi-zhen-ji-ba-ywep/">C++实现，使用双指针，击败100%</a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>; </span><br><span class="line">        <span class="keyword">int</span> a[<span class="number">100010</span>] = &#123;<span class="number">0</span>&#125;;  <span class="comment">//用来保存每个字符出现的次数，初始化为0</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i ++)&#123;</span><br><span class="line">            a[s[i]]++;	<span class="comment">//我只能说这个太离谱了</span></span><br><span class="line">            <span class="keyword">while</span>(j &lt; i &amp;&amp; a[s[i]] &gt; <span class="number">1</span>)&#123;</span><br><span class="line">                a[s[j]]--;</span><br><span class="line">                j ++;</span><br><span class="line">            &#125;</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, i - j + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//总体思路和官方解答几乎差不多，很喜欢我只能说，原来这题不是用动态规划，我太套路了/</span></span><br></pre></td></tr></table></figure>

<h3 id="动态规划具体实现"><a href="#动态规划具体实现" class="headerlink" title="动态规划具体实现"></a>动态规划具体实现</h3><p>可以看见具体解法需要哈希表记录一下</p>
<img src="/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/image-20230311153002478.png" class title="image-20230311153002478">

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len=s.<span class="built_in">length</span>();</span><br><span class="line">    <span class="keyword">if</span>(len&lt;<span class="number">2</span>)   <span class="keyword">return</span> len;</span><br><span class="line"></span><br><span class="line">	unordered_map&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; position;</span><br><span class="line">	<span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(len, <span class="number">0</span>)</span></span>;</span><br><span class="line">	<span class="keyword">int</span> res = <span class="number">0</span>, count = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123; </span><br><span class="line">		<span class="keyword">if</span> (i != <span class="number">0</span> &amp;&amp; position.<span class="built_in">find</span>(s[i]) == position.<span class="built_in">end</span>()) &#123;<span class="comment">//当前字符首次出现</span></span><br><span class="line">			dp[i] = dp[i - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">			dp[i] = <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;	<span class="comment">//如果当前字符和哈希表记录的发生重复，计算当前字符位置与前面重复的字符位置的距离i - j</span></span><br><span class="line">			<span class="keyword">int</span> j = position[s[i]];</span><br><span class="line">			<span class="keyword">if</span> (i - j &lt;= dp[i - <span class="number">1</span>]) &#123;	<span class="comment">//即前面重复的那个字符包含在当前最长非重复子串里面了</span></span><br><span class="line">				dp[i] = i - j;		<span class="comment">//我们当前新的最长非重复子串长度应该为i - j</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;	<span class="comment">//即前面重复的那个字符已经不在当前最长非重复子串里面了</span></span><br><span class="line">				dp[i] = dp[i - <span class="number">1</span>] + <span class="number">1</span>;	<span class="comment">//我们直接将当前长度在前面的基础上加一即可</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		position[s[i]] = i;</span><br><span class="line">        res = <span class="built_in">max</span>(res, dp[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="因为每次dp结果只与上一次dp的结果有关，将上述代码优化空间复杂度得到"><a href="#因为每次dp结果只与上一次dp的结果有关，将上述代码优化空间复杂度得到" class="headerlink" title="因为每次dp结果只与上一次dp的结果有关，将上述代码优化空间复杂度得到"></a>因为每次dp结果只与上一次dp的结果有关，将上述代码优化空间复杂度得到</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>, tmp = <span class="number">0</span>;</span><br><span class="line">        unordered_map&lt;<span class="keyword">char</span> ,<span class="keyword">int</span>&gt; hash;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">length</span>(); i++)&#123;   </span><br><span class="line">            <span class="keyword">int</span> j = <span class="number">0</span>;    </span><br><span class="line">            <span class="keyword">if</span>(hash.<span class="built_in">count</span>(s[i]) != <span class="number">0</span>)</span><br><span class="line">                j = hash[s[i]];</span><br><span class="line">            <span class="keyword">else</span> j = <span class="number">-1</span>;   </span><br><span class="line">            hash[s[i]] = i;</span><br><span class="line">            tmp = tmp &lt; i - j ? tmp + <span class="number">1</span> : i - j;</span><br><span class="line">            </span><br><span class="line">            res = <span class="built_in">max</span>(res, tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<h2 id="⭐面试题-字母与数字"><a href="#⭐面试题-字母与数字" class="headerlink" title="⭐面试题 字母与数字"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-longest-subarray-lcci/">⭐面试题 字母与数字</a></h2><p>​    给定一个放有字母和数字的数组，找到最长的子数组，且包含的字母和数字的个数相同。</p>
<p>​    返回该子数组，若存在多个最长子数组，返回左端点下标值最小的子数组。若不存在这样的数组，返回一个空数组。</p>
<img src="/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/image-20230311162128491.png" class title="image-20230311162128491">

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一眼顶真 动态规划（或者双指针）</span></span><br><span class="line"><span class="comment">//我们可以先将string数组改成int数组，字母转为1，数字转为-1</span></span><br><span class="line"><span class="comment">//定义俩个指针i j ,i指针指向左侧，从0开始，j指针则从左侧开始往右走，若......然后发现问题很大，并不能用上题思路。卡壳，看题解找思路</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>为了在转换后的数组中寻找元素和为0的子数组，可以计算转换后的数组的前缀和，如果两个下标对应的前缀和相等，则这两个下标之间的子数组的元素和为0。</p>
</blockquote>
<p>​    哦，有一点思路了。但是还是遍历的思路。我可以设置一个二维数组，第一个下标表示左边的i在哪里，第二个下标表示右边的j在哪里，然后该二维数组的值，记录这一段ij之间的+1 -1之和。然后再找出所有值为0的，计算j-i的最大值即可……很显然，必超时。</p>
<blockquote>
<p>​    关键就是如何求出来目标值为0的最长子数组长度呢？首先我们可以想到一个O(n^2)的办法，也就是首先求出前缀和sum[i],sum[i]表示的是0<del>i的数组的元素和为多少。那么sum[i] - sum[j]表示的就是从j+1</del>i位置所有的元素的和。两层遍历就可以求出最长的子数组了。</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/Cooperia/article/details/118861303">算法笔记（五）：前缀和</a></p>
<blockquote>
<p>​    有没有更好的办法呢？实际上是有的，最终的算法复杂度是O(n)。假设我们考虑sum[i]的情况如下：</p>
<p>​    +1， +2，+3， +2， +2，+3，+2，+1， 0， -1，-2，-1, 0，+1，+2，+3，+2…</p>
<p>​    我们看加粗的+3，表示在这个位置sum[2] == sum[5] == sum[15] == +3. 假设我们遍历到第二个+3的位置也就是index = 5索引位置，这个时候，如果我们知道最左边索引2位置也有一个3，那么我们可以清楚地得知 从索引2后一位 到 索引5 的和是0. 我们在看索引15的sum[15] == 3, 当遍历到这一位的时候，我们如果知道最左边索引2的位置也有一个3，那么我们也可以清楚地得知送索引2后一位到索引15的和是0.</p>
<p>​    所以说，知道每一个前缀和在最左边第一次出现的位置是至关重要的，因为后面每当出现同样的前缀和，两次的索引相减+1之后得到的，就可能是目前已知的区间线段和为0的最长索引，而这两次相同前缀和之间和他们相同的前缀和的索引是多少，我们并不关心，就像我们现在有最左边的前缀和为3的索引是2，目前找到前缀和为3的索引是15，那么我们就不会关心中间前缀和为3的索引5了，因为无论如何他都不可能最长。</p>
<p>​    所以我们要建立一个结构去存储最左边第一次出现前缀和为sum[i]时候的索引。每次出现相同前缀和，我们就判断一下是不是可能为最长的。同时注意特殊情况，因为当前缀和为0的时候，假设sum[i]为0，那么一定有一种默认情况出现，也就是从0~i这些位置的和也是0，最长的子区间有可能是【0，i】.</p>
<p>作者：Wzing<br>链接：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-longest-subarray-lcci/solution/tong-guo-ji-lu-qian-zhui-he-di-yi-ci-chu-xian-wei-/">https://leetcode.cn/problems/find-longest-subarray-lcci/solution/tong-guo-ji-lu-qian-zhui-he-di-yi-ci-chu-xian-wei-/</a></p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//按照佬的思路加了一些注释</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function">vector&lt;string&gt; <span class="title">findLongestSubarray</span><span class="params">(vector&lt;string&gt;&amp; array)</span> </span>&#123;</span><br><span class="line">		 vector&lt;<span class="keyword">int</span>&gt; nums;</span><br><span class="line">         <span class="keyword">int</span> n = array.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;        <span class="comment">//转化为1与-1</span></span><br><span class="line">            nums.<span class="built_in">push_back</span>(array[i][<span class="number">0</span>] &lt;= <span class="string">&#x27;9&#x27;</span>? <span class="number">1</span>: <span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//sum[i]表示从0到i的前缀和</span></span><br><span class="line">		vector&lt;<span class="keyword">int</span>&gt; sum;</span><br><span class="line">		sum.<span class="built_in">push_back</span>(nums[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">int</span> sumTemp = nums[<span class="number">0</span>];  </span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">			sumTemp += nums[i];</span><br><span class="line">			sum.<span class="built_in">push_back</span>(sumTemp);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">int</span> start = <span class="number">-1</span>; <span class="comment">//用于记录那一段的开头和结尾，方便输出</span></span><br><span class="line">		<span class="keyword">int</span> end = <span class="number">-1</span>;</span><br><span class="line">		<span class="keyword">int</span> maxLength = <span class="number">0</span>;</span><br><span class="line">		unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; mp;             <span class="comment">//mp[k] = index表示出现和为k的最左边索引为index</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sum.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">			<span class="keyword">if</span> (mp.<span class="built_in">find</span>(sum[i]) != mp.<span class="built_in">end</span>())<span class="comment">//最左边出现过，即已经记录过了，按照思想就直接加就行了</span></span><br><span class="line">            &#123;   </span><br><span class="line">				<span class="keyword">if</span> (sum[i] == <span class="number">0</span>)</span><br><span class="line">                &#123;   <span class="comment">//和为0的情况特殊，因为当某一个index为i的时候，最长的子线段长度一定是0~i，也就是长度为i+1</span></span><br><span class="line">					<span class="keyword">if</span> (i + <span class="number">1</span> &gt; maxLength)</span><br><span class="line">                    &#123;</span><br><span class="line">						maxLength = i + <span class="number">1</span>;</span><br><span class="line">						start = <span class="number">0</span>;</span><br><span class="line">						end = i;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span>&#123;   <span class="comment">//否则就是普通的有前缀和，则直接相减即可</span></span><br><span class="line">					<span class="keyword">if</span> (i - mp[sum[i]] &gt; maxLength)</span><br><span class="line">                    &#123;</span><br><span class="line">						maxLength = i - mp[sum[i]];</span><br><span class="line">						start = mp[sum[i]] + <span class="number">1</span>;</span><br><span class="line">						end = i;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> </span><br><span class="line">            &#123; </span><br><span class="line">				<span class="comment">//前缀和为sum[i]第一次出现，记录下来</span></span><br><span class="line">				mp.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(sum[i], i));</span><br><span class="line">				<span class="comment">//这里需要注意哪怕是第一次出现0也需要比较，这和前缀和为其他的不一样</span></span><br><span class="line">				<span class="keyword">if</span> (sum[i] == <span class="number">0</span>)&#123;</span><br><span class="line">					<span class="keyword">if</span>(i + <span class="number">1</span> &gt; maxLength)&#123;</span><br><span class="line">						maxLength = i + <span class="number">1</span>;</span><br><span class="line">						start = <span class="number">0</span>;</span><br><span class="line">						end = i;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (start == <span class="number">-1</span>) <span class="keyword">return</span>&#123;&#125;;<span class="comment">//没有找到前缀和为0的</span></span><br><span class="line">		<span class="function">vector&lt;string&gt; <span class="title">ret</span><span class="params">(array.begin() + start, array.begin() + end + <span class="number">1</span>)</span></span>;</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<h1 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h1><h2 id="剑指-Offer-18-删除链表的节点"><a href="#剑指-Offer-18-删除链表的节点" class="headerlink" title="剑指 Offer 18. 删除链表的节点"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/shan-chu-lian-biao-de-jie-dian-lcof/">剑指 Offer 18. 删除链表的节点</a></h2><p>​    给定单向链表的头指针和一个要删除的节点的值，定义一个函数删除该节点。返回删除后的链表的头节点。</p>
<img src="/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/image-20230312160400179.png" alt="image-20230312160400179" style="zoom:67%;">

<p>初始思路就是定义一个t1指针指向开头head，另一个指向head-&gt;next；然后递归下去一个一个寻找。哈哈结果就是超时，我恨。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">deleteNode</span><span class="params">(ListNode* head, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        ListNode* p =head;</span><br><span class="line">        ListNode* q =head-&gt;next;</span><br><span class="line">        <span class="keyword">if</span>(!q) &#123;</span><br><span class="line">            <span class="keyword">if</span>(p-&gt;val == val) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(q)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(q-&gt;val==val)</span><br><span class="line">            &#123;</span><br><span class="line">                ListNode* t3=q-&gt;next;</span><br><span class="line">                <span class="keyword">if</span>(!t3) </span><br><span class="line">                &#123;</span><br><span class="line">                    p-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">                    <span class="keyword">return</span> head;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    p-&gt;next=t3;</span><br><span class="line">                    <span class="keyword">return</span> head;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>后来我发现我总是把问题复杂化，如果刚开始就是双指针不就很简单？</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">deleteNode</span><span class="params">(ListNode* head, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        ListNode* p =head;</span><br><span class="line">        ListNode* q =p-&gt;next;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;val==val) <span class="keyword">return</span> q;</span><br><span class="line">        <span class="keyword">while</span>(q)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(q-&gt;val==val) </span><br><span class="line">            &#123;</span><br><span class="line">                p-&gt;next=q-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            p=q;</span><br><span class="line">            q=q-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="剑指-Offer-22-链表中倒数第k个节点"><a href="#剑指-Offer-22-链表中倒数第k个节点" class="headerlink" title="剑指 Offer 22. 链表中倒数第k个节点"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/">剑指 Offer 22. 链表中倒数第k个节点</a></h2><p>输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点</p>
<img src="/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/image-20230312162453617.png" alt="image-20230312162453617" style="zoom:67%;">

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//很简单，408常见</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">getKthFromEnd</span><span class="params">(ListNode* head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        ListNode* p=head;</span><br><span class="line">        ListNode* q=p;</span><br><span class="line">        <span class="keyword">while</span>(k&gt;<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            q=q-&gt;next;</span><br><span class="line">            k--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(q)</span><br><span class="line">        &#123;</span><br><span class="line">            p=p-&gt;next;</span><br><span class="line">            q=q-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="剑指-Offer-25-合并两个排序的链表"><a href="#剑指-Offer-25-合并两个排序的链表" class="headerlink" title="剑指 Offer 25. 合并两个排序的链表"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/he-bing-liang-ge-pai-xu-de-lian-biao-lcof/">剑指 Offer 25. 合并两个排序的链表</a></h2><p>输入两个递增排序的链表，合并这两个链表并使新链表中的节点仍然是递增排序的。</p>
<img src="/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/image-20230312162837680.png" alt="image-20230312162837680" style="zoom:67%;">

<p> 主要思路就是新增指针pq指向俩条链表的头结点。</p>
<img src="/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/image-20230312165703584.png" class title="image-20230312165703584">

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        ListNode* p=l1;</span><br><span class="line">        ListNode* q=l2;</span><br><span class="line">        ListNode* ans = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">        ListNode* ap=ans;</span><br><span class="line">        <span class="keyword">while</span>(p &amp;&amp; q)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(p-&gt;val&lt;=q-&gt;val)</span><br><span class="line">            &#123;</span><br><span class="line">                ap-&gt;next=p;</span><br><span class="line">                l1=p-&gt;next;</span><br><span class="line">                p=l1;</span><br><span class="line">                ap= ap-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                ap-&gt;next=q;</span><br><span class="line">                l1=q-&gt;next;</span><br><span class="line">                q=l1;</span><br><span class="line">                ap= ap-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(p)ap-&gt;next=p;</span><br><span class="line">        <span class="keyword">else</span> ap-&gt;next=q;</span><br><span class="line">        <span class="keyword">return</span> ans-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<img src="/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/image-20230312165756171.png" class title="image-20230312165756171">

<h2 id="剑指-Offer-52-两个链表的第一个公共节点"><a href="#剑指-Offer-52-两个链表的第一个公共节点" class="headerlink" title="剑指 Offer 52. 两个链表的第一个公共节点"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof/">剑指 Offer 52. 两个链表的第一个公共节点</a></h2><p>输入两个链表，找出它们的第一个公共节点。</p>
<img src="/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/image-20230312170001133.png" alt="image-20230312170001133" style="zoom:80%;">

<img src="/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/image-20230312170011685.png" alt="image-20230312170011685" style="zoom:80%;">

<p>第一思路是直接算出俩链表的长度，然后长减短，得到差值。长的指针直接往后移动差值dif，然后二者一起移动，直到遇到完全相同就可以了。</p>
<p>第二思路就倒着来，很明显俩个链表最后一定是一样的，我们可以从后面开始移动，直到有不同的即可。</p>
<p>不过还是用思路一做出来了。不过这题很蠢的一点是，俩个结点的值val一样，却不是同一结点，如例一，绷不住了，不过还好只不过是改变了判断条件从val==val变到了ListNode==ListNode；</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Getlength</span><span class="params">(ListNode* a)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(a)</span><br><span class="line">        &#123;</span><br><span class="line">            a=a-&gt;next;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a=<span class="built_in">Getlength</span>(headA);</span><br><span class="line">        <span class="keyword">int</span> b=<span class="built_in">Getlength</span>(headB);</span><br><span class="line">        ListNode*p=headA;</span><br><span class="line">        ListNode*q=headB;</span><br><span class="line">        ListNode* ans=<span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span>(a&lt;=b)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> dif=b-a;</span><br><span class="line">            <span class="keyword">while</span>(dif&gt;<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                q=q-&gt;next;</span><br><span class="line">                dif--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> dif=a-b;</span><br><span class="line">            <span class="keyword">while</span>(dif&gt;<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                p=p-&gt;next;</span><br><span class="line">                dif--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">bool</span> isEnd=<span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">while</span>(p &amp;&amp; q)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(p == q &amp;&amp; isEnd==<span class="literal">false</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                ans=p;</span><br><span class="line">                isEnd=<span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(p != q)</span><br><span class="line">            &#123;</span><br><span class="line">                isEnd=<span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            p=p-&gt;next;</span><br><span class="line">            q=q-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(isEnd)<span class="keyword">return</span> ans;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<img src="/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/image-20230312172947289.png" alt="image-20230312172947289">



<h2 id="剑指-Offer-21-调整数组顺序使奇数位于偶数前面"><a href="#剑指-Offer-21-调整数组顺序使奇数位于偶数前面" class="headerlink" title="剑指 Offer 21. 调整数组顺序使奇数位于偶数前面"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/diao-zheng-shu-zu-shun-xu-shi-qi-shu-wei-yu-ou-shu-qian-mian-lcof/">剑指 Offer 21. 调整数组顺序使奇数位于偶数前面</a></h2><p>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有奇数在数组的前半部分，所有偶数在数组的后半部分。</p>
<img src="/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/image-20230312173126674.png" alt="image-20230312173126674" style="zoom:67%;">

<p>刚开始的思路就是双指针，一前一后，疯狂逼近。先前面的p往后挪，如果遇到偶数，则转为后面的q往前挪，直到q移到奇数，然后二者数据交换一下。当然有限制条件，必须时刻p&lt;q。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">exchange</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> p=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> q=nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(p&lt;q)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(;p&lt;q;p++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[p]%<span class="number">2</span>==<span class="number">0</span>)    <span class="comment">//是偶数，需要代换</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(;p&lt;q;q--)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[q]%<span class="number">2</span>==<span class="number">1</span>)    <span class="comment">//是奇数，需要代换</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(p&lt;q)</span><br><span class="line">                <span class="built_in">swap</span>(nums[p],nums[q]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="剑指-Offer-57-和为s的两个数字"><a href="#剑指-Offer-57-和为s的两个数字" class="headerlink" title="剑指 Offer 57. 和为s的两个数字"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/he-wei-sde-liang-ge-shu-zi-lcof/">剑指 Offer 57. 和为s的两个数字</a></h2><p>输入一个递增排序的数组和一个数字s，在数组中查找两个数，使得它们的和正好是s。如果有多对数字的和等于s，则输出任意一对即可。</p>
<img src="/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/image-20230312225116562.png" alt="image-20230312225116562" style="zoom:67%;">

<p>双指针pq，刚开始均位于0，q往后移动，一个个测试，直到得到结果，或者相加大于s；</p>
<p>然后q往左一位，p开始右移，直到相加大于结果；</p>
<p>然后p左移一位….啊这，好像有点难写。</p>
<p>啊我错了，原来思想还是左右双指针夹逼。再写写看咯</p>
<p>ok 内部就不用写while了，直接用外面大循环的while就可以了。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> p=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> q=nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[p]+nums[q]==target) <span class="keyword">return</span> &#123;nums[p],nums[q]&#125;;</span><br><span class="line">        <span class="keyword">while</span>(p&lt;q)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[p]+nums[q]&lt;target)  <span class="comment">//最小+最大比目标小，则最小右移</span></span><br><span class="line">            &#123;</span><br><span class="line">                p++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[p]+nums[q]&gt;target)</span><br><span class="line">            &#123;</span><br><span class="line">                q--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span>&#123;nums[p],nums[q]&#125;;            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="剑指-Offer-58-I-翻转单词顺序"><a href="#剑指-Offer-58-I-翻转单词顺序" class="headerlink" title="剑指 Offer 58 - I. 翻转单词顺序"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/fan-zhuan-dan-ci-shun-xu-lcof/">剑指 Offer 58 - I. 翻转单词顺序</a></h2><p>输入一个英文句子，翻转句子中单词的顺序，但单词内字符的顺序不变。为简单起见，标点符号和普通字母一样处理。例如输入字符串”I am a student. “，则输出”student. a am I”。</p>
<img src="/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/image-20230312232307537.png" alt="image-20230312232307537" style="zoom:67%;">

<p>刚开始的思路：想着遍历检测字母，然后再检测空格，将之间这一段存入vector中。然后倒置vector输出即可。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">reverseWords</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        vector&lt;string&gt; words;</span><br><span class="line">        string ans;</span><br><span class="line">        <span class="keyword">bool</span> isInWord=<span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">int</span> a,b;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">length</span>()<span class="number">-1</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i]&lt;=<span class="string">&#x27;z&#x27;</span> &amp;&amp; s[i]&gt;=<span class="string">&#x27;a&#x27;</span>&amp;&amp; !isInWord) <span class="comment">//首次进入单词</span></span><br><span class="line">            &#123;</span><br><span class="line">                isInWord=!isInWord;</span><br><span class="line">                a=i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(isInWord &amp;&amp; s[i]==<span class="string">&#x27; &#x27;</span>)<span class="comment">//从单词里出去了</span></span><br><span class="line">            &#123;</span><br><span class="line">                isInWord=!isInWord;</span><br><span class="line">                b=i;</span><br><span class="line">                words.<span class="built_in">push_back</span>(s.<span class="built_in">substr</span>(a,b));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=words.<span class="built_in">size</span>();i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">        &#123;</span><br><span class="line">            ans=ans+words[i]+<span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>很棒，超时，思路错误。</p>
<p>看了解答后发现，其实我们从后面开始往前找单词就行了。从刚开始遇到不是’ ‘,再到遇到空白，嗯然后统一输出到res并加一个 “ ”。最后一下弹出即可。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">reverseWords</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        string res;</span><br><span class="line">        <span class="keyword">int</span> j = s.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (j &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; s[j] == <span class="string">&#x27; &#x27;</span>) j--;</span><br><span class="line">            <span class="keyword">if</span> (j == - <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">int</span> i = j;</span><br><span class="line">            <span class="keyword">while</span> (i &gt;= <span class="number">0</span> &amp;&amp; s[i] != <span class="string">&#x27; &#x27;</span>) i--;</span><br><span class="line">            res.<span class="built_in">append</span>(s.<span class="built_in">substr</span>(i + <span class="number">1</span>, j - i));</span><br><span class="line">            res.<span class="built_in">push_back</span>(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">            j = i;</span><br><span class="line">        &#125;</span><br><span class="line">        res.<span class="built_in">pop_back</span>();</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="搜索与回溯算法（中等）"><a href="#搜索与回溯算法（中等）" class="headerlink" title="搜索与回溯算法（中等）"></a>搜索与回溯算法（中等）</h1><h2 id="⭐剑指-Offer-12-矩阵中的路径"><a href="#⭐剑指-Offer-12-矩阵中的路径" class="headerlink" title="⭐剑指 Offer 12. 矩阵中的路径"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/ju-zhen-zhong-de-lu-jing-lcof/">⭐剑指 Offer 12. 矩阵中的路径</a></h2><p>给定一个 <code>m x n</code> 二维字符网格 <code>board</code> 和一个字符串单词 <code>word</code> 。如果 <code>word</code> 存在于网格中，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>
<p>单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用</p>
<img src="/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/image-20230314110235880.png" alt="image-20230314110235880" style="zoom:80%;">

<p>思路就是：遍历遍历，哈哈哈。然后用一个flag数组标记。</p>
<p>这样写挺好的，但是我写不出来循环入口和终止条件，很复杂感觉。看了答案之后恍然大悟，原来我们直接用一个dfs进行上下左右遍历即可，然后用int去记录遍历了多少，如果遍历过了++，直到最后。</p>
<p>代码如下，copy的但是很标准，值得学习</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">exist</span><span class="params">(vector&lt;vector&lt;<span class="keyword">char</span>&gt;&gt;&amp; board, string word)</span> </span>&#123;</span><br><span class="line">        rows = board.<span class="built_in">size</span>();</span><br><span class="line">        cols = board[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cols; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">dfs</span>(board, word, i, j, <span class="number">0</span>)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> rows, cols;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="keyword">char</span>&gt;&gt;&amp; board, string word, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i &gt;= rows || i &lt; <span class="number">0</span> || j &gt;= cols || j &lt; <span class="number">0</span> || board[i][j] != word[k]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(k == word.<span class="built_in">size</span>() - <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        board[i][j] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        <span class="keyword">bool</span> res = <span class="built_in">dfs</span>(board, word, i + <span class="number">1</span>, j, k + <span class="number">1</span>) || <span class="built_in">dfs</span>(board, word, i - <span class="number">1</span>, j, k + <span class="number">1</span>) || </span><br><span class="line">                      <span class="built_in">dfs</span>(board, word, i, j + <span class="number">1</span>, k + <span class="number">1</span>) || <span class="built_in">dfs</span>(board, word, i , j - <span class="number">1</span>, k + <span class="number">1</span>);</span><br><span class="line">        board[i][j] = word[k];</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="⭐面试题13-机器人的运动范围"><a href="#⭐面试题13-机器人的运动范围" class="headerlink" title="⭐面试题13. 机器人的运动范围"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof/">⭐面试题13. 机器人的运动范围</a></h2><p>地上有一个m行n列的方格，从坐标 <code>[0,0]</code> 到坐标 <code>[m-1,n-1]</code> 。一个机器人从坐标 <code>[0, 0] </code>的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于k的格子。例如，当k为18时，机器人能够进入方格 [35, 37] ，因为3+5+3+7=18。但它不能进入方格 [35, 38]，因为3+5+3+8=19。请问该机器人能够到达多少个格子？</p>
<img src="/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/image-20230314140832599.png" alt="image-20230314140832599">

<p>同理，深度优先.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//上下左右，四个方向移动~</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">movingCount</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">visit</span>(m, vector&lt;<span class="keyword">int</span>&gt;(n, <span class="number">0</span>));    <span class="comment">// 二维 vector 动态初始化全零</span></span><br><span class="line">        <span class="keyword">int</span> grids = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">move</span>(visit, <span class="number">0</span>, <span class="number">0</span>, k, grids);</span><br><span class="line">        <span class="keyword">return</span> grids;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">move</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; visit, <span class="keyword">int</span> row, <span class="keyword">int</span> col, <span class="keyword">int</span> k, <span class="keyword">int</span>&amp; grids)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (visit[row][col] == <span class="number">1</span>)   <span class="comment">//已访问过</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">getBitSum</span>(row) + <span class="built_in">getBitSum</span>(col) &gt; k)    <span class="comment">//各位之和大于k</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        </span><br><span class="line">        visit[row][col] = <span class="number">1</span>;    <span class="comment">//标记已访问</span></span><br><span class="line">        grids = grids + <span class="number">1</span>;      </span><br><span class="line">        <span class="keyword">if</span> (row &gt; <span class="number">0</span>)    <span class="comment">//上下左右开始遍历，这个算是深度优先咯</span></span><br><span class="line">            <span class="built_in">move</span>(visit, row - <span class="number">1</span>, col, k, grids);</span><br><span class="line">        <span class="keyword">if</span> (row &lt; visit.<span class="built_in">size</span>() - <span class="number">1</span>)</span><br><span class="line">            <span class="built_in">move</span>(visit, row + <span class="number">1</span>, col, k, grids);</span><br><span class="line">        <span class="keyword">if</span> (col &gt; <span class="number">0</span>)</span><br><span class="line">            <span class="built_in">move</span>(visit, row, col - <span class="number">1</span>, k, grids);</span><br><span class="line">        <span class="keyword">if</span> (col &lt; visit[<span class="number">0</span>].<span class="built_in">size</span>() - <span class="number">1</span>)</span><br><span class="line">            <span class="built_in">move</span>(visit, row, col + <span class="number">1</span>, k, grids);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getBitSum</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;    <span class="comment">//获取一个数字的各位和</span></span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (num &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            sum += num % <span class="number">10</span>;</span><br><span class="line">            num /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="深度遍历-34-二叉树中和为某一值的路径"><a href="#深度遍历-34-二叉树中和为某一值的路径" class="headerlink" title="深度遍历 34. 二叉树中和为某一值的路径"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/er-cha-shu-zhong-he-wei-mou-yi-zhi-de-lu-jing-lcof/">深度遍历 34. 二叉树中和为某一值的路径</a></h2><p>给你二叉树的根节点 <code>root</code> 和一个整数目标和 <code>targetSum</code> ，找出所有 <strong>从根节点到叶子节点</strong> 路径总和等于给定目标和的路径。</p>
<p><strong>叶子节点</strong> 是指没有子节点的节点。</p>
<img src="/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/image-20230314151016772.png" alt="image-20230314151016772" style="zoom:80%;">

<p>这不是纯纯的深度遍历吗。我知道怎么做，但是我居然写不出来！！！！！</p>
<p>烦，一看答案，我去，这vector.push_back用的怎么这么巧妙啊。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt;path;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">traversal</span><span class="params">(TreeNode* root,<span class="keyword">int</span> target,<span class="keyword">int</span> sum)</span></span>&#123;	<span class="comment">//sum其实就是从0开始，能遍历进去再加</span></span><br><span class="line">        path.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">        sum += root-&gt;val;</span><br><span class="line">        <span class="keyword">if</span>( root-&gt;left == <span class="literal">nullptr</span> &amp;&amp; root-&gt;right == <span class="literal">nullptr</span> )</span><br><span class="line">            <span class="keyword">if</span>( sum == target )&#123;</span><br><span class="line">                ans.<span class="built_in">push_back</span>(path);</span><br><span class="line">                <span class="keyword">return</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//else return;</span></span><br><span class="line">        <span class="keyword">if</span>( root-&gt;left )&#123;</span><br><span class="line">            <span class="built_in">traversal</span>(root-&gt;left,target,sum);</span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>( root-&gt;right )&#123;</span><br><span class="line">            <span class="built_in">traversal</span>(root-&gt;right,target,sum);</span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">pathSum</span>(TreeNode* root, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">if</span>( root == <span class="literal">nullptr</span> )   <span class="keyword">return</span> ans;</span><br><span class="line">        <span class="built_in">traversal</span>(root,target,<span class="number">0</span>); </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<h2 id="⭐剑指-Offer-36-二叉搜索树与双向链表"><a href="#⭐剑指-Offer-36-二叉搜索树与双向链表" class="headerlink" title="⭐剑指 Offer 36. 二叉搜索树与双向链表"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof/">⭐剑指 Offer 36. 二叉搜索树与双向链表</a></h2><p>输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的循环双向链表。要求不能创建任何新的节点，只能调整树中节点指针的指向。</p>
<img src="/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/image-20230314152817092.png" class title="image-20230314152817092">

<p>思路：很明显，一眼顶真中序遍历。问题在于如何遍历遍历就连起来了。</p>
<p>将head和pre定义为公共变量，然后就可以在dfs里直接调用了。</p>
<p>进入dfs后就可以先判断pre是否为空，若空，则代表是中序的第一个，则直接令head=当前点。然后当前点的左边指向pre，pre等于当前点。ok就是这个意思。</p>
<p>之后就每次进来，首先pre的右边=当前点，当前点的左边=pre，然后pre等于当前点。</p>
<p>最后遍历完了，别忘了首尾相连。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Node *pre, *head;</span><br><span class="line"></span><br><span class="line">    <span class="function">Node* <span class="title">treeToDoublyList</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>)   <span class="keyword">return</span> root;</span><br><span class="line">        <span class="comment">//中序遍历，然后一个一个连起来就行了。</span></span><br><span class="line">        head=root;</span><br><span class="line">        <span class="built_in">midBianli</span>(root);</span><br><span class="line">        <span class="comment">//最后将首尾相连</span></span><br><span class="line">        head-&gt;left = pre;</span><br><span class="line">        pre-&gt;right = head;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">midBianli</span><span class="params">(Node * cur )</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cur == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">midBianli</span>(cur-&gt;left);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(pre == <span class="literal">nullptr</span>) </span><br><span class="line">            head = cur;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            pre-&gt;right = cur;</span><br><span class="line">            </span><br><span class="line">        cur-&gt;left = pre;</span><br><span class="line">        pre = cur;</span><br><span class="line">        <span class="built_in">midBianli</span>(cur-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="剑指-Offer-54-二叉搜索树的第k大节点"><a href="#剑指-Offer-54-二叉搜索树的第k大节点" class="headerlink" title="剑指 Offer 54. 二叉搜索树的第k大节点"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof/">剑指 Offer 54. 二叉搜索树的第k大节点</a></h2><p>给定一棵二叉搜索树，请找出其中第 <code>k</code> 大的节点的值。</p>
<img src="/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/image-20230314220219943.png" alt="image-20230314220219943" style="zoom:80%;">

<p>不多说，先上代码：注释在代码中，很简单。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line">    <span class="keyword">int</span> ans;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">kthLargest</span><span class="params">(TreeNode* root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//第一思路是是否有简单方法</span></span><br><span class="line">        <span class="comment">//然后实在不行 就遍历。</span></span><br><span class="line">        count=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">InorderTraversal</span>(root,k);   <span class="comment">//第一次遍历，其实只为获取总个数</span></span><br><span class="line">        <span class="keyword">int</span> temp=count;</span><br><span class="line">        count=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">InorderTraversal</span>(root,temp-k+<span class="number">1</span>);<span class="comment">//第二次遍历，找第k大，就是找第总数-k+1小的值，再次中序遍历即可。</span></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">InorderTraversal</span><span class="params">(TreeNode* root,<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>)<span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">InorderTraversal</span>(root-&gt;left, k);</span><br><span class="line"></span><br><span class="line">        count++;</span><br><span class="line">        <span class="keyword">if</span>(count==k)&#123;ans= root-&gt;val;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">InorderTraversal</span>(root-&gt;right, k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<img src="/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/image-20230314222155432.png" class title="image-20230314222155432">





<h2 id="⭐剑指-Offer-55-I-求二叉树的深度"><a href="#⭐剑指-Offer-55-I-求二叉树的深度" class="headerlink" title="⭐剑指 Offer 55 - I.求二叉树的深度"></a>⭐<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/er-cha-shu-de-shen-du-lcof/">剑指 Offer 55 - I.求二叉树的深度</a></h2><p>输入一棵二叉树的根节点，求该树的深度。从根节点到叶节点依次经过的节点（含根、叶节点）形成树的一条路径，最长路径的长度为树的深度。</p>
<img src="/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/image-20230315150429812.png" alt="image-20230315150429812" style="zoom:80%;">

<p>常规的深度遍历</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> max=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//深度遍历咯</span></span><br><span class="line">        <span class="built_in">dfs</span>(root,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode* node,<span class="keyword">int</span> depth)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node==<span class="literal">NULL</span>)<span class="keyword">return</span>;</span><br><span class="line">        depth++;</span><br><span class="line">        <span class="keyword">if</span>(depth&gt;max)max=depth;</span><br><span class="line">        <span class="built_in">dfs</span>(node-&gt;left,depth);</span><br><span class="line">        <span class="built_in">dfs</span>(node-&gt;right,depth);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>看了答案感觉自己是笨蛋….</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(<span class="built_in">maxDepth</span>(root-&gt;left), <span class="built_in">maxDepth</span>(root-&gt;right)) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其实直接遍历就可以好吧我是笨蛋。</p>
<h2 id="⭐剑指-Offer-55-II-判断平衡二叉树"><a href="#⭐剑指-Offer-55-II-判断平衡二叉树" class="headerlink" title="⭐剑指 Offer 55 - II. 判断平衡二叉树"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/ping-heng-er-cha-shu-lcof/">⭐剑指 Offer 55 - II. 判断平衡二叉树</a></h2><p>输入一棵二叉树的根节点，判断该树是不是平衡二叉树。如果某二叉树中任意节点的左右子树的深度相差不超过1，那么它就是一棵平衡二叉树。</p>
<img src="/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/image-20230315151218721.png" alt="image-20230315151218721" style="zoom:67%;">

<p>我居然,,,写不来了//////</p>
<blockquote>
<p>根据定义，一棵二叉树是平衡二叉树，当且仅当其所有子树也都是平衡二叉树，因此可以使用递归的方式判断二叉树是不是平衡二叉树，递归的顺序可以是自顶向下或者自底向上。</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/ping-heng-er-cha-shu-lcof/solution/cji-hu-shuang-bai-de-di-gui-qiu-jie-by-f-o03i/">主要思路：</a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isBalanced</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> dif=<span class="built_in">dfs</span>(root);</span><br><span class="line">        <span class="keyword">if</span>(dif!=<span class="number">-1</span>)<span class="keyword">return</span> <span class="literal">true</span>;	<span class="comment">//-1表示下面有不平衡子树，否则返回的应该是这个树的深度！！</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> left = <span class="built_in">dfs</span>(root-&gt;left);</span><br><span class="line">        <span class="keyword">if</span> (left == <span class="number">-1</span>)<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> right = <span class="built_in">dfs</span>(root-&gt;right);</span><br><span class="line">        <span class="keyword">if</span> (right == <span class="number">-1</span>)<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">abs</span>(left-right) &gt; <span class="number">1</span> ? <span class="number">-1</span> : <span class="built_in">max</span>(left, right) + <span class="number">1</span>;<span class="comment">//计算深度，如果深度为-1即表示差值超过1，有子树不是平衡的，则直接寄。否则直接返回深度即可。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="逻辑运算符的短路性质-求1-2-…-n"><a href="#逻辑运算符的短路性质-求1-2-…-n" class="headerlink" title="逻辑运算符的短路性质. 求1+2+…+n"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/qiu-12n-lcof/">逻辑运算符的短路性质. 求1+2+…+n</a></h2><p>求 <code>1+2+...+n</code> ，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。</p>
<p>什么逆天题目？绷不住了，完全没思路，<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/qiu-12n-lcof/solution/qiu-12n-by-leetcode-solution/">直接看题解</a>：</p>
<h3 id="逻辑运算符的短路性质"><a href="#逻辑运算符的短路性质" class="headerlink" title="逻辑运算符的短路性质"></a>逻辑运算符的短路性质</h3><img src="/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/image-20230315155201561.png" class title="image-20230315155201561">

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sumNums</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        (n&gt;<span class="number">0</span>) &amp;&amp; (n += <span class="built_in">sumNums</span>(n<span class="number">-1</span>)); </span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>什么逆天</p>
<h2 id="⭐剑指-Offer-68-I-二叉搜索树的最近公共祖先"><a href="#⭐剑指-Offer-68-I-二叉搜索树的最近公共祖先" class="headerlink" title="⭐剑指 Offer 68 - I. 二叉搜索树的最近公共祖先"></a>⭐<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/er-cha-sou-suo-shu-de-zui-jin-gong-gong-zu-xian-lcof/">剑指 Offer 68 - I. 二叉搜索树的最近公共祖先</a></h2><p>给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。</p>
<img src="/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/image-20230315155852457.png" class title="image-20230315155852457">

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//遍历咯，判断自己的子树有无值（包括自己）</span></span><br><span class="line">        <span class="comment">//尤其注意题目中是二叉搜索树，即满足大小为左中右</span></span><br><span class="line">        <span class="comment">//很明显我们可以递归到俩个结点都在某结点的左右俩边，此时该某节点即为返回值</span></span><br><span class="line">        <span class="keyword">if</span> (p-&gt;val&lt;root-&gt;val &amp;&amp; q-&gt;val&lt;root-&gt;val) <span class="comment">//如果俩个值都比root小，则代表俩个都在左边，root必不是最小祖先</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">lowestCommonAncestor</span>(root-&gt;left,p,q);</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;val&gt;root-&gt;val &amp;&amp; q-&gt;val&gt;root-&gt;val) <span class="comment">//如果俩个值都比root大，则代表俩个都在右边，root必不是最小祖先</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">lowestCommonAncestor</span>(root-&gt;right,p,q);   </span><br><span class="line">        <span class="keyword">return</span> root;    <span class="comment">//俩个一左一右即可！！！！</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>如代码！！！！！！</p>
<h2 id="⭐⭐剑指-Offer-68-II-二叉树的最近公共祖先"><a href="#⭐⭐剑指-Offer-68-II-二叉树的最近公共祖先" class="headerlink" title="⭐⭐剑指 Offer 68 - II. 二叉树的最近公共祖先"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/er-cha-shu-de-zui-jin-gong-gong-zu-xian-lcof/">⭐⭐剑指 Offer 68 - II. 二叉树的最近公共祖先</a></h2><p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p>
<img src="/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/image-20230315163121407.png" class title="image-20230315163121407">

<p>此题相比上一题，就在于不是左中右的二叉搜索树，而是随意的二叉树，于是上一题的结论失效/</p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1jd4y1B7E2">但是思路还是一样，去判断当pq在俩侧，则该结点是共同祖先</a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">bool</span> bothLeft=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">bool</span> bothRight=<span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span> || root == p || root == q) <span class="keyword">return</span> root;<span class="comment">//如果有p或q就返回咯</span></span><br><span class="line"></span><br><span class="line">        TreeNode *left = <span class="built_in">lowestCommonAncestor</span>(root-&gt;left, p, q);<span class="comment">//这里表示左子树中有p或者q</span></span><br><span class="line">        TreeNode *right = <span class="built_in">lowestCommonAncestor</span>(root-&gt;right, p, q);<span class="comment">//这里表示右子树中出现了p或者q</span></span><br><span class="line">        <span class="comment">// 我尝试解释一下</span></span><br><span class="line">        <span class="comment">// 主函数的作用时在以root为父节点的树中，寻找p和q的位置。</span></span><br><span class="line">        <span class="comment">// 如果root本身不是p或者q，那么就要去子树寻找。</span></span><br><span class="line">        <span class="comment">// 这就开启了递归。 那递归返回什么呢，当然是在左右子树寻找p和q的结果。</span></span><br><span class="line">        <span class="comment">// 如果只有p在左子树，那么返回什么最能说明问题，当然直接是把p网上押送，方便递归的上层能够找到p。相当于层层传话，告诉p在这呢，诉p在这呢，p在这呢，在这呢，这呢，呢，最后送到递归的起点。</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(left == <span class="literal">nullptr</span> &amp;&amp; right == <span class="literal">nullptr</span>) </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>; <span class="comment">// 1.分别在左右都没有，则当前必没有</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(left == <span class="literal">nullptr</span>) </span><br><span class="line">            <span class="keyword">return</span> right; <span class="comment">// 3.左边是空，则都在右边，返回右。即让这个结点向上返回，变成上一个结点的左右子树了</span></span><br><span class="line">        <span class="keyword">if</span>(right == <span class="literal">nullptr</span>) </span><br><span class="line">            <span class="keyword">return</span> left; <span class="comment">// 4.右边都空，都在左边，返回左</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root; <span class="comment">// 2. if(left != null and right != null) 即正确的公共祖先已找到！</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>自己试一下就能理解递归了。但是我还是写不出来啊好烦。只能硬记了/</p>
<h1 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h1><h2 id="⭐面试题45-把数组排成最小的数"><a href="#⭐面试题45-把数组排成最小的数" class="headerlink" title="⭐面试题45. 把数组排成最小的数"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/ba-shu-zu-pai-cheng-zui-xiao-de-shu-lcof/">⭐面试题45. 把数组排成最小的数</a></h2><p>输入一个非负整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。</p>
<img src="/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/image-20230314222636257.png" class title="image-20230314222636257">

<p>//obviously，首先位数尽可能的短，然后前几位尽可能的小，尤其是第一位。</p>
<p>//可以使用那个数据结构使用过的排序算法。叫基数排序！</p>
<p>//即一个一个排下去。</p>
<p>后来发现不太行，因为基数排序，起码大家的位数都是一样的，这里不知道数字多少位，你连从多少开始砍都不知道。</p>
<p>无语，看解答吧。</p>
<img src="/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/image-20230314223602255.png" class title="image-20230314223602255">

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">minNumber</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), [](<span class="keyword">int</span> n1, <span class="keyword">int</span> n2) &#123;</span><br><span class="line">            string s1 = <span class="built_in">to_string</span>(n1), s2 = <span class="built_in">to_string</span>(n2);	</span><br><span class="line">            <span class="built_in"><span class="keyword">return</span></span> (s1 + s2) &lt; (s2 + s1);	<span class="comment">//还能这样子，我真的，哭死。</span></span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        string ret;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; e : nums) </span><br><span class="line">            ret += <span class="built_in">to_string</span>(e);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>说实话，难写</p>
<h2 id="面试题61-扑克牌中的顺子"><a href="#面试题61-扑克牌中的顺子" class="headerlink" title="面试题61. 扑克牌中的顺子"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/bu-ke-pai-zhong-de-shun-zi-lcof/">面试题61. 扑克牌中的顺子</a></h2><p>从<strong>若干副扑克牌</strong>中随机抽 <code>5</code> 张牌，判断是不是一个顺子，即这5张牌是不是连续的。2～10为数字本身，A为1，J为11，Q为12，K为13，而大、小王为 0 ，可以看成任意数字。A 不能视为 14。</p>
<img src="/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/image-20230314224229457.png" alt="image-20230314224229457" style="zoom:50%;">

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//还以为很简单，其实也不简单</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isStraight</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>( nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>() );</span><br><span class="line">        <span class="keyword">int</span> empty=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>()<span class="number">-1</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]==<span class="number">0</span>) <span class="comment">//计算0的个数</span></span><br><span class="line">                empty++; </span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[i]==nums[i+<span class="number">1</span>]) <span class="comment">//有相同必不可能是顺子</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;   </span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[i+<span class="number">1</span>]-nums[i]<span class="number">-1</span>&lt;=empty)     <span class="comment">//如果差值已经用0补不上去就寄</span></span><br><span class="line">                empty-=nums[i+<span class="number">1</span>]<span class="number">-1</span>-nums[i];</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="⭐快排实现-最小的k个数"><a href="#⭐快排实现-最小的k个数" class="headerlink" title="⭐快排实现. 最小的k个数"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/zui-xiao-de-kge-shu-lcof/">⭐快排实现. 最小的k个数</a></h2><p>输入整数数组 <code>arr</code> ，找出其中最小的 <code>k</code> 个数。例如，输入4、5、1、6、2、7、3、8这8个数字，则最小的4个数字是1、2、3、4。</p>
<img src="/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/image-20230314233851767.png" alt="image-20230314233851767" style="zoom:80%;">

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//主要体现在快排代码</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//vector&lt;int&gt; getLeastNumbers(vector&lt;int&gt;&amp; arr, int k) &#123;</span></span><br><span class="line">        <span class="comment">// sort(arr.begin(),arr.end());</span></span><br><span class="line">        <span class="comment">// vector&lt;int&gt; v2(arr.begin(),arr.begin()+k);</span></span><br><span class="line">        <span class="comment">// return v2;</span></span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">getLeastNumbers</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">quickSort</span>(arr, <span class="number">0</span>, arr.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        res.<span class="built_in">assign</span>(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">begin</span>() + k);   </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 子数组长度为 1 时终止递归</span></span><br><span class="line">        <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// 哨兵划分操作（以 arr[l] 作为基准数）</span></span><br><span class="line">        <span class="keyword">int</span> i = l, j = r;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">            <span class="keyword">while</span> (i &lt; j &amp;&amp; arr[j] &gt;= arr[l]) j--;</span><br><span class="line">            <span class="keyword">while</span> (i &lt; j &amp;&amp; arr[i] &lt;= arr[l]) i++;</span><br><span class="line">            <span class="built_in">swap</span>(arr[i], arr[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">swap</span>(arr[i], arr[l]);</span><br><span class="line">        <span class="comment">// 递归左（右）子数组执行哨兵划分</span></span><br><span class="line">        <span class="built_in">quickSort</span>(arr, l, i - <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">quickSort</span>(arr, i + <span class="number">1</span>, r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>408时期经常写的，模拟一下就懂了，默认拿第一个当pivot</p>
<h2 id="剑指-Offer-41-数据流中的中位数"><a href="#剑指-Offer-41-数据流中的中位数" class="headerlink" title="剑指 Offer 41. 数据流中的中位数"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/shu-ju-liu-zhong-de-zhong-wei-shu-lcof/">剑指 Offer 41. 数据流中的中位数</a></h2><p>如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。<img src="/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/image-20230315141505487.png" class title="image-20230315141505487"></p>
<p>困难题？秒杀！</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MedianFinder</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">    <span class="built_in">MedianFinder</span>() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addNum</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        nums.<span class="built_in">push_back</span>(num);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">findMedian</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">int</span> count=nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(count%<span class="number">2</span>==<span class="number">0</span>) <span class="keyword">return</span> ((<span class="keyword">double</span>)nums[count/<span class="number">2</span><span class="number">-1</span>]+(<span class="keyword">double</span>)nums[count/<span class="number">2</span>])/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> nums[count/<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; nums;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>好吧我被秒杀了，这样子做会很明显地超时。实在没思路，遂看解。</p>
<p>回顾本题，其目标即是找到中位数而已，我们可以不顾全大局，而仅仅去找到中位数而已。根据这个思路，我们可以<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/shu-ju-liu-zhong-de-zhong-wei-shu-lcof/solution/dai-tu-xiang-jie-jian-zhi-offer-41-shu-j-y3d6/">建立最大堆和最小堆</a>，堆顶分别为较小一半的最大值和较大一半的最小值</p>
<p>题目要求获取数据流排序后的中位数，而根据数据流的奇偶性以及堆的性质，将获取中位数的情况分为两类：</p>
<ul>
<li><p>数据流为奇数时，保证两个堆的长度相差1，那么长度较大的堆的堆顶就是中位数；</p>
</li>
<li><p>数据流为偶数时，保证两个堆的长度相等，两个堆的堆顶相加除二就是中位数。</p>
<p><strong>最大堆和最小堆的实现，可以用C++中的优先队列实现</strong></p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MedianFinder</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    </span><br><span class="line">    priority_queue &lt;<span class="keyword">int</span>, vector&lt;<span class="keyword">int</span>&gt;, less&lt;<span class="keyword">int</span>&gt;&gt; maxheap; <span class="comment">//按降less序排列，也就是说队头是最大值 min应该存左半边的值</span></span><br><span class="line">    priority_queue &lt;<span class="keyword">int</span>, vector&lt;<span class="keyword">int</span>&gt;, greater&lt;<span class="keyword">int</span>&gt;&gt; minheap;    <span class="comment">//按升序排列，也就是说队头是最小值 min应该存右半边的值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MedianFinder</span>() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addNum</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(maxheap.<span class="built_in">size</span>() == minheap.<span class="built_in">size</span>()) &#123;      <span class="comment">//表示原来是偶数个，将加入的值插到左半边，再将左半边的最大值插到右半边</span></span><br><span class="line">            maxheap.<span class="built_in">push</span>(num);</span><br><span class="line">            minheap.<span class="built_in">push</span>(maxheap.<span class="built_in">top</span>());</span><br><span class="line">            maxheap.<span class="built_in">pop</span>();  <span class="comment">//这样始终保持右半边比左半边大，则每次输出只输出右半边即可。</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;      <span class="comment">//如果不平衡</span></span><br><span class="line">            minheap.<span class="built_in">push</span>(num);</span><br><span class="line">            maxheap.<span class="built_in">push</span>(minheap.<span class="built_in">top</span>());</span><br><span class="line">            minheap.<span class="built_in">pop</span>();  <span class="comment">//维持俩个堆的平衡，因为肯定右边堆比较多，所以从右边选出最小的给左边</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">findMedian</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(maxheap.<span class="built_in">size</span>() == minheap.<span class="built_in">size</span>()) <span class="keyword">return</span> (maxheap.<span class="built_in">top</span>() + minheap.<span class="built_in">top</span>())/(<span class="keyword">double</span>)<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> minheap.<span class="built_in">top</span>();  <span class="comment">//不平衡，则肯定是右边多，而中位数必是右边的最小值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<h1 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h1><h2 id="150-逆波兰表达式求值"><a href="#150-逆波兰表达式求值" class="headerlink" title="150. 逆波兰表达式求值"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/evaluate-reverse-polish-notation/">150. 逆波兰表达式求值</a></h2><p>给你一个字符串数组 <code>tokens</code> ，表示一个根据 <a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E9%80%86%E6%B3%A2%E5%85%B0%E5%BC%8F/128437">逆波兰表示法</a> 表示的算术表达式。</p>
<img src="/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/image-20230315202307896.png" class title="image-20230315202307896">

<img src="/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/image-20230315202313658.png" class title="image-20230315202313658">

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">evalRPN</span><span class="params">(vector&lt;string&gt;&amp; tokens)</span> </span>&#123;</span><br><span class="line">        stack&lt;<span class="keyword">int</span>&gt; S;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;tokens.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(tokens[i]!=<span class="string">&quot;+&quot;</span> &amp;&amp; tokens[i]!=<span class="string">&quot;-&quot;</span>&amp;&amp; tokens[i]!=<span class="string">&quot;*&quot;</span>&amp;&amp; tokens[i]!=<span class="string">&quot;/&quot;</span>)  </span><br><span class="line">                S.<span class="built_in">push</span>(<span class="built_in">stoi</span>(tokens[i]));</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> a1=S.<span class="built_in">top</span>(); S.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">int</span> a2=S.<span class="built_in">top</span>(); S.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span>(tokens[i]==<span class="string">&quot;+&quot;</span>)S.<span class="built_in">push</span>(a1+a2);</span><br><span class="line">                <span class="keyword">if</span>(tokens[i]==<span class="string">&quot;-&quot;</span>)S.<span class="built_in">push</span>(a2-a1);</span><br><span class="line">                <span class="keyword">if</span>(tokens[i]==<span class="string">&quot;*&quot;</span>)S.<span class="built_in">push</span>(a1*a2);</span><br><span class="line">                <span class="keyword">if</span>(tokens[i]==<span class="string">&quot;/&quot;</span>)S.<span class="built_in">push</span>(a2/a1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans =S.<span class="built_in">top</span>();</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="中缀表达式转化后缀表达式"><a href="#中缀表达式转化后缀表达式" class="headerlink" title="中缀表达式转化后缀表达式"></a>中缀表达式转化后缀表达式</h2><h1 id="随机练习"><a href="#随机练习" class="headerlink" title="随机练习"></a>随机练习</h1><h2 id="⭐⭐-给定数字能组成的最大时间"><a href="#⭐⭐-给定数字能组成的最大时间" class="headerlink" title="⭐⭐ 给定数字能组成的最大时间"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/largest-time-for-given-digits/">⭐⭐ 给定数字能组成的最大时间</a></h2><img src="/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/image-20230315221004093.png" class title="image-20230315221004093">

<img src="/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/image-20230315222115601.png" class title="image-20230315222115601">

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//https://leetcode.cn/problems/largest-time-for-given-digits/solution/24-xiao-shi-zhi-de-zui-da-shi-jian-by-gary-7/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution2</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">largestTimeFromDigits</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(A.<span class="built_in">begin</span>(), A.<span class="built_in">end</span>(), greater&lt;<span class="keyword">int</span>&gt;());   <span class="comment">//先按降序排列，需传入第三个参数–比较函数，greater&lt;type&gt;()</span></span><br><span class="line">        vector&lt;string&gt; ans;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>( ((A[<span class="number">0</span>] == <span class="number">2</span> &amp;&amp; A[<span class="number">1</span>] &lt; <span class="number">4</span>) || A[<span class="number">0</span>] &lt; <span class="number">2</span>) &amp;&amp; A[<span class="number">2</span>] &lt; <span class="number">6</span> )     <span class="comment">//即符合时间的形式</span></span><br><span class="line">            &#123;</span><br><span class="line">                string s = <span class="string">&quot;&quot;</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) </span><br><span class="line">                    s += (<span class="string">&#x27;0&#x27;</span>+ A[i]);</span><br><span class="line">                s.<span class="built_in">insert</span>(<span class="number">2</span>, <span class="string">&quot;:&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> s;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">while</span>( <span class="built_in">prev_permutation</span>(A.<span class="built_in">begin</span>(), A.<span class="built_in">end</span>()) );<span class="comment">//全排列的函数，表示还有上一个排列组合</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>可以考虑贪心！！！只要满足格式，默认排下来最大的就是最合适的</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/xenny/p/10192983.html">STL提供了两个用来计算排列组合关系的<strong>算法，分别是next_permutation和prev_permutation。</strong></a></p>
<h4 id="发现，只要在排序时，按照升序排列，即可输出符合规则的最小时间"><a href="#发现，只要在排序时，按照升序排列，即可输出符合规则的最小时间" class="headerlink" title="发现，只要在排序时，按照升序排列，即可输出符合规则的最小时间"></a>发现，只要在排序时，按照升序排列，即可输出符合规则的最小时间</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//https://leetcode.cn/problems/largest-time-for-given-digits/solution/24-xiao-shi-zhi-de-zui-da-shi-jian-by-gary-7/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">largestTimeFromDigits</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(A.<span class="built_in">begin</span>(), A.<span class="built_in">end</span>());   <span class="comment">//按升序排列，即可输出按照规定下的最小值</span></span><br><span class="line">        vector&lt;string&gt; ans;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>( ((A[<span class="number">0</span>] == <span class="number">2</span> &amp;&amp; A[<span class="number">1</span>] &lt; <span class="number">4</span>) || A[<span class="number">0</span>] &lt; <span class="number">2</span>) &amp;&amp; A[<span class="number">2</span>] &lt; <span class="number">6</span> )     <span class="comment">//即符合时间的形式</span></span><br><span class="line">            &#123;</span><br><span class="line">                string s = <span class="string">&quot;&quot;</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) </span><br><span class="line">                    s += (<span class="string">&#x27;0&#x27;</span>+ A[i]);</span><br><span class="line">                s.<span class="built_in">insert</span>(<span class="number">2</span>, <span class="string">&quot;:&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> s;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">while</span>( <span class="built_in">prev_permutation</span>(A.<span class="built_in">begin</span>(), A.<span class="built_in">end</span>()) );<span class="comment">//全排列的函数，表示还有上一个排列组合</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<img src="/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/image-20230316130707921.png" class title="image-20230316130707921">









<h2 id="6位数能拼出的最晚时间和最早时间"><a href="#6位数能拼出的最晚时间和最早时间" class="headerlink" title="6位数能拼出的最晚时间和最早时间"></a><a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_66952681/article/details/127346134">6位数能拼出的最晚时间和最早时间</a></h2><img src="/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/image-20230315215918667.png" class title="image-20230315215918667">

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 算法思想</span></span><br><span class="line"><span class="comment"> * 1、创建两个相同的数组 元素长度都相同、创建一些变量分别代表最大值、最小值、和这些数字的索引</span></span><br><span class="line"><span class="comment"> * 2、one  two 代表数组内两个数字组成的两位数</span></span><br><span class="line"><span class="comment"> * 3、通过冒泡循环一次得到数组里的两位数one two 依次做出判断是否符合条件，如果符合则one、two分别赋值给对应的变量</span></span><br><span class="line"><span class="comment"> * 如果不符合则寻找下一位两位数、并得到两个数字的索引位</span></span><br><span class="line"><span class="comment"> * 4、出循环之后、需要把得到的索引位置上的数字赋值为0 、 9 (因为已经使用过的数字不得在使用第二次)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>





































<h1 id="分治（二叉树）"><a href="#分治（二叉树）" class="headerlink" title="分治（二叉树）"></a>分治（二叉树）</h1><h2 id="⭐⭐剑指-Offer-07-重建二叉树"><a href="#⭐⭐剑指-Offer-07-重建二叉树" class="headerlink" title="⭐⭐剑指 Offer 07. 重建二叉树"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/zhong-jian-er-cha-shu-lcof/">⭐⭐剑指 Offer 07. 重建二叉树</a></h2><p>输入某二叉树的前序遍历和中序遍历的结果，请构建该二叉树并返回其根节点。</p>
<img src="/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/image-20230316131104437.png" alt="image-20230316131104437" style="zoom: 80%;">

<p>先序和中序，后序和中序都可以确定一棵二叉树。</p>
<p>首先我们都知道，根节点必然是先序遍历中第一个值。我们拿着这个值去中序遍历中找，即可确定该值左侧均为其左子树，右侧均为右子树。有递归的感觉了！</p>
<p>然后如果有左子树，则先序中，根结点的下一个是其左子树的根。如果有右子树，则先序中，去掉其中序左侧部分的值之后的第一个值就是右子树的根节点。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span>		<span class="comment">//脑子不太行，stl熟练度跟不上，。哎</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; preorder, vector&lt;<span class="keyword">int</span>&gt;&amp; inorder)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">recur</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; preorder, vector&lt;<span class="keyword">int</span>&gt;&amp; inorder)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        TreeNode* root=<span class="keyword">new</span> <span class="built_in">TreeNode</span>(preorder[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">if</span>(preorder[<span class="number">0</span>]==inorder[<span class="number">0</span>])<span class="keyword">return</span> root;</span><br><span class="line">        <span class="keyword">int</span> place=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;preorder.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(inorder[i]==preorder[<span class="number">0</span>]) &#123;place=i;<span class="keyword">break</span>; &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(place==<span class="number">0</span>)<span class="keyword">return</span> root;</span><br><span class="line">        root-&gt;left=<span class="built_in">recur</span>(vector&lt;<span class="keyword">int</span>&gt; <span class="built_in">Arrs2</span>(preorder.<span class="built_in">begin</span>() + <span class="number">1</span>, preorder.<span class="built_in">begin</span>() + place),</span><br><span class="line">            vector&lt;<span class="keyword">int</span>&gt; <span class="built_in">Arrs2</span>(inorder.<span class="built_in">begin</span>(), inorder.<span class="built_in">begin</span>() + place)</span><br><span class="line">        );</span><br><span class="line">        root-&gt;right=<span class="built_in">recur</span>(vector&lt;<span class="keyword">int</span>&gt; <span class="built_in">Arrs2</span>(preorder.<span class="built_in">begin</span>() + <span class="number">1</span>+place, preorder.<span class="built_in">end</span>()),</span><br><span class="line">            vector&lt;<span class="keyword">int</span>&gt; <span class="built_in">Arrs2</span>(inorder.<span class="built_in">begin</span>()+<span class="number">1</span>+place, inorder.<span class="built_in">end</span>())</span><br><span class="line">        );</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>很显然，写错了，<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/zhong-jian-er-cha-shu-lcof/solution/cjian-dan-shi-xian-di-gui-by-theowu/">于是乎寻找答案：</a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; preorder, vector&lt;<span class="keyword">int</span>&gt;&amp; inorder)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//递归分治 我想的是传入俩边的int，然后直接截取vector传入，这里直接传迭代器</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">recursionBuild</span>(preorder.<span class="built_in">begin</span>(),preorder.<span class="built_in">end</span>(),inorder.<span class="built_in">begin</span>(),inorder.<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//递归分治</span></span><br><span class="line">    <span class="function">TreeNode* <span class="title">recursionBuild</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;::iterator preBegin, vector&lt;<span class="keyword">int</span>&gt;::iterator preEnd,vector&lt;<span class="keyword">int</span>&gt;::iterator inBegin, vector&lt;<span class="keyword">int</span>&gt;::iterator inEnd )</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(inEnd==inBegin) <span class="keyword">return</span> <span class="literal">NULL</span>;	<span class="comment">//如果传入的头尾一样，则表示为空，返回null</span></span><br><span class="line">        TreeNode* cur = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(*preBegin); <span class="comment">//根结点</span></span><br><span class="line">        <span class="keyword">auto</span> root = <span class="built_in">find</span>(inBegin,inEnd,*preBegin);	<span class="comment">//找到根节点在inorder中位置</span></span><br><span class="line">        cur-&gt;left = <span class="built_in">recursionBuild</span>(preBegin+<span class="number">1</span>,preBegin+<span class="number">1</span>+(root-inBegin),inBegin,root);	<span class="comment">//开始遍历即可</span></span><br><span class="line">        cur-&gt;right = <span class="built_in">recursionBuild</span>(preBegin+<span class="number">1</span>+(root-inBegin),preEnd,root+<span class="number">1</span>,inEnd);</span><br><span class="line">        <span class="keyword">return</span> cur;	<span class="comment">//太聪明了，主要我思想是对的，但是没有写出来啊啊啊啊</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<h2 id="快速幂⭐-数值的整数次方"><a href="#快速幂⭐-数值的整数次方" class="headerlink" title="快速幂⭐ 数值的整数次方"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/shu-zhi-de-zheng-shu-ci-fang-lcof/">快速幂⭐ 数值的整数次方</a></h2><p>实现 <a target="_blank" rel="noopener" href="https://www.cplusplus.com/reference/valarray/pow/">pow(<em>x</em>, <em>n</em>)</a> ，即计算 x 的 n 次幂函数（即，xn）。不得使用库函数，同时不需要考虑<a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_47963315/article/details/124090856">大数问题</a>。</p>
<img src="/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/image-20230316142542879.png" class title="image-20230316142542879">

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span>	<span class="comment">//for循环可以，但是超时！！！</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x==<span class="number">1.0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>)   <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(n&lt;<span class="number">0</span>)&#123; </span><br><span class="line">            x=<span class="number">1</span>/x; </span><br><span class="line">            n=-n; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">double</span> ans=x;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++) ans=ans*x; </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<img src="/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/image-20230316143306919.png" class title="image-20230316143306919">

<p>差不多得了😅😅😅😅😅😅😅😅😅😅😅😅😅😅😅😅😅😅😅😅😅😅😅😅</p>
<p>差点忘了这个板块是分治算法板块，想想快想想。想不出来，寄，没工作了。</p>
<h3 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/shu-zhi-de-zheng-shu-ci-fang-lcof/solution/jian-zhi-offer-16-shu-zhi-de-zheng-shu-c-8u6a/">快速幂</a></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//如 x^11 = x^(1+2+8) = x^(2^0 + 2^1 + 2^3) = x^(1011)_2 = 1 * x^1 + 1 * x^2 + 0 * x^4 + 1 * x^8</span></span><br><span class="line">        <span class="keyword">if</span>(x==<span class="number">1.0</span> || n==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">1.0</span>;</span><br><span class="line">        <span class="keyword">int</span> sign = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">double</span> res = <span class="number">1.0</span>;</span><br><span class="line">        <span class="comment">// 这里要注意一个特殊的数字，n = -2^31，这个数没法用abs取绝对值</span></span><br><span class="line">        <span class="comment">// 解决办法就是先用一个 long long 类型的变量接收 n，然后再用 abs 取绝对值</span></span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> m = n;</span><br><span class="line">        m = <span class="built_in">abs</span>(m);</span><br><span class="line">        <span class="keyword">while</span> (m)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (m &amp; <span class="number">1</span>) res = res * x;   <span class="comment">//&amp;（按位与）运算符 这里表示若m当前二进制位是1，即需要×</span></span><br><span class="line">            m = m &gt;&gt; <span class="number">1</span>; <span class="comment">//&gt;&gt;(右移)运算符</span></span><br><span class="line">            x = x * x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">0</span>) res = <span class="number">1</span> / res;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>x是底数，n是指数，ans是结果，x^n代表的是一个数值，快速幂说白了就是在确保数值不变的情况下，用二分法把数值从指数不断地往底数里面搬。核心是n=n/2, x=x^2这两句代码。但是由于指数可能是奇数，整数除二会丢失一位底数，所以要在ans里面记录奇数轮丢失的底数。</p>
</blockquote>
<p>真的很绝秒，想不到想不到，学习了学习了，应该牢记于心应该牢记于心。</p>
<h2 id="GOOD-二叉搜索树的后序遍历序列"><a href="#GOOD-二叉搜索树的后序遍历序列" class="headerlink" title="GOOD. 二叉搜索树的后序遍历序列"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/">GOOD. 二叉搜索树的后序遍历序列</a></h2><p>输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历结果。如果是则返回 <code>true</code>，否则返回 <code>false</code>。假设输入的数组的任意两个数字都互不相同。</p>
<img src="/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/image-20230316144946171.png" alt="image-20230316144946171" style="zoom:80%;">

<p>后续遍历序列应满足，左右根，则我们从后往前遍历，去找第一个小于根的值；<br>    如果是正确序列，则该值及其左侧均应小于根<br>        我们在对其左右子树进行截取，递归判断其左右子树是否满足<br>    如果不正确，则其左侧必然有大于根的值的存在</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">verifyPostorder</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; sequence)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(sequence.<span class="built_in">empty</span>())<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">       <span class="keyword">return</span> <span class="built_in">recur</span>(sequence);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">recur</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; s)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len=s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(len==<span class="number">0</span> || len==<span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;   <span class="comment">//如果只要单值或null则直接返回</span></span><br><span class="line">        <span class="keyword">int</span> root=s[len<span class="number">-1</span>];  <span class="comment">//标记根的值</span></span><br><span class="line">        <span class="keyword">int</span> cut=len<span class="number">-1</span>;  <span class="comment">//标记左右子树分段点</span></span><br><span class="line">        <span class="keyword">bool</span> isLeftHere =<span class="literal">false</span>; <span class="comment">//标记有无左子树</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=len<span class="number">-2</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i]&lt;root) </span><br><span class="line">            &#123;</span><br><span class="line">                cut=i;  <span class="comment">//先找出后序遍历中，可以将序列分成左右子树的那一分段点(其实如果不满足条件，则该点是假的，我就是基于这个判断写的)</span></span><br><span class="line">                isLeftHere=<span class="literal">true</span>;    <span class="comment">//用来标记有无左子树，如果没有左子树，则直接进入右子树判断</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(isLeftHere==<span class="literal">false</span>)<span class="comment">//如果没有左子树，则直接进入右子树判断</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">v3</span><span class="params">(s.begin(), s.end()<span class="number">-1</span>)</span></span>;</span><br><span class="line">            <span class="keyword">return</span> (<span class="built_in">recur</span>(v3));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;cut;i++)  <span class="comment">//有左子树，那是否有右子树无所谓了</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i]&gt;root)<span class="keyword">return</span> <span class="literal">false</span>;  <span class="comment">//这里是在左子树序列中判断有无比root还大的，若有则不满足规则</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">v1</span><span class="params">(s.begin(), s.begin() +cut)</span></span>;  <span class="comment">//遍历左子树是否满足二叉搜索树</span></span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">v2</span><span class="params">(s.begin()+cut+<span class="number">1</span>, s.end()<span class="number">-1</span>)</span></span>; <span class="comment">//遍历右子树是否满足二叉搜索树</span></span><br><span class="line">        <span class="keyword">return</span> (<span class="built_in">recur</span>(v1) &amp;&amp; <span class="built_in">recur</span>(v2));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h1 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h1><h2 id="剑指-Offer-15-二进制中1的个数"><a href="#剑指-Offer-15-二进制中1的个数" class="headerlink" title="剑指 Offer 15. 二进制中1的个数"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/er-jin-zhi-zhong-1de-ge-shu-lcof/">剑指 Offer 15. 二进制中1的个数</a></h2><p>编写一个函数，输入是一个无符号整数（以二进制串的形式），返回其二进制表达式中数字位数为 ‘1’ 的个数（也被称为 <a target="_blank" rel="noopener" href="http://en.wikipedia.org/wiki/Hamming_weight">汉明重量</a>).）</p>

  </div>
</article>



        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
         
          <li><a href="/">首页</a></li>
         
          <li><a href="/about/">关于</a></li>
         
          <li><a href="/archives/">归档</a></li>
        
      </ul>
    </div>

    <div id="toc-footer" style="display: none">
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#C-%E5%9F%BA%E7%A1%80"><span class="toc-number">1.</span> <span class="toc-text">C++基础</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%80%92%E5%BD%92%E4%B8%8E%E5%88%86%E6%B2%BB%EF%BC%8C%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%8C%E8%B4%AA%E5%BF%83%EF%BC%8C%E5%9B%9E%E6%BA%AF%EF%BC%8C%E5%88%86%E6%94%AF%E7%95%8C%E9%99%90%E6%B3%95"><span class="toc-number">2.</span> <span class="toc-text">递归与分治，动态规划，贪心，回溯，分支界限法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%93%BE%E8%A1%A8"><span class="toc-number">3.</span> <span class="toc-text">链表</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#NC78-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8"><span class="toc-number">3.1.</span> <span class="toc-text">NC78 反转链表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9C%8B%E4%B8%8D%E6%87%82%E9%80%92%E5%BD%92%E7%9A%84%E7%9C%8B%E8%BF%87%E6%9D%A5%EF%BC%8C%E5%B8%8C%E6%9C%9B%E8%83%BD%E5%B8%AE%E5%88%B0%E4%BD%A0%EF%BC%81"><span class="toc-number">3.1.1.</span> <span class="toc-text">看不懂递归的看过来，希望能帮到你！</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8%E3%80%91%EF%BC%9A%E5%8F%8C%E6%8C%87%E9%92%88%EF%BC%8C%E9%80%92%E5%BD%92%EF%BC%8C%E5%A6%96%E9%AD%94%E5%8C%96%E7%9A%84%E5%8F%8C%E6%8C%87%E9%92%88"><span class="toc-number">3.1.2.</span> <span class="toc-text">【反转链表】：双指针，递归，妖魔化的双指针</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BD%BB%E6%9D%BE%E7%89%88%E5%8F%8C%E6%8C%87%E9%92%88"><span class="toc-number">3.1.2.1.</span> <span class="toc-text">轻松版双指针</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%96%E9%AD%94%E5%8C%96%E5%8F%8C%E6%8C%87%E9%92%88"><span class="toc-number">3.1.2.2.</span> <span class="toc-text">妖魔化双指针</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%80%E6%B4%81%E7%9A%84%E9%80%92%E5%BD%92"><span class="toc-number">3.1.2.3.</span> <span class="toc-text">简洁的递归</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%90%9C%E7%B4%A2%E4%B8%8E%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9B%B8%E5%85%B3"><span class="toc-number">4.</span> <span class="toc-text">搜索与回溯算法 二叉树相关</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#32-%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E5%87%BA%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%AF%8F%E4%B8%AA%E8%8A%82%E7%82%B9%EF%BC%8C%E5%90%8C%E4%B8%80%E5%B1%82%E7%9A%84%E8%8A%82%E7%82%B9%E6%8C%89%E7%85%A7%E4%BB%8E%E5%B7%A6%E5%88%B0%E5%8F%B3%E7%9A%84%E9%A1%BA%E5%BA%8F%E6%89%93%E5%8D%B0%E3%80%82"><span class="toc-number">4.0.1.</span> <span class="toc-text">32.从上到下打印出二叉树的每个节点，同一层的节点按照从左到右的顺序打印。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#32-%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%8C%89%E5%B1%82%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%8C%E5%90%8C%E4%B8%80%E5%B1%82%E7%9A%84%E8%8A%82%E7%82%B9%E6%8C%89%E4%BB%8E%E5%B7%A6%E5%88%B0%E5%8F%B3%E7%9A%84%E9%A1%BA%E5%BA%8F%E6%89%93%E5%8D%B0%EF%BC%8C%E6%AF%8F%E4%B8%80%E5%B1%82%E6%89%93%E5%8D%B0%E5%88%B0%E4%B8%80%E8%A1%8C%E3%80%82"><span class="toc-number">4.0.2.</span> <span class="toc-text">32.从上到下按层打印二叉树，同一层的节点按从左到右的顺序打印，每一层打印到一行。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#32-%E8%AF%B7%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%87%BD%E6%95%B0%E6%8C%89%E7%85%A7%E4%B9%8B%E5%AD%97%E5%BD%A2%E9%A1%BA%E5%BA%8F%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%8C%E5%8D%B3%E7%AC%AC%E4%B8%80%E8%A1%8C%E6%8C%89%E7%85%A7%E4%BB%8E%E5%B7%A6%E5%88%B0%E5%8F%B3%E7%9A%84%E9%A1%BA%E5%BA%8F%E6%89%93%E5%8D%B0%EF%BC%8C%E7%AC%AC%E4%BA%8C%E5%B1%82%E6%8C%89%E7%85%A7%E4%BB%8E%E5%8F%B3%E5%88%B0%E5%B7%A6%E7%9A%84%E9%A1%BA%E5%BA%8F%E6%89%93%E5%8D%B0%EF%BC%8C%E7%AC%AC%E4%B8%89%E8%A1%8C%E5%86%8D%E6%8C%89%E7%85%A7%E4%BB%8E%E5%B7%A6%E5%88%B0%E5%8F%B3%E7%9A%84%E9%A1%BA%E5%BA%8F%E6%89%93%E5%8D%B0%EF%BC%8C%E5%85%B6%E4%BB%96%E8%A1%8C%E4%BB%A5%E6%AD%A4%E7%B1%BB%E6%8E%A8%E3%80%82"><span class="toc-number">4.0.3.</span> <span class="toc-text">32.请实现一个函数按照之字形顺序打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右到左的顺序打印，第三行再按照从左到右的顺序打印，其他行以此类推。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#33-%E8%BE%93%E5%85%A5%E4%B8%80%E4%B8%AA%E6%95%B4%E6%95%B0%E6%95%B0%E7%BB%84%EF%BC%8C%E5%88%A4%E6%96%AD%E8%AF%A5%E6%95%B0%E7%BB%84%E6%98%AF%E4%B8%8D%E6%98%AF%E6%9F%90%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E7%BB%93%E6%9E%9C%E3%80%82%E5%A6%82%E6%9E%9C%E6%98%AF%E5%88%99%E8%BF%94%E5%9B%9E-true%EF%BC%8C%E5%90%A6%E5%88%99%E8%BF%94%E5%9B%9E-false%E3%80%82%E5%81%87%E8%AE%BE%E8%BE%93%E5%85%A5%E7%9A%84%E6%95%B0%E7%BB%84%E7%9A%84%E4%BB%BB%E6%84%8F%E4%B8%A4%E4%B8%AA%E6%95%B0%E5%AD%97%E9%83%BD%E4%BA%92%E4%B8%8D%E7%9B%B8%E5%90%8C%E3%80%82"><span class="toc-number">4.0.4.</span> <span class="toc-text">33.输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历结果。如果是则返回 true，否则返回 false。假设输入的数组的任意两个数字都互不相同。</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%EF%BC%9A"><span class="toc-number">4.0.4.1.</span> <span class="toc-text">解题思路：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B7%E4%BD%93%E5%9C%B0%EF%BC%8C%E6%88%91%E4%BB%AC%E5%8F%AF%E4%BB%A5%E9%A6%96%E5%85%88%E6%89%BE%E5%88%B0%E6%A0%B9%E8%8A%82%E7%82%B9%E7%9A%84%E4%BD%8D%E7%BD%AE%EF%BC%8C%E7%84%B6%E5%90%8E%E5%88%86%E5%88%AB%E9%80%92%E5%BD%92%E5%88%A4%E6%96%AD%E5%B7%A6%E5%AD%90%E6%A0%91%E5%92%8C%E5%8F%B3%E5%AD%90%E6%A0%91%E6%98%AF%E5%90%A6%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E3%80%82"><span class="toc-number">4.0.4.2.</span> <span class="toc-text">具体地，我们可以首先找到根节点的位置，然后分别递归判断左子树和右子树是否为二叉搜索树。</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%90%9C%E7%B4%A2%E4%B8%8E%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95-%E6%A0%91%E7%9B%B8%E5%85%B3"><span class="toc-number">5.</span> <span class="toc-text">搜索与回溯算法 树相关</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#26-%E8%BE%93%E5%85%A5%E4%B8%A4%E6%A3%B5%E4%BA%8C%E5%8F%89%E6%A0%91A%E5%92%8CB%EF%BC%8C%E5%88%A4%E6%96%ADB%E6%98%AF%E4%B8%8D%E6%98%AFA%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84%E3%80%82-%E7%BA%A6%E5%AE%9A%E7%A9%BA%E6%A0%91%E4%B8%8D%E6%98%AF%E4%BB%BB%E6%84%8F%E4%B8%80%E4%B8%AA%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84"><span class="toc-number">5.0.1.</span> <span class="toc-text">26.输入两棵二叉树A和B，判断B是不是A的子结构。(约定空树不是任意一个树的子结构)</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%A7%E5%AE%B6%E6%95%B4%E4%BD%93%E9%80%BB%E8%BE%91%E4%B8%80%E8%87%B4%EF%BC%8C%E9%83%BD%E6%98%AF%EF%BC%9A"><span class="toc-number">5.0.1.0.1.</span> <span class="toc-text">大家整体逻辑一致，都是：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AD%90%E5%87%BD%E6%95%B0iscontain%E7%94%A8%E6%9D%A5%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E8%A2%AB%E5%8C%85%E5%90%AB%EF%BC%8C%E9%80%BB%E8%BE%91%E4%B9%9F%E5%BE%88%E7%AE%80%E5%8D%95%EF%BC%9A%E5%A6%82%E6%9E%9CAB%E8%8A%82%E7%82%B9%E7%9B%B8%E7%AD%89%E5%B0%B1%E5%8E%BB%E5%88%A4%E6%96%AD%E5%90%84%E5%AD%90%E6%A0%91%EF%BC%8C%E5%A6%82%E6%9E%9C%E4%B8%8D%E6%83%B3%E7%AD%89%E7%9B%B4%E6%8E%A5%E8%BF%94%E5%9B%9E%E5%81%87%E3%80%82"><span class="toc-number">5.0.1.0.2.</span> <span class="toc-text">子函数iscontain用来判断是否被包含，逻辑也很简单：如果AB节点相等就去判断各子树，如果不想等直接返回假。</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#27-%E8%AF%B7%E5%AE%8C%E6%88%90%E4%B8%80%E4%B8%AA%E5%87%BD%E6%95%B0%EF%BC%8C%E8%BE%93%E5%85%A5%E4%B8%80%E4%B8%AA%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%8C%E8%AF%A5%E5%87%BD%E6%95%B0%E8%BE%93%E5%87%BA%E5%AE%83%E7%9A%84%E9%95%9C%E5%83%8F%E3%80%82"><span class="toc-number">5.0.2.</span> <span class="toc-text">27.请完成一个函数，输入一个二叉树，该函数输出它的镜像。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#28-%E8%AF%B7%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%87%BD%E6%95%B0%EF%BC%8C%E7%94%A8%E6%9D%A5%E5%88%A4%E6%96%AD%E4%B8%80%E6%A3%B5%E4%BA%8C%E5%8F%89%E6%A0%91%E6%98%AF%E4%B8%8D%E6%98%AF%E5%AF%B9%E7%A7%B0%E7%9A%84%E3%80%82%E5%A6%82%E6%9E%9C%E4%B8%80%E6%A3%B5%E4%BA%8C%E5%8F%89%E6%A0%91%E5%92%8C%E5%AE%83%E7%9A%84%E9%95%9C%E5%83%8F%E4%B8%80%E6%A0%B7%EF%BC%8C%E9%82%A3%E4%B9%88%E5%AE%83%E6%98%AF%E5%AF%B9%E7%A7%B0%E7%9A%84%E3%80%82"><span class="toc-number">5.0.3.</span> <span class="toc-text">28.请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92Dynamic-programming-DP"><span class="toc-number">6.</span> <span class="toc-text">动态规划Dynamic programming(DP)</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">6.1.</span> <span class="toc-text">基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%A0%B7%E7%9A%84%E9%97%AE%E9%A2%98%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="toc-number">6.1.1.</span> <span class="toc-text">什么样的问题可以使用动态规划</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%9A%84%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF"><span class="toc-number">6.1.2.</span> <span class="toc-text">动态规划的解题思路</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E7%A9%B7%E4%B8%BE%E5%88%86%E6%9E%90"><span class="toc-number">6.1.2.1.</span> <span class="toc-text">1. 穷举分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E7%A1%AE%E5%AE%9A%E8%BE%B9%E7%95%8C"><span class="toc-number">6.1.2.2.</span> <span class="toc-text">2. 确定边界</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E6%89%BE%E8%A7%84%E5%BE%8B%EF%BC%8C%E7%A1%AE%E5%AE%9A%E6%9C%80%E4%BC%98%E5%AD%90%E7%BB%93%E6%9E%84"><span class="toc-number">6.1.2.3.</span> <span class="toc-text">3. 找规律，确定最优子结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E5%86%99%E5%87%BA%E7%8A%B6%E6%80%81%E8%BD%AC%E7%A7%BB%E6%96%B9%E7%A8%8B"><span class="toc-number">6.1.2.4.</span> <span class="toc-text">4.写出状态转移方程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-number">6.1.2.5.</span> <span class="toc-text">5. 代码实现</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E4%BF%97%E7%9A%84%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E8%A7%A3%E9%A2%98%E6%AD%A5%E9%AA%A4"><span class="toc-number">6.1.3.</span> <span class="toc-text">通俗的动态规划解题步骤</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%84%E9%80%A0dp%E6%95%B0%E7%BB%84"><span class="toc-number">6.1.3.1.</span> <span class="toc-text">构造dp数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B4%E8%A7%82%E4%B8%8A%E7%9A%84%E7%8A%B6%E6%80%81%E8%BD%AC%E7%A7%BB"><span class="toc-number">6.1.3.2.</span> <span class="toc-text">直观上的状态转移</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%BE%E8%A7%84%E5%BE%8B"><span class="toc-number">6.1.3.3.</span> <span class="toc-text">找规律</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%9A%84%E6%9D%A5%E8%AF%B4%EF%BC%8C%E6%8B%BF%E5%88%B0%E4%B8%80%E9%81%93%E9%A2%98%E7%9B%AE%E5%90%8E%EF%BC%8C%E6%88%91%E4%BB%AC%E5%8F%AF%E4%BB%A5%E6%8C%89%E7%85%A7%E4%B8%8B%E9%9D%A2%E7%9A%84%E6%AD%A5%E9%AA%A4%E8%BF%9B%E8%A1%8C%E5%88%86%E6%9E%90%E3%80%81%E5%B0%9D%E8%AF%95%EF%BC%9A"><span class="toc-number">6.1.3.4.</span> <span class="toc-text">总的来说，拿到一道题目后，我们可以按照下面的步骤进行分析、尝试：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%EF%BC%88Fibonacci%EF%BC%89"><span class="toc-number">6.2.</span> <span class="toc-text">斐波那契（Fibonacci）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BE%88%E6%98%8E%E6%98%BE%EF%BC%8C%E7%94%A8%E9%80%92%E5%BD%92%E7%9B%B4%E6%8E%A5%E8%B6%85%E6%97%B6%EF%BC%8C%E8%BF%98%E5%BE%97%E6%98%AF%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%81"><span class="toc-number">6.2.1.</span> <span class="toc-text">很明显，用递归直接超时，还得是动态规划！</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%88%96%E8%80%85%E7%94%A8%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2-%E9%99%8D%E4%BD%8E%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="toc-number">6.2.2.</span> <span class="toc-text">或者用记忆化搜索 降低复杂度</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%92%E8%9B%99%E8%B7%B3%E5%8F%B0%E9%98%B6"><span class="toc-number">6.3.</span> <span class="toc-text">青蛙跳台阶</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E6%9C%89%E5%87%A0%E4%B8%AA%E5%85%B8%E5%9E%8B%E7%89%B9%E5%BE%81%EF%BC%8C%E6%9C%80%E4%BC%98%E5%AD%90%E7%BB%93%E6%9E%84%E3%80%81%E7%8A%B6%E6%80%81%E8%BD%AC%E7%A7%BB%E6%96%B9%E7%A8%8B%E3%80%81%E8%BE%B9%E7%95%8C%E3%80%81%E9%87%8D%E5%8F%A0%E5%AD%90%E9%97%AE%E9%A2%98%E3%80%82%E5%9C%A8%E9%9D%92%E8%9B%99%E8%B7%B3%E9%98%B6%E9%97%AE%E9%A2%98%E4%B8%AD%EF%BC%9A"><span class="toc-number">6.3.1.</span> <span class="toc-text">动态规划有几个典型特征，最优子结构、状态转移方程、边界、重叠子问题。在青蛙跳阶问题中：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E4%BC%98%E5%AD%90%E7%BB%93%E6%9E%84"><span class="toc-number">6.3.2.</span> <span class="toc-text">最优子结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E5%8F%A0%E5%AD%90%E9%97%AE%E9%A2%98"><span class="toc-number">6.3.3.</span> <span class="toc-text">重叠子问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E5%A4%A7%E5%88%A9%E6%B6%A6"><span class="toc-number">6.4.</span> <span class="toc-text">股票的最大利润</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C"><span class="toc-number">6.5.</span> <span class="toc-text">连续子数组的最大和</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF%E4%B8%80"><span class="toc-number">6.5.0.1.</span> <span class="toc-text">思路一</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF%E4%BA%8C"><span class="toc-number">6.5.0.2.</span> <span class="toc-text">思路二</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E4%BA%8E%E5%9B%9E%E6%BA%AF%E6%B3%95%E4%B8%8EDP"><span class="toc-number">6.5.0.3.</span> <span class="toc-text">关于回溯法与DP</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BC%E7%89%A9%E7%9A%84%E6%9C%80%E5%A4%A7%E4%BB%B7%E5%80%BC"><span class="toc-number">6.6.</span> <span class="toc-text">礼物的最大价值</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%92%E5%BD%92%EF%BC%88%E5%9B%9E%E6%BA%AF%E6%B3%95%EF%BC%89%E6%96%B9%E6%B3%95"><span class="toc-number">6.6.1.</span> <span class="toc-text">递归（回溯法）方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2%EF%BC%88%E5%9B%9E%E6%BA%AF%E6%B3%95%EF%BC%89%EF%BC%88%E5%8D%B3%E8%AE%B0%E5%BD%95%E4%B9%8B%E5%89%8D%E7%9A%84%E5%80%BC%EF%BC%89"><span class="toc-number">6.6.2.</span> <span class="toc-text">记忆化搜索（回溯法）（即记录之前的值）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E6%96%B9%E6%B3%95"><span class="toc-number">6.6.3.</span> <span class="toc-text">动态规划方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E5%AD%97%E7%BF%BB%E8%AF%91%E6%88%90%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">6.7.</span> <span class="toc-text">数字翻译成字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BB%E8%A6%81%E6%80%9D%E8%B7%AF"><span class="toc-number">6.7.1.</span> <span class="toc-text">主要思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0"><span class="toc-number">6.7.2.</span> <span class="toc-text">具体实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%AD%90-%E6%9C%80%E9%95%BF%E4%B8%8D%E5%90%AB%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">6.8.</span> <span class="toc-text">⭐ 最长不含重复字符的子字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9A%E5%BC%80%E5%A7%8B%E6%80%9D%E8%B7%AF"><span class="toc-number">6.8.1.</span> <span class="toc-text">刚开始思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BD%A2%EF%BC%8C%E7%9C%8B%E5%AE%98%E6%96%B9%E9%A2%98%E8%A7%A3"><span class="toc-number">6.8.2.</span> <span class="toc-text">罢，看官方题解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8C%E6%8C%87%E9%92%88%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0"><span class="toc-number">6.8.3.</span> <span class="toc-text">双指针具体实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0"><span class="toc-number">6.8.4.</span> <span class="toc-text">动态规划具体实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%A0%E4%B8%BA%E6%AF%8F%E6%AC%A1dp%E7%BB%93%E6%9E%9C%E5%8F%AA%E4%B8%8E%E4%B8%8A%E4%B8%80%E6%AC%A1dp%E7%9A%84%E7%BB%93%E6%9E%9C%E6%9C%89%E5%85%B3%EF%BC%8C%E5%B0%86%E4%B8%8A%E8%BF%B0%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%BE%97%E5%88%B0"><span class="toc-number">6.8.4.1.</span> <span class="toc-text">因为每次dp结果只与上一次dp的结果有关，将上述代码优化空间复杂度得到</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%AD%90%E9%9D%A2%E8%AF%95%E9%A2%98-%E5%AD%97%E6%AF%8D%E4%B8%8E%E6%95%B0%E5%AD%97"><span class="toc-number">6.9.</span> <span class="toc-text">⭐面试题 字母与数字</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%8C%E6%8C%87%E9%92%88"><span class="toc-number">7.</span> <span class="toc-text">双指针</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%91%E6%8C%87-Offer-18-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E8%8A%82%E7%82%B9"><span class="toc-number">7.1.</span> <span class="toc-text">剑指 Offer 18. 删除链表的节点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%91%E6%8C%87-Offer-22-%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E8%8A%82%E7%82%B9"><span class="toc-number">7.2.</span> <span class="toc-text">剑指 Offer 22. 链表中倒数第k个节点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%91%E6%8C%87-Offer-25-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%8E%92%E5%BA%8F%E7%9A%84%E9%93%BE%E8%A1%A8"><span class="toc-number">7.3.</span> <span class="toc-text">剑指 Offer 25. 合并两个排序的链表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%91%E6%8C%87-Offer-52-%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%AC%E5%85%B1%E8%8A%82%E7%82%B9"><span class="toc-number">7.4.</span> <span class="toc-text">剑指 Offer 52. 两个链表的第一个公共节点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%91%E6%8C%87-Offer-21-%E8%B0%83%E6%95%B4%E6%95%B0%E7%BB%84%E9%A1%BA%E5%BA%8F%E4%BD%BF%E5%A5%87%E6%95%B0%E4%BD%8D%E4%BA%8E%E5%81%B6%E6%95%B0%E5%89%8D%E9%9D%A2"><span class="toc-number">7.5.</span> <span class="toc-text">剑指 Offer 21. 调整数组顺序使奇数位于偶数前面</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%91%E6%8C%87-Offer-57-%E5%92%8C%E4%B8%BAs%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%95%B0%E5%AD%97"><span class="toc-number">7.6.</span> <span class="toc-text">剑指 Offer 57. 和为s的两个数字</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%91%E6%8C%87-Offer-58-I-%E7%BF%BB%E8%BD%AC%E5%8D%95%E8%AF%8D%E9%A1%BA%E5%BA%8F"><span class="toc-number">7.7.</span> <span class="toc-text">剑指 Offer 58 - I. 翻转单词顺序</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%90%9C%E7%B4%A2%E4%B8%8E%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%AD%E7%AD%89%EF%BC%89"><span class="toc-number">8.</span> <span class="toc-text">搜索与回溯算法（中等）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%AD%90%E5%89%91%E6%8C%87-Offer-12-%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84"><span class="toc-number">8.1.</span> <span class="toc-text">⭐剑指 Offer 12. 矩阵中的路径</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%AD%90%E9%9D%A2%E8%AF%95%E9%A2%9813-%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E8%BF%90%E5%8A%A8%E8%8C%83%E5%9B%B4"><span class="toc-number">8.2.</span> <span class="toc-text">⭐面试题13. 机器人的运动范围</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B7%B1%E5%BA%A6%E9%81%8D%E5%8E%86-34-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%92%8C%E4%B8%BA%E6%9F%90%E4%B8%80%E5%80%BC%E7%9A%84%E8%B7%AF%E5%BE%84"><span class="toc-number">8.3.</span> <span class="toc-text">深度遍历 34. 二叉树中和为某一值的路径</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%AD%90%E5%89%91%E6%8C%87-Offer-36-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%8E%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8"><span class="toc-number">8.4.</span> <span class="toc-text">⭐剑指 Offer 36. 二叉搜索树与双向链表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%91%E6%8C%87-Offer-54-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E7%AC%ACk%E5%A4%A7%E8%8A%82%E7%82%B9"><span class="toc-number">8.5.</span> <span class="toc-text">剑指 Offer 54. 二叉搜索树的第k大节点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%AD%90%E5%89%91%E6%8C%87-Offer-55-I-%E6%B1%82%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6"><span class="toc-number">8.6.</span> <span class="toc-text">⭐剑指 Offer 55 - I.求二叉树的深度</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%AD%90%E5%89%91%E6%8C%87-Offer-55-II-%E5%88%A4%E6%96%AD%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">8.7.</span> <span class="toc-text">⭐剑指 Offer 55 - II. 判断平衡二叉树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E7%9F%AD%E8%B7%AF%E6%80%A7%E8%B4%A8-%E6%B1%821-2-%E2%80%A6-n"><span class="toc-number">8.8.</span> <span class="toc-text">逻辑运算符的短路性质. 求1+2+…+n</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E7%9F%AD%E8%B7%AF%E6%80%A7%E8%B4%A8"><span class="toc-number">8.8.1.</span> <span class="toc-text">逻辑运算符的短路性质</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%AD%90%E5%89%91%E6%8C%87-Offer-68-I-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88"><span class="toc-number">8.9.</span> <span class="toc-text">⭐剑指 Offer 68 - I. 二叉搜索树的最近公共祖先</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%AD%90%E2%AD%90%E5%89%91%E6%8C%87-Offer-68-II-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88"><span class="toc-number">8.10.</span> <span class="toc-text">⭐⭐剑指 Offer 68 - II. 二叉树的最近公共祖先</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F"><span class="toc-number">9.</span> <span class="toc-text">排序</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%AD%90%E9%9D%A2%E8%AF%95%E9%A2%9845-%E6%8A%8A%E6%95%B0%E7%BB%84%E6%8E%92%E6%88%90%E6%9C%80%E5%B0%8F%E7%9A%84%E6%95%B0"><span class="toc-number">9.1.</span> <span class="toc-text">⭐面试题45. 把数组排成最小的数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%9861-%E6%89%91%E5%85%8B%E7%89%8C%E4%B8%AD%E7%9A%84%E9%A1%BA%E5%AD%90"><span class="toc-number">9.2.</span> <span class="toc-text">面试题61. 扑克牌中的顺子</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%AD%90%E5%BF%AB%E6%8E%92%E5%AE%9E%E7%8E%B0-%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0"><span class="toc-number">9.3.</span> <span class="toc-text">⭐快排实现. 最小的k个数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%91%E6%8C%87-Offer-41-%E6%95%B0%E6%8D%AE%E6%B5%81%E4%B8%AD%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0"><span class="toc-number">9.4.</span> <span class="toc-text">剑指 Offer 41. 数据流中的中位数</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A0%88"><span class="toc-number">10.</span> <span class="toc-text">栈</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#150-%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC"><span class="toc-number">10.1.</span> <span class="toc-text">150. 逆波兰表达式求值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%AD%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%BD%AC%E5%8C%96%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">10.2.</span> <span class="toc-text">中缀表达式转化后缀表达式</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%9A%8F%E6%9C%BA%E7%BB%83%E4%B9%A0"><span class="toc-number">11.</span> <span class="toc-text">随机练习</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%AD%90%E2%AD%90-%E7%BB%99%E5%AE%9A%E6%95%B0%E5%AD%97%E8%83%BD%E7%BB%84%E6%88%90%E7%9A%84%E6%9C%80%E5%A4%A7%E6%97%B6%E9%97%B4"><span class="toc-number">11.1.</span> <span class="toc-text">⭐⭐ 给定数字能组成的最大时间</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%91%E7%8E%B0%EF%BC%8C%E5%8F%AA%E8%A6%81%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%97%B6%EF%BC%8C%E6%8C%89%E7%85%A7%E5%8D%87%E5%BA%8F%E6%8E%92%E5%88%97%EF%BC%8C%E5%8D%B3%E5%8F%AF%E8%BE%93%E5%87%BA%E7%AC%A6%E5%90%88%E8%A7%84%E5%88%99%E7%9A%84%E6%9C%80%E5%B0%8F%E6%97%B6%E9%97%B4"><span class="toc-number">11.1.0.1.</span> <span class="toc-text">发现，只要在排序时，按照升序排列，即可输出符合规则的最小时间</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6%E4%BD%8D%E6%95%B0%E8%83%BD%E6%8B%BC%E5%87%BA%E7%9A%84%E6%9C%80%E6%99%9A%E6%97%B6%E9%97%B4%E5%92%8C%E6%9C%80%E6%97%A9%E6%97%B6%E9%97%B4"><span class="toc-number">11.2.</span> <span class="toc-text">6位数能拼出的最晚时间和最早时间</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%88%86%E6%B2%BB%EF%BC%88%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%89"><span class="toc-number">12.</span> <span class="toc-text">分治（二叉树）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%AD%90%E2%AD%90%E5%89%91%E6%8C%87-Offer-07-%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">12.1.</span> <span class="toc-text">⭐⭐剑指 Offer 07. 重建二叉树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E5%B9%82%E2%AD%90-%E6%95%B0%E5%80%BC%E7%9A%84%E6%95%B4%E6%95%B0%E6%AC%A1%E6%96%B9"><span class="toc-number">12.2.</span> <span class="toc-text">快速幂⭐ 数值的整数次方</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E5%B9%82"><span class="toc-number">12.2.1.</span> <span class="toc-text">快速幂</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#GOOD-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97"><span class="toc-number">12.3.</span> <span class="toc-text">GOOD. 二叉搜索树的后序遍历序列</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BD%8D%E8%BF%90%E7%AE%97"><span class="toc-number">13.</span> <span class="toc-text">位运算</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%91%E6%8C%87-Offer-15-%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0"><span class="toc-number">13.1.</span> <span class="toc-text">剑指 Offer 15. 二进制中1的个数</span></a></li></ol></li></ol>
    </div>

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=http://example.com/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=http://example.com/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/&text=算法合集 C++ 剑指Offer"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=http://example.com/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/&title=算法合集 C++ 剑指Offer"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=http://example.com/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/&is_video=false&description=算法合集 C++ 剑指Offer"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=算法合集 C++ 剑指Offer&body=Check out this article: http://example.com/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/"><i class="fas fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=http://example.com/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/&title=算法合集 C++ 剑指Offer"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=http://example.com/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/&title=算法合集 C++ 剑指Offer"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=http://example.com/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/&title=算法合集 C++ 剑指Offer"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=http://example.com/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/&title=算法合集 C++ 剑指Offer"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=http://example.com/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/&name=算法合集 C++ 剑指Offer&description="><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=http://example.com/2023/03/10/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86%E5%9F%BA%E7%A1%80/&t=算法合集 C++ 剑指Offer"><i class="fab fa-hacker-news fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fas fa-bars fa-lg" aria-hidden="true"></i> 菜单</a>
        <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fas fa-list fa-lg" aria-hidden="true"></i> 目录</a>
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fas fa-share-alt fa-lg" aria-hidden="true"></i> 分享</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up fa-lg" aria-hidden="true"></i> 返回顶部</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy;
    
    
    2021-2023
    Frostsea
  </div>
  <div class="footer-right">
    <nav>
      <ul>
        <!--
       --><li><a href="/">首页</a></li><!--
     --><!--
       --><li><a href="/about/">关于</a></li><!--
     --><!--
       --><li><a href="/archives/">归档</a></li><!--
     -->


     <!--这一段是不蒜子的访问量统计代码-->
<!-- <script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<span id="busuanzi_container_site_pv">本站总访问量<span id="busuanzi_value_site_pv"></span>次 &nbsp;   </span>
<span id="busuanzi_container_site_uv">访客数<span id="busuanzi_value_site_uv"></span>人次</span> -->

      </ul>
    </nav>
  </div>
</footer>

    </div>
    <!-- styles -->



  <link rel="preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.2/css/all.min.css" crossorigin="anonymous" onload="this.onload=null;this.rel='stylesheet'"/>


    <!-- jquery -->
 
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js" crossorigin="anonymous"></script> 




<!-- clipboard -->

  
    <script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.7/clipboard.min.js" crossorigin="anonymous"></script> 
  
  <script type="text/javascript">
  $(function() {
    // copy-btn HTML
    var btn = "<span class=\"btn-copy tooltipped tooltipped-sw\" aria-label=\"复制到粘贴板！\">";
    btn += '<i class="far fa-clone"></i>';
    btn += '</span>'; 
    // mount it!
    $(".highlight table").before(btn);
    var clip = new ClipboardJS('.btn-copy', {
      text: function(trigger) {
        return Array.from(trigger.nextElementSibling.querySelectorAll('.code')).reduce((str,it)=>str+it.innerText+'\n','')
      }
    });
    clip.on('success', function(e) {
      e.trigger.setAttribute('aria-label', "复制成功！");
      e.clearSelection();
    })
  })
  </script>


<script src="/js/main.js"></script>

<!-- search -->

<!-- Google Analytics -->

<!-- Baidu Analytics -->

<!-- Cloudflare Analytics -->

<!-- Umami Analytics -->

<!-- Disqus Comments -->

<!-- utterances Comments -->

</body>
</html>
